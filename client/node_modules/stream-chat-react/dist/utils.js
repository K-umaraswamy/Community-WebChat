var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import React from 'react';
import emojiRegex from 'emoji-regex';
import { find } from 'linkifyjs';
import { nanoid } from 'nanoid';
import { findAndReplace } from 'hast-util-find-and-replace';
import ReactMarkdown, { uriTransformer } from 'react-markdown';
import { u } from 'unist-builder';
import { visit } from 'unist-util-visit';
import remarkGfm from 'remark-gfm';
import uniqBy from 'lodash.uniqby';
import clsx from 'clsx';
export var isOnlyEmojis = function (text) {
    if (!text)
        return false;
    var noEmojis = text.replace(emojiRegex(), '');
    var noSpace = noEmojis.replace(/[\s\n]/gm, '');
    return !noSpace;
};
var allowedMarkups = [
    'html',
    'text',
    'br',
    'p',
    'em',
    'strong',
    'a',
    'ol',
    'ul',
    'li',
    'code',
    'pre',
    'blockquote',
    'del',
    // custom types (tagNames)
    'emoji',
    'mention',
];
export var matchMarkdownLinks = function (message) {
    var regexMdLinks = /\[([^[]+)\](\(.*\))/gm;
    var matches = message.match(regexMdLinks);
    var singleMatch = /\[([^[]+)\]\((.*)\)/;
    var links = matches
        ? matches.map(function (match) {
            var i = singleMatch.exec(match);
            return i && [i[1], i[2]];
        })
        : [];
    return links.flat();
};
export var messageCodeBlocks = function (message) {
    var codeRegex = /```[a-z]*\n[\s\S]*?\n```|`[a-z]*[\s\S]*?`/gm;
    var matches = message.match(codeRegex);
    return matches || [];
};
var detectHttp = /(http(s?):\/\/)?(www\.)?/;
function formatUrlForDisplay(url) {
    try {
        return decodeURIComponent(url).replace(detectHttp, '');
    }
    catch (e) {
        return url;
    }
}
function encodeDecode(url) {
    try {
        return encodeURI(decodeURIComponent(url));
    }
    catch (error) {
        return url;
    }
}
var Anchor = function (_a) {
    var children = _a.children, href = _a.href;
    var isEmail = href === null || href === void 0 ? void 0 : href.startsWith('mailto:');
    var isUrl = href === null || href === void 0 ? void 0 : href.startsWith('http');
    if (!href || (!isEmail && !isUrl))
        return React.createElement(React.Fragment, null, children);
    return (React.createElement("a", { className: clsx({ 'str-chat__message-url-link': isUrl }), href: href, rel: 'nofollow noreferrer noopener', target: '_blank' }, children));
};
var Emoji = function (_a) {
    var children = _a.children;
    return (React.createElement("span", { className: 'inline-text-emoji', "data-testid": 'inline-text-emoji' }, children));
};
var Mention = function (_a) {
    var children = _a.children, mentionedUser = _a.node.mentionedUser;
    return (React.createElement("span", { className: 'str-chat__message-mention', "data-user-id": mentionedUser.id }, children));
};
export var markDownRenderers = {
    a: Anchor,
    emoji: Emoji,
    mention: Mention,
};
export var emojiMarkdownPlugin = function () {
    var replace = function (match) {
        return u('element', { tagName: 'emoji' }, [u('text', match)]);
    };
    var transform = function (node) { return findAndReplace(node, emojiRegex(), replace); };
    return transform;
};
export var mentionsMarkdownPlugin = function (mentioned_users) { return function () {
    var mentioned_usernames = mentioned_users
        .map(function (user) { return user.name || user.id; })
        .filter(Boolean)
        .map(escapeRegExp);
    var mentionedUsersRegex = new RegExp(mentioned_usernames.map(function (username) { return "@".concat(username); }).join('|'), 'g');
    var replace = function (match) {
        var usernameOrId = match.replace('@', '');
        var user = mentioned_users.find(function (_a) {
            var id = _a.id, name = _a.name;
            return name === usernameOrId || id === usernameOrId;
        });
        return u('element', { mentionedUser: user, tagName: 'mention' }, [u('text', match)]);
    };
    var transform = function (tree) {
        if (!mentioned_usernames.length)
            return tree;
        // handles special cases of mentions where user.name is an e-mail
        // Remark GFM translates all e-mail-like text nodes to links creating
        // two separate child nodes "@" and "your.name@as.email" instead of
        // keeping it as one text node with value "@your.name@as.email"
        // this piece finds these two separated nodes and merges them together
        // before "replace" function takes over
        visit(tree, function (node, index, parent) {
            var _a;
            if (index === null)
                return;
            if (!parent)
                return;
            var nextChild = parent.children.at(index + 1);
            var nextChildHref = (_a = nextChild === null || nextChild === void 0 ? void 0 : nextChild.properties) === null || _a === void 0 ? void 0 : _a.href;
            if (node.type === 'text' &&
                // text value has to have @ sign at the end of the string
                // and no other characters except whitespace can precede it
                // valid cases:   "text @", "@", " @"
                // invalid cases: "text@", "@text",
                /.?\s?@$|^@$/.test(node.value) &&
                (nextChildHref === null || nextChildHref === void 0 ? void 0 : nextChildHref.startsWith('mailto:'))) {
                var newTextValue = node.value.replace(/@$/, '');
                var username = nextChildHref.replace('mailto:', '');
                parent.children[index] = u('text', newTextValue);
                parent.children[index + 1] = u('text', "@".concat(username));
            }
        });
        return findAndReplace(tree, mentionedUsersRegex, replace);
    };
    return transform;
}; };
export var renderText = function (text, mentionedUsers, _a) {
    var _b = _a === void 0 ? {} : _a, customMarkDownRenderers = _b.customMarkDownRenderers;
    // take the @ mentions and turn them into markdown?
    // translate links
    if (!text)
        return null;
    if (text.trim().length === 1)
        return React.createElement(React.Fragment, null, text);
    var newText = text;
    var markdownLinks = matchMarkdownLinks(newText);
    var codeBlocks = messageCodeBlocks(newText);
    // extract all valid links/emails within text and replace it with proper markup
    uniqBy(__spreadArray(__spreadArray([], find(newText, 'email'), true), find(newText, 'url'), true), 'value').forEach(function (_a) {
        var href = _a.href, type = _a.type, value = _a.value;
        var linkIsInBlock = codeBlocks.some(function (block) { return block === null || block === void 0 ? void 0 : block.includes(value); });
        // check if message is already  markdown
        var noParsingNeeded = markdownLinks &&
            markdownLinks.filter(function (text) {
                var strippedHref = href === null || href === void 0 ? void 0 : href.replace(detectHttp, '');
                var strippedText = text === null || text === void 0 ? void 0 : text.replace(detectHttp, '');
                if (!strippedHref || !strippedText)
                    return false;
                return strippedHref.includes(strippedText) || strippedText.includes(strippedHref);
            });
        if (noParsingNeeded.length > 0 || linkIsInBlock)
            return;
        try {
            // special case for mentions:
            // it could happen that a user's name matches with an e-mail format pattern.
            // in that case, we check whether the found e-mail is actually a mention
            // by naively checking for an existence of @ sign in front of it.
            if (type === 'email' && mentionedUsers) {
                var emailMatchesWithName = mentionedUsers.some(function (u) { return u.name === value; });
                if (emailMatchesWithName) {
                    newText = newText.replace(new RegExp(escapeRegExp(value), 'g'), function (match, position) {
                        var isMention = newText.charAt(position - 1) === '@';
                        // in case of mention, we leave the match in its original form,
                        // and we let `mentionsMarkdownPlugin` to do its job
                        return isMention ? match : "[".concat(match, "](").concat(encodeDecode(href), ")");
                    });
                    return;
                }
            }
            var displayLink = type === 'email' ? value : formatUrlForDisplay(href);
            newText = newText.replace(new RegExp(escapeRegExp(value), 'g'), "[".concat(displayLink, "](").concat(encodeDecode(href), ")"));
        }
        catch (e) {
            void e;
        }
    });
    var rehypePlugins = [emojiMarkdownPlugin];
    if (mentionedUsers === null || mentionedUsers === void 0 ? void 0 : mentionedUsers.length) {
        rehypePlugins.push(mentionsMarkdownPlugin(mentionedUsers));
    }
    // TODO: remove in the next major release
    if (customMarkDownRenderers === null || customMarkDownRenderers === void 0 ? void 0 : customMarkDownRenderers.mention) {
        var MentionComponent_1 = customMarkDownRenderers['mention'];
        // eslint-disable-next-line react/display-name
        customMarkDownRenderers['mention'] = function (_a) {
            var node = _a.node, rest = __rest(_a, ["node"]);
            return (React.createElement(MentionComponent_1
            // @ts-ignore
            , __assign({ 
                // @ts-ignore
                mentioned_user: node.mentionedUser, 
                // @ts-ignore
                node: __assign({ mentioned_user: node.mentionedUser }, node) }, rest)));
        };
    }
    var rehypeComponents = __assign(__assign({}, markDownRenderers), customMarkDownRenderers);
    return (React.createElement(ReactMarkdown, { allowedElements: allowedMarkups, components: rehypeComponents, rehypePlugins: rehypePlugins, remarkPlugins: [[remarkGfm, { singleTilde: false }]], skipHtml: true, transformLinkUri: function (uri) { return (uri.startsWith('app://') ? uri : uriTransformer(uri)); }, unwrapDisallowed: true }, newText));
};
export function escapeRegExp(text) {
    return text.replace(/[-[\]{}()*+?.,/\\^$|#]/g, '\\$&');
}
/**
 * @deprecated will be removed in the next major release
 */
export var generateRandomId = nanoid;
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charAt#getting_whole_characters
export var getWholeChar = function (str, i) {
    var code = str.charCodeAt(i);
    if (Number.isNaN(code))
        return '';
    if (code < 0xd800 || code > 0xdfff)
        return str.charAt(i);
    if (0xd800 <= code && code <= 0xdbff) {
        if (str.length <= i + 1) {
            throw 'High surrogate without following low surrogate';
        }
        var next = str.charCodeAt(i + 1);
        if (0xdc00 > next || next > 0xdfff) {
            throw 'High surrogate without following low surrogate';
        }
        return str.charAt(i) + str.charAt(i + 1);
    }
    if (i === 0) {
        throw 'Low surrogate without preceding high surrogate';
    }
    var prev = str.charCodeAt(i - 1);
    if (0xd800 > prev || prev > 0xdbff) {
        throw 'Low surrogate without preceding high surrogate';
    }
    return '';
};
