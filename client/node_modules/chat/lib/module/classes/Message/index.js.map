{"version":3,"sources":["index.ts"],"names":["recipientHasId","recipientHasMembers","isNewMessageModel","fuego","chat","Room","message","recipients","send","firebase","functions","httpsCallable","httpCallables","sendMessageToRooms","Error","createdAt","firestore","FieldValue","serverTimestamp","console","error","data","sendMessageToPeople","sendMessageToGroup","to","batch","db","promises","forEach","room","id","messagesPath","ref","collection","doc","set","peopleInThisRoomOtherThanMe","slice","sort","a","b","addMessage","sendMessageFromFeed","newMessage","push","Promise","all","commit","roomId","addToFirebase","updateOnFirebase","isDocList","m","isDocument","map","toDate","e","isNew","text","trim","messages","updateBatch","addToBatch","roomPath","path","messageDoc","auth","currentUser","displayName","uid","roomRef","lastMessage","name","system","update","Array","isArray","merge","reaction","roomMembers","users","warn","reactions"],"mappings":"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","sourcesContent":["import {\n\tMessageModel,\n\tEditMessageModel,\n\tRoomId,\n\tNewMessageModel,\n\tMessageModelDocument,\n\tSendFromFeedRecipients,\n\trecipientHasId,\n\trecipientHasMembers,\n\tSendFromFeedModel,\n\tisNewMessageModel,\n\tNewMessageFormattedForServer\n} from './types'\nimport { fuego, chat } from '../../components/ChatProvider/index'\nimport Room from '../Room'\nimport { LastMessageServer, RoomMembers, RoomMember } from '../Room/types'\nimport { ReactionOption } from '../Reaction/types'\n\nexport default class {\n\tprivate message: MessageModel\n\tconstructor(message: MessageModel) {\n\t\tthis.message = message\n\t}\n\t/**\n\t * A function to send one message to many different existing rooms/group chats separately.\n\t *\n\t * @param recipients An array of rooms ids where this message will be sent to separately\n\t * @returns Promise that returns a room ID if there is only one (or promise that resolves as null if the message object isn't valid)\n\t */\n\tasync sendToRooms(recipients: string[]) {\n\t\ttry {\n\t\t\tconst send = fuego.firebase\n\t\t\t\t.functions()\n\t\t\t\t.httpsCallable(chat.httpCallables.sendMessageToRooms)\n\t\t\tif (!isNewMessageModel(this.message)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'FAILED TO SEND TO ROOMS: message object is not NewMessageModel'\n\t\t\t\t)\n\t\t\t}\n\t\t\tthis.message = {\n\t\t\t\t...this.message,\n\t\t\t\tcreatedAt: fuego.firebase.firestore.FieldValue.serverTimestamp()\n\t\t\t} as NewMessageFormattedForServer\n\t\t\treturn send({\n\t\t\t\tmessage: this.message,\n\t\t\t\trecipients\n\t\t\t})\n\t\t} catch (e) {\n\t\t\tconsole.error(e)\n\t\t\treturn {\n\t\t\t\tdata: null\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * A function to send one message to many different people individually.\n\t * For each recipient, if a room for them doesn't exist, it will get created and the message will be added to it.\n\t * If the room does exist, the message will be added to it.\n\t *\n\t * @param recipients An array of user ids whom this message will be sent to separately\n\t * @returns Promise that returns a room ID (or promise that resolves as null if the message object isn't valid)\n\t */\n\tasync sendToPeople(recipients: string[]) {\n\t\tconst send = fuego.firebase\n\t\t\t.functions()\n\t\t\t.httpsCallable(chat.httpCallables.sendMessageToPeople)\n\t\ttry {\n\t\t\tif (!isNewMessageModel(this.message)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'FAILED TO SEND TO PEOPLE: message object is not NewMessageModel'\n\t\t\t\t)\n\t\t\t}\n\t\t\tthis.message = {\n\t\t\t\t...this.message,\n\t\t\t\tcreatedAt: fuego.firebase.firestore.FieldValue.serverTimestamp()\n\t\t\t} as NewMessageFormattedForServer\n\t\t\treturn send({\n\t\t\t\tmessage: this.message,\n\t\t\t\trecipients\n\t\t\t})\n\t\t} catch (e) {\n\t\t\tconsole.error(e)\n\t\t\treturn {\n\t\t\t\tdata: null\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Sends message to a group. This is useful when you don't have a room id but do have a list of people you want to send a message to. If you want to send the message to them separately, try sendToPeople instead.\n\t * This function will create a group chat with the specified users if one doesn't exist yet. If it does exist already, then it will add to that existing room.\n\t * @param recipients Array of uids for people in the group this message should send to.\n\t * @returns Promise that returns a room ID (or promise that resolves as null if the message object isn't valid)\n\t */\n\tasync sendToGroup(recipients: string[]) {\n\t\tconst send = fuego.firebase\n\t\t\t.functions()\n\t\t\t.httpsCallable(chat.httpCallables.sendMessageToGroup)\n\t\ttry {\n\t\t\tif (!isNewMessageModel(this.message)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'FAILED TO SEND TO PEOPLE: message object is not NewMessageModel'\n\t\t\t\t)\n\t\t\t}\n\t\t\tthis.message = {\n\t\t\t\t...this.message,\n\t\t\t\tcreatedAt: fuego.firebase.firestore.FieldValue.serverTimestamp()\n\t\t\t} as NewMessageFormattedForServer\n\t\t\treturn send({\n\t\t\t\tmessage: this.message,\n\t\t\t\trecipients\n\t\t\t})\n\t\t} catch (e) {\n\t\t\tconsole.error(e)\n\t\t\treturn {\n\t\t\t\tdata: null\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t *  deprecated: fuck this function\n\t */\n\tsendFromFeed(to: SendFromFeedRecipients) {\n\t\tconst batch = fuego.db.batch()\n\t\tconst promises: Promise<firebase.functions.HttpsCallableResult>[] = []\n\n\t\t// the to variable is an array of dictionaries\n\t\t// the dictionaries can be EITHER { id: string } or { recipients: Array<recipient> }\n\t\t// example:\n\t\t// you might send a message to five different places\n\t\t// could be 3 people, and 2 existing rooms\n\t\t// this would be an array of 5 items, 3 with recipients, 2 with id\n\t\t// example of the array:\n\t\t// [\n\t\t// 1) send to a room that has these two users\n\t\t// { recipients: [{id: uid, name: username }, {uid: uid2, name: name2 }]},\n\t\t// 2) send to an already existing room (likely pressing a group)\n\t\t// { id: roomId },\n\t\t// 3) send to one person, unaware if this room exists\n\t\t// { recipients: [{id: uid, name: username }]},\n\t\t// ]\n\n\t\t// now, set of people we're sending this to...\n\t\tto.forEach(room => {\n\t\t\tconst { id, ...message } = this.message as NewMessageModel\n\t\t\tif (recipientHasId(room)) {\n\t\t\t\t// if this recipient is a specified room, then send to that\n\t\t\t\tconst { messagesPath } = new Room({ id: room.id })\n\t\t\t\tconst ref = fuego.db.collection(messagesPath).doc(id)\n\t\t\t\tbatch.set(ref, message)\n\t\t\t} else if (recipientHasMembers(room)) {\n\t\t\t\t// otherwise, if you're just sending to a list of ambigious recipients...\n\t\t\t\t// note: this list will often be one person you're choosing from a feed\n\t\t\t\t// list could be: { recipients: [{ name: string, id: string }, { ...otherRecipient }]}\n\t\t\t\tconst peopleInThisRoomOtherThanMe = room.recipients\n\t\t\t\t\t.slice()\n\t\t\t\t\t.sort((a, b) => (a.id > b.id ? 1 : -1))\n\t\t\t\tconst addMessage = fuego.firebase\n\t\t\t\t\t.functions()\n\t\t\t\t\t.httpsCallable(chat.httpCallables.sendMessageFromFeed)\n\t\t\t\tconst newMessage: SendFromFeedModel = {\n\t\t\t\t\t...(message as NewMessageModel),\n\t\t\t\t\trecipients: peopleInThisRoomOtherThanMe\n\t\t\t\t}\n\t\t\t\tpromises.push(addMessage(newMessage))\n\t\t\t}\n\t\t})\n\n\t\treturn Promise.all<any>([batch.commit(), ...promises])\n\n\t\t// return {\n\t\t// \tbatch: () => batch.commit(),\n\t\t// \ttoRecipients: () => Promise.all(promises)\n\t\t// }\n\t}\n\t/**\n\t * Send message by adding it directly to the backend\n\t * @param roomId The id of the room you want to send this to. Could also be an array of ids, if the same message should go to multiple rooms.\n\t */\n\tsend(roomId: RoomId) {\n\t\tthis.addToFirebase(roomId)\n\t}\n\tedit(roomId: string) {\n\t\treturn this.updateOnFirebase(roomId)\n\t}\n\tformatForRender(): NewMessageModel[] | NewMessageModel | null {\n\t\tfunction isDocList(m: MessageModel): m is MessageModelDocument[] {\n\t\t\treturn !!(m as MessageModelDocument[])\n\t\t}\n\t\tfunction isDocument(m: MessageModel): m is MessageModelDocument {\n\t\t\treturn !!(m as MessageModelDocument)\n\t\t}\n\t\ttry {\n\t\t\tif (isDocList(this.message)) {\n\t\t\t\treturn (\n\t\t\t\t\t(this.message as MessageModelDocument[]).map(\n\t\t\t\t\t\t(doc: MessageModelDocument) => ({\n\t\t\t\t\t\t\t...doc,\n\t\t\t\t\t\t\tid: doc.id,\n\t\t\t\t\t\t\tcreatedAt: doc.createdAt.toDate()\n\t\t\t\t\t\t})\n\t\t\t\t\t) || []\n\t\t\t\t)\n\t\t\t}\n\t\t\tif (isDocument(this.message))\n\t\t\t\treturn {\n\t\t\t\t\t...this.message,\n\t\t\t\t\tid: this.message.id,\n\t\t\t\t\tcreatedAt: this.message.createdAt.toDate()\n\t\t\t\t}\n\n\t\t\tthrow new Error('Wrong model here.')\n\t\t} catch (e) {\n\t\t\tconsole.error(\n\t\t\t\t'wrong model given to format for render in Message class.',\n\t\t\t\te\n\t\t\t)\n\t\t\treturn null\n\t\t}\n\t}\n\tformatForSend() {\n\t\ttry {\n\t\t\tconst isNew = (m: MessageModel): m is NewMessageModel[] =>\n\t\t\t\t!!(m as NewMessageModel[])\n\t\t\tif (isNew(this.message)) {\n\t\t\t\tthis.message = (this.message as NewMessageModel[]).map(message => ({\n\t\t\t\t\t...message,\n\t\t\t\t\ttext: (message.text && message.text.trim()) || '',\n\t\t\t\t\tcreatedAt: fuego.firebase.firestore.FieldValue.serverTimestamp()\n\t\t\t\t})) as NewMessageFormattedForServer[]\n\t\t\t\treturn this\n\t\t\t}\n\t\t\tthrow new Error('wrong format for formatting for send')\n\t\t} catch (e) {\n\t\t\tconsole.error(e)\n\t\t\treturn this\n\t\t}\n\t}\n\taddToFirebase(roomId: RoomId) {\n\t\tconst { message: messages } = this\n\n\t\tconst batch = fuego.db.batch()\n\n\t\tconst updateBatch = (roomId: string) => {\n\t\t\t// for each message, add to this batch...\n\t\t\tconst addToBatch = (message: NewMessageFormattedForServer) => {\n\t\t\t\ttry {\n\t\t\t\t\tconst { messagesPath, path: roomPath } = new Room({ id: roomId })\n\t\t\t\t\tconst ref = fuego.db.collection(messagesPath).doc(message.id)\n\n\t\t\t\t\t// remove id from message for single source of truth\n\t\t\t\t\t// it'll be put back again upon format()-ing\n\t\t\t\t\tconst { id, ...messageDoc } = message\n\t\t\t\t\tbatch.set(ref, messageDoc)\n\n\t\t\t\t\t// update the latest message\n\t\t\t\t\tconst { displayName, uid } = fuego.auth().currentUser as firebase.User\n\t\t\t\t\tconst roomRef = fuego.db.doc(roomPath)\n\t\t\t\t\tconst lastMessage: LastMessageServer = {\n\t\t\t\t\t\tname: displayName || 'Name failed',\n\t\t\t\t\t\tid: uid,\n\t\t\t\t\t\tsystem: false,\n\t\t\t\t\t\ttext: message.text,\n\t\t\t\t\t\tcreatedAt: message.createdAt\n\t\t\t\t\t}\n\t\t\t\t\tbatch.update(roomRef, { lastMessage })\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error('sending message had an error:', e)\n\t\t\t\t}\n\t\t\t}\n\t\t\t;(messages as NewMessageFormattedForServer[]).forEach(addToBatch)\n\t\t}\n\n\t\t// if you're sending these message(s) to multiple rooms, loop through each room...\n\t\tif (Array.isArray(roomId)) {\n\t\t\t;(roomId as string[]).forEach(updateBatch)\n\t\t} else {\n\t\t\t// just send to this room\n\t\t\tupdateBatch(roomId as string)\n\t\t}\n\t\t// once everything has been added to the db batch, commit it\n\t\treturn batch.commit()\n\t}\n\tupdateOnFirebase(roomId: string) {\n\t\tconst { path } = new Room({ id: roomId })\n\t\tconst { id, ...message } = this.message as EditMessageModel\n\t\treturn fuego.db\n\t\t\t.collection(path)\n\t\t\t.doc((this.message as EditMessageModel).id)\n\t\t\t.set(message, { merge: true })\n\t}\n\t// TODO get members through some other method...idk\n\t// eek. what a mess.\n\tgetUsersWhoReacted(\n\t\treaction: ReactionOption,\n\t\t{ roomMembers }: { roomMembers: RoomMembers }\n\t): RoomMember[] {\n\t\tconst users: RoomMember[] = []\n\t\tif (!isNewMessageModel(this.message)) {\n\t\t\tconsole.warn(\n\t\t\t\t'error getting users who reacted. Needs the new message model passed as an argument, but instead it got this:',\n\t\t\t\tthis.message\n\t\t\t)\n\t\t} else if (this.message.reactions) {\n\t\t\tthis.message.reactions[reaction].forEach(\n\t\t\t\tuid => roomMembers[uid] && users.push(roomMembers[uid])\n\t\t\t)\n\t\t}\n\t\treturn users\n\t}\n}\n"]}