import React from 'react'
import { View, StyleSheet } from 'react-native'
import { LinearGradient } from 'expo-linear-gradient'
import Animated, { Easing } from 'react-native-reanimated'

const {
	Value,
	useCode,
	interpolate,
	Clock,
	set,
	block,
	startClock,
	cond,
	stopClock,
	timing
} = Animated

const dots = [1, 2, 3]
const length = dots.length

export default function(props: TypingIndicatorProps) {
	const animatedValue = new Value(0)
	const config = {
		duration: 2500,
		toValue: new Value(length + 1),
		easing: Easing.inOut(Easing.linear)
	}
	useCode(() => set(animatedValue, runLoop(config)), [animatedValue])

	const { theme = 'red' } = props

	if (props.hide) return null

	const renderDot = (index: number) => {
		const opacity = interpolate(animatedValue, {
			inputRange: [index - 1, index, index + 1],
			outputRange: [0, 1, 0]
		})
		return (
			<View key={index.toString()} style={styles.dot}>
				<LinearGradient
					{...{
						colors: props.dotEmptyColors || themes[theme].emptyDotColors,
						start: [0.9, 0.9],
						end: [0.1, 0.1]
					}}
					style={{ flex: 1 }}
				/>
				<Animated.View style={{ opacity, ...StyleSheet.absoluteFillObject }}>
					<LinearGradient
						{...{
							colors: props.dotColors || themes[theme].dotColors,
							start: [0.1, 0.1],
							end: [0.9, 0.9]
						}}
						style={{ flex: 1 }}
					/>
				</Animated.View>
			</View>
		)
	}
	return (
		<View style={styles.container}>
			<LinearGradient
				{...{
					colors: props.backgroundColors || themes[theme].backgroundColors,
					start: [0.1, 0.1],
					end: [0.9, 0.9]
				}}
				style={styles.wrapper}
			>
				<View style={styles.dots}>{dots.map(renderDot)}</View>
			</LinearGradient>
		</View>
	)
}

const themes = {
	purple: {
		backgroundColors: ['#7950f2', '#5f3dc4'],
		dotColors: ['white', 'white'],
		emptyDotColors: ['#adb5bd', '#adb5bd']
	},
	red: {
		backgroundColors: ['#E5E5EA', '#E5E5EA'],
		dotColors: ['#ff8000', '#ec2a80'],
		emptyDotColors: ['#D1D1D6', '#D1D1D6']
	},
	default: {
		backgroundColors: ['#E5E5EA', '#E5E5EA'],
		dotColors: ['#8E8E93', '#8E8E93'],
		emptyDotColors: ['#D1D1D6', '#D1D1D6']
	}
}

export interface TypingIndicatorProps {
	hide?: boolean
	backgroundColors?: string[]
	dotColors?: string[]
	dotEmptyColors?: string[]
	theme?: 'purple' | 'red' | 'default'
}

const dotSize = 9
const padding = dotSize / 4
const paddingVertical = padding * 5
const totalHeight = dotSize + paddingVertical * 2

const styles = StyleSheet.create({
	container: {
		alignItems: 'flex-start'
	},
	wrapper: {
		paddingHorizontal: padding * 3,
		paddingVertical,
		borderRadius: totalHeight / 2
	},
	dots: {
		flexDirection: 'row'
	},
	dot: {
		height: dotSize,
		width: dotSize,
		borderRadius: dotSize / 2,
		backgroundColor: 'white',
		marginHorizontal: padding,
		overflow: 'hidden'
	}
})

function runLoop(config: Animated.TimingConfig) {
	const clock = new Clock()

	const state = {
		finished: new Value(0),
		position: new Value(0),
		time: new Value(0),
		frameTime: new Value(0)
	}

	return block([
		// start right away
		startClock(clock),

		// process your state
		timing(clock, state, config),

		// when over (processed by timing at the end)
		cond(state.finished, [
			// we stop
			stopClock(clock),

			// set flag ready to be restarted
			set(state.finished, 0),
			// same value as the initial defined in the state creation
			set(state.position, 0),

			// very important to reset this ones !!! as mentioned in the doc about timing is saying
			set(state.time, 0),
			set(state.frameTime, 0),

			// and we restart
			startClock(clock)
		]),

		state.position
	])
}
