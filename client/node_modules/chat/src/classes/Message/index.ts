import {
	MessageModel,
	EditMessageModel,
	RoomId,
	NewMessageModel,
	MessageModelDocument,
	SendFromFeedRecipients,
	recipientHasId,
	recipientHasMembers,
	SendFromFeedModel,
	isNewMessageModel,
	NewMessageFormattedForServer
} from './types'
import { fuego, chat } from '../../components/ChatProvider/index'
import Room from '../Room'
import { LastMessageServer, RoomMembers, RoomMember } from '../Room/types'
import { ReactionOption } from '../Reaction/types'

export default class {
	private message: MessageModel
	constructor(message: MessageModel) {
		this.message = message
	}
	/**
	 * A function to send one message to many different existing rooms/group chats separately.
	 *
	 * @param recipients An array of rooms ids where this message will be sent to separately
	 * @returns Promise that returns a room ID if there is only one (or promise that resolves as null if the message object isn't valid)
	 */
	async sendToRooms(recipients: string[]) {
		try {
			const send = fuego.firebase
				.functions()
				.httpsCallable(chat.httpCallables.sendMessageToRooms)
			if (!isNewMessageModel(this.message)) {
				throw new Error(
					'FAILED TO SEND TO ROOMS: message object is not NewMessageModel'
				)
			}
			this.message = {
				...this.message,
				createdAt: fuego.firebase.firestore.FieldValue.serverTimestamp()
			} as NewMessageFormattedForServer
			return send({
				message: this.message,
				recipients
			})
		} catch (e) {
			console.error(e)
			return {
				data: null
			}
		}
	}
	/**
	 * A function to send one message to many different people individually.
	 * For each recipient, if a room for them doesn't exist, it will get created and the message will be added to it.
	 * If the room does exist, the message will be added to it.
	 *
	 * @param recipients An array of user ids whom this message will be sent to separately
	 * @returns Promise that returns a room ID (or promise that resolves as null if the message object isn't valid)
	 */
	async sendToPeople(recipients: string[]) {
		const send = fuego.firebase
			.functions()
			.httpsCallable(chat.httpCallables.sendMessageToPeople)
		try {
			if (!isNewMessageModel(this.message)) {
				throw new Error(
					'FAILED TO SEND TO PEOPLE: message object is not NewMessageModel'
				)
			}
			this.message = {
				...this.message,
				createdAt: fuego.firebase.firestore.FieldValue.serverTimestamp()
			} as NewMessageFormattedForServer
			return send({
				message: this.message,
				recipients
			})
		} catch (e) {
			console.error(e)
			return {
				data: null
			}
		}
	}
	/**
	 * Sends message to a group. This is useful when you don't have a room id but do have a list of people you want to send a message to. If you want to send the message to them separately, try sendToPeople instead.
	 * This function will create a group chat with the specified users if one doesn't exist yet. If it does exist already, then it will add to that existing room.
	 * @param recipients Array of uids for people in the group this message should send to.
	 * @returns Promise that returns a room ID (or promise that resolves as null if the message object isn't valid)
	 */
	async sendToGroup(recipients: string[]) {
		const send = fuego.firebase
			.functions()
			.httpsCallable(chat.httpCallables.sendMessageToGroup)
		try {
			if (!isNewMessageModel(this.message)) {
				throw new Error(
					'FAILED TO SEND TO PEOPLE: message object is not NewMessageModel'
				)
			}
			this.message = {
				...this.message,
				createdAt: fuego.firebase.firestore.FieldValue.serverTimestamp()
			} as NewMessageFormattedForServer
			return send({
				message: this.message,
				recipients
			})
		} catch (e) {
			console.error(e)
			return {
				data: null
			}
		}
	}
	/**
	 *  deprecated: fuck this function
	 */
	sendFromFeed(to: SendFromFeedRecipients) {
		const batch = fuego.db.batch()
		const promises: Promise<firebase.functions.HttpsCallableResult>[] = []

		// the to variable is an array of dictionaries
		// the dictionaries can be EITHER { id: string } or { recipients: Array<recipient> }
		// example:
		// you might send a message to five different places
		// could be 3 people, and 2 existing rooms
		// this would be an array of 5 items, 3 with recipients, 2 with id
		// example of the array:
		// [
		// 1) send to a room that has these two users
		// { recipients: [{id: uid, name: username }, {uid: uid2, name: name2 }]},
		// 2) send to an already existing room (likely pressing a group)
		// { id: roomId },
		// 3) send to one person, unaware if this room exists
		// { recipients: [{id: uid, name: username }]},
		// ]

		// now, set of people we're sending this to...
		to.forEach(room => {
			const { id, ...message } = this.message as NewMessageModel
			if (recipientHasId(room)) {
				// if this recipient is a specified room, then send to that
				const { messagesPath } = new Room({ id: room.id })
				const ref = fuego.db.collection(messagesPath).doc(id)
				batch.set(ref, message)
			} else if (recipientHasMembers(room)) {
				// otherwise, if you're just sending to a list of ambigious recipients...
				// note: this list will often be one person you're choosing from a feed
				// list could be: { recipients: [{ name: string, id: string }, { ...otherRecipient }]}
				const peopleInThisRoomOtherThanMe = room.recipients
					.slice()
					.sort((a, b) => (a.id > b.id ? 1 : -1))
				const addMessage = fuego.firebase
					.functions()
					.httpsCallable(chat.httpCallables.sendMessageFromFeed)
				const newMessage: SendFromFeedModel = {
					...(message as NewMessageModel),
					recipients: peopleInThisRoomOtherThanMe
				}
				promises.push(addMessage(newMessage))
			}
		})

		return Promise.all<any>([batch.commit(), ...promises])

		// return {
		// 	batch: () => batch.commit(),
		// 	toRecipients: () => Promise.all(promises)
		// }
	}
	/**
	 * Send message by adding it directly to the backend
	 * @param roomId The id of the room you want to send this to. Could also be an array of ids, if the same message should go to multiple rooms.
	 */
	send(roomId: RoomId) {
		this.addToFirebase(roomId)
	}
	edit(roomId: string) {
		return this.updateOnFirebase(roomId)
	}
	formatForRender(): NewMessageModel[] | NewMessageModel | null {
		function isDocList(m: MessageModel): m is MessageModelDocument[] {
			return !!(m as MessageModelDocument[])
		}
		function isDocument(m: MessageModel): m is MessageModelDocument {
			return !!(m as MessageModelDocument)
		}
		try {
			if (isDocList(this.message)) {
				return (
					(this.message as MessageModelDocument[]).map(
						(doc: MessageModelDocument) => ({
							...doc,
							id: doc.id,
							createdAt: doc.createdAt.toDate()
						})
					) || []
				)
			}
			if (isDocument(this.message))
				return {
					...this.message,
					id: this.message.id,
					createdAt: this.message.createdAt.toDate()
				}

			throw new Error('Wrong model here.')
		} catch (e) {
			console.error(
				'wrong model given to format for render in Message class.',
				e
			)
			return null
		}
	}
	formatForSend() {
		try {
			const isNew = (m: MessageModel): m is NewMessageModel[] =>
				!!(m as NewMessageModel[])
			if (isNew(this.message)) {
				this.message = (this.message as NewMessageModel[]).map(message => ({
					...message,
					text: (message.text && message.text.trim()) || '',
					createdAt: fuego.firebase.firestore.FieldValue.serverTimestamp()
				})) as NewMessageFormattedForServer[]
				return this
			}
			throw new Error('wrong format for formatting for send')
		} catch (e) {
			console.error(e)
			return this
		}
	}
	addToFirebase(roomId: RoomId) {
		const { message: messages } = this

		const batch = fuego.db.batch()

		const updateBatch = (roomId: string) => {
			// for each message, add to this batch...
			const addToBatch = (message: NewMessageFormattedForServer) => {
				try {
					const { messagesPath, path: roomPath } = new Room({ id: roomId })
					const ref = fuego.db.collection(messagesPath).doc(message.id)

					// remove id from message for single source of truth
					// it'll be put back again upon format()-ing
					const { id, ...messageDoc } = message
					batch.set(ref, messageDoc)

					// update the latest message
					const { displayName, uid } = fuego.auth().currentUser as firebase.User
					const roomRef = fuego.db.doc(roomPath)
					const lastMessage: LastMessageServer = {
						name: displayName || 'Name failed',
						id: uid,
						system: false,
						text: message.text,
						createdAt: message.createdAt
					}
					batch.update(roomRef, { lastMessage })
				} catch (e) {
					console.error('sending message had an error:', e)
				}
			}
			;(messages as NewMessageFormattedForServer[]).forEach(addToBatch)
		}

		// if you're sending these message(s) to multiple rooms, loop through each room...
		if (Array.isArray(roomId)) {
			;(roomId as string[]).forEach(updateBatch)
		} else {
			// just send to this room
			updateBatch(roomId as string)
		}
		// once everything has been added to the db batch, commit it
		return batch.commit()
	}
	updateOnFirebase(roomId: string) {
		const { path } = new Room({ id: roomId })
		const { id, ...message } = this.message as EditMessageModel
		return fuego.db
			.collection(path)
			.doc((this.message as EditMessageModel).id)
			.set(message, { merge: true })
	}
	// TODO get members through some other method...idk
	// eek. what a mess.
	getUsersWhoReacted(
		reaction: ReactionOption,
		{ roomMembers }: { roomMembers: RoomMembers }
	): RoomMember[] {
		const users: RoomMember[] = []
		if (!isNewMessageModel(this.message)) {
			console.warn(
				'error getting users who reacted. Needs the new message model passed as an argument, but instead it got this:',
				this.message
			)
		} else if (this.message.reactions) {
			this.message.reactions[reaction].forEach(
				uid => roomMembers[uid] && users.push(roomMembers[uid])
			)
		}
		return users
	}
}
