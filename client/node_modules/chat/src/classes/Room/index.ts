import {
	NewRoomModel,
	RoomModel,
	EditRoomModel,
	NewRoomMember,
	currentUserExists,
	roomIsEditModel,
	ExistingRoomModel,
	RoomMembers,
	CreateRoomModel,
	RoomPropertiesModel,
	roomIsNewModel,
	roomIsCreateCallable
} from './types'
import { fuego, chat } from '../../components/ChatProvider'
import { getInitials } from '../../helpers/getInitials'
import { firestore } from 'firebase'
import uuid from 'uuid'

export default class {
	private room: RoomModel
	constructor(room: RoomModel) {
		this.room = room
	}
	get path() {
		return `${chat.roomsCollection}/${(this.room as RoomPropertiesModel).id}`
	}
	get messagesPath() {
		return `${this.path}/${chat.messagesCollection}`
	}
	getUnreadCount(): number {
		const { uid } = fuego.firebase.auth().currentUser as firebase.User
		try {
			const member = (this.room as ExistingRoomModel | NewRoomModel).members[
				uid
			]

			return (member && member.unreadCount && member.unreadCount.count) || 0
		} catch (e) {
			console.error(
				`Room getUnreadCount error. Are you sure you initialized the room with the proper members schema?`
			)
			return 0
		}
	}
	/**
	 * Views message function for a room.
	 *
	 * To use this in a react component out-of-the-box, I recommend using the [[useViewMessage]] hook. It will handle all this for you.
	 *
	 * @param messageId ID of the message you're viewing
	 * @param messageCreatedAt Timestamp of the message which you're viewing, found in message.createdAt
	 *
	 * @remarks
	 * If you aren't using the useViewMessage hook:
	 * This function should be used with care. You don't want to send 500 writes if someone views 500 messages.
	 * You only want to send a read for the most recent message being viewed, assuming it's someone else's message.
	 * Also, you should be memoizing the last message you sent that you viewed to avoid repeats. Again, this is all handled by useViewMessages.
	 *
	 * @returns Promise that only resolves while you're online.
	 */
	async viewMessage(messageId: string, messageCreatedAt: Date) {
		try {
			const ref = fuego.db.doc(this.path)
			const { uid } = fuego.auth().currentUser as firebase.User

			return ref.update({
				[`members.${uid}.unreadCount.count`]: 0,
				[`members.${uid}.unreadCount.lastCleared`]: fuego.firebase.firestore.FieldValue.serverTimestamp(),
				[`members.${uid}.unreadCount.lastSeen`]: {
					id: messageId,
					createdAt: messageCreatedAt
				}
			})
		} catch (e) {
			console.error('Room class: viewMessage() error:', e)
		}
	}
	getArrayOfMembersOtherThanMe() {
		const { members } = this.room as ExistingRoomModel
		const { uid } = fuego.auth().currentUser as firebase.User
		return Object.keys(members)
			.filter(id => id !== uid)
			.map(id => members[id])
	}
	getName(): string {
		const { members, name } = this.room as ExistingRoomModel
		if (name) return name

		const { uid } = fuego.auth().currentUser as firebase.User

		const otherPeopleInRoom = Object.keys(members).filter(
			(id: string) => id !== uid
		)
		const namesOfOtherPeopleInRoom = otherPeopleInRoom.map(
			id =>
				(members[id] &&
					members[id].name &&
					members[id].name.split(' ') &&
					members[id].name.split(' ')[0]) ||
				''
		)
		if (!namesOfOtherPeopleInRoom.length) {
			console.error('no other members in room', this.room)
			return ''
		}
		if (namesOfOtherPeopleInRoom.length === 1)
			return members[otherPeopleInRoom[0]].name
		if (namesOfOtherPeopleInRoom.length === 2)
			return namesOfOtherPeopleInRoom.join(' & ')

		const commaNames = namesOfOtherPeopleInRoom
			.slice(0, namesOfOtherPeopleInRoom.length - 1)
			.join(', ')
		const finalName =
			namesOfOtherPeopleInRoom[namesOfOtherPeopleInRoom.length - 1]

		return `${commaNames} & ${finalName}`
	}
	getInitials(maxNumberOfInitials = 2): string {
		const { name } = this.room
		if (name) return getInitials(name)

		const members = this.getArrayOfMembersOtherThanMe()

		if (!members.length) {
			console.error(
				'get room initials error: no other members in this room',
				this.room
			)
			return ''
		}

		if (members.length === 1) {
			return getInitials(members[0].name, maxNumberOfInitials)
		}

		return (
			members
				// first letter of each person's name
				.map(member => (member.name && member.name.slice(0, 1)) || '')
				.join('')
				// up to two initials
				.slice(0, maxNumberOfInitials)
		)
	}
	/**
	 * @returns
	 * A promise.all array of responses. The first array is for adding a system message; the second is for updating the room object.
	 */
	async leave() {
		try {
			if (!currentUserExists(fuego.auth().currentUser)) {
				throw new Error(
					"ðŸš¨ Fuego auth error: Tried to leave a room, but there is no valid firebase auth object for this user. \n In order to join a room, the user must exist. If you're just testing around and don't want to have valid users, try await firebase.auth().signInAnonymously()."
				)
			}
			const { uid } = fuego.auth().currentUser as firebase.User
			// is this even necessary? maybe if people want the option to join or not...
			return fuego.db.doc(this.path).update({
				currentMembers: fuego.firebase.firestore.FieldValue.arrayRemove(uid),
				[`members.${uid}`]: fuego.firebase.firestore.FieldValue.delete()
			})
		} catch (e) {
			console.error(e)
			return null
		}
	}
	join() {
		try {
			if (!currentUserExists(fuego.auth().currentUser)) {
				throw new Error(
					"ðŸš¨ Fuego auth error: Tried to join a room, but there is no valid firebase auth object for this user. \n In order to join a room, the user must exist. If you're just testing around and don't want to have valid users, try await firebase.auth().signInAnonymously()."
				)
			}
			const { uid, displayName } = fuego.auth().currentUser as firebase.User
			const newMember: NewRoomMember = {
				name: displayName || 'Fredrick Failuretest',
				exists: true,
				joinedAt: fuego.firebase.firestore.FieldValue.serverTimestamp()
			}
			// is this even necessary?
			// maybe if people want the option to choose whether they join a room or not...
			return fuego.db.doc(this.path).update({
				[`members.${uid}`]: newMember,
				currentMembers: fuego.firebase.firestore.FieldValue.arrayUnion(uid)
			})
		} catch (e) {
			console.error(e)
			return null
		}
	}
	addMembers(members: RoomMembers) {
		const batch = fuego.db.batch()
		const ref = fuego.db.doc(this.path)
		Object.keys(members).forEach((uid: string) =>
			batch.update(ref, {
				[`members.${uid}`]: members[uid]
			})
		)

		batch.update(ref, {
			currentMembers: firestore.FieldValue.arrayUnion(...Object.keys(members))
		})

		return batch.commit()
	}
	removeMembers(members: RoomMembers) {
		const batch = fuego.db.batch()
		const ref = fuego.db.doc(this.path)

		Object.keys(members).forEach((uid: string) =>
			batch.update(ref, {
				[`members.${uid}.exists`]: false
			})
		)

		batch.update(ref, {
			currentMembers: firestore.FieldValue.arrayRemove(...Object.keys(members))
		})

		return batch.commit()
	}
	async create() {
		try {
			if (roomIsNewModel(this.room)) return this.addToFirebase()
			throw new Error(
				'Tried to create room without the proper schema. See NewRoomModel typescript type.'
			)
		} catch (e) {
			console.error(e)
			return null
		}
	}
	async createViaCallable(): Promise<firebase.functions.HttpsCallableResult> {
		try {
			if (roomIsCreateCallable(this.room)) {
				const create = fuego.firebase
					.functions()
					.httpsCallable(chat.httpCallables.createRoom)
				return create({
					recipients: this.room.recipients,
					name: this.room.name || '',
					avatar: this.room.avatar || ''
				})
			}
			throw new Error(
				'Error: improper room model for Room.createCallable(). The error comes from config for new Room(config). Make sure schema for config is correct'
			)
		} catch (e) {
			console.error(e)
			return {
				data: null
			}
		}
	}
	edit() {
		try {
			// typeguard
			if (roomIsEditModel(this.room)) return this.updateOnFirebase()
			throw new Error(
				'Tried to edit room without the proper schema. See EditRoomModel typescript type.'
			)
		} catch (e) {
			console.error(e)
			return null
		}
	}
	getUsersTyping() {
		return this.getArrayOfMembersOtherThanMe().filter(
			member => member.typing && member.typing.state === 'typing'
		)

		// return Object.keys((this.room as ExistingRoomModel).members || {})
		// 	.filter(
		// 		(uid: string) =>
		// 			this.room &&
		// 			this.room.members &&
		// 			this.room.members[uid] &&
		// 			this.room.members[uid].typing
		// 	)
		// 	.map(
		// 		(uid: string) =>
		// 			(this.room as ExistingRoomModel) &&
		// 			this.room.members &&
		// 			this.room.members[uid]
		// 	)
	}
	updateOnFirebase() {
		const { id, ...room } = this.room as EditRoomModel
		return fuego.db.doc(this.path).update(room)
	}
	addToFirebase() {
		const { uid, displayName, photoURL } = fuego.auth()
			.currentUser as firebase.User
		const date = fuego.firebase.firestore.FieldValue.serverTimestamp()
		const me: NewRoomMember = {
			name: displayName || 'Inexistent Poopnugget',
			exists: true,
			avatar: photoURL || '',
			joinedAt: date
		}
		const members: RoomMembers = {
			...(this.room as NewRoomModel).members,
			[uid]: me
		}
		const room: CreateRoomModel = {
			members,
			currentMembers: [...Object.keys(members)].sort(),
			createdAt: date,
			lastEdited: date,
			lastMessage: {
				system: true,
				text: `${me.name} started a chat`,
				createdAt: date,
				id: uuid.v4(),
				name: me.name
			}
		}
		const ref = fuego.db.collection(chat.roomsCollection).doc()
		return ref.set(room)
	}
}
