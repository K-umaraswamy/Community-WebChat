import { useFuego } from '@nandorojo/fuego'
import Room from '../../classes/Room'
import {
	EditRoomModel,
	RoomPropertiesModel,
	CreateCallableRoomModel,
	ExistingRoomDocument,
	ExistingRoomModel
} from '../../classes/Room/types'
import { UseRoomType } from './types'
import { QueryDataHandler } from '@nandorojo/fuego/lib/typescript/hooks/useFuego/types'
import { useMemo } from 'react'

/**
 * Fetches or subscribes to a chatroom. It automatically handles unmounts, etc.
 *
 * @param config - config dictionary.
 * @param config.id - Required: the unique ID for this chatroom, typically generated by the backend. If using the [[useInbox]] hook, each item in [[useInbox]]'s data array has this ID.
 * @param config.listen Boolean to determine if this room should update state as a subscription. Default false.
 * @param options - added options dictionary for useRoom
 *
 * @remarks Look at the fuego library's useFuego hook to see all the available arguments for config and options.
 *
 * @returns { data: room, loading, error, ref, create, edit, usersAreTyping, namesOfUsersTyping } data is formatted for rendering room.
 */

export default (
	{ id, ...config }: UseRoomType,
	options: QueryDataHandler<ExistingRoomDocument> = {}
) => {
	const { path } = new Room({ id } as RoomPropertiesModel)
	const { data, loading, error, ref } = useFuego<ExistingRoomDocument>(
		{
			...config,
			path
		},
		options
	)
	const create = (room: CreateCallableRoomModel) => {
		return new Room(room).createViaCallable()
	}
	const edit = (room: EditRoomModel) => {
		return new Room(room).edit()
	}
	const members = data && (data as ExistingRoomDocument).members
	const usersAreTyping = useMemo(() => {
		return !!(members && new Room({ members }).getUsersTyping().length)
	}, [members])
	const namesOfUsersTyping = useMemo(() => {
		return (
			(members &&
				new Room({ members }).getUsersTyping().map(user => user.name)) ||
			[]
		)
	}, [members])
	const room = useMemo(() => {
		function isDocument(r: typeof data): r is ExistingRoomDocument {
			return !!(r as ExistingRoomDocument)
		}
		if (data && isDocument(data)) {
			const model: ExistingRoomModel = {
				...data,
				lastMessage: {
					...data.lastMessage,
					createdAt: data.lastMessage.createdAt.toDate()
				}
			}
			return model
		}
		return null
	}, [data])
	return {
		data: room,
		loading,
		error,
		ref,
		create,
		edit,
		usersAreTyping,
		namesOfUsersTyping
	}
}
