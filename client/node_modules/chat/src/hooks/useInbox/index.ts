import { useFuego } from '@nandorojo/fuego'
import { useMemo } from 'react'
import { WhereFilterOp } from '@firebase/firestore-types'
import { QueryDataHandler } from '@nandorojo/fuego/lib/typescript/hooks/useFuego/types'
import { OrderByItem } from '@nandorojo/fuego/lib/typescript/FuegoQuery/types'
import { fuego } from '../../components/ChatProvider/index'
import { chat } from '../../components/ChatProvider'
import { ExistingRoomDocument } from '../../classes/Room/types'
import { InboxModel } from '../../classes/Inbox/types'
import { UseInboxConfig } from './types'
import { Room } from '../..'

const orderBy: OrderByItem = ['lastMessage.createdAt', 'desc']

/**
 * React hook to query the chat inbox in realtime. Used with the [Juice.Inbox] component from Juice.
 *
 * @example
 * ```
 * const { data } = useInbox()
 *
 * return <Juice.Inbox rooms={data} />
 * ```
 *
 * @returns
 * { data, loading, path, error } and other values returned by useFuego() hook. Data is properly formatted for rendering.
 */
export default (
	config: UseInboxConfig = {},
	options: QueryDataHandler<ExistingRoomDocument> = {}
) => {
	const currentUser = fuego.auth().currentUser as firebase.User
	const uid = config.uid || (currentUser && currentUser.uid)

	const where: [string, WhereFilterOp, string] = useMemo(() => {
		// useMemo to avoid re-making the array every render,
		// since that would refresh the useFuego each time
		return ['currentMembers', 'array-contains' as WhereFilterOp, uid]
		// if the uid updates, then it recreates
		// re: [uid]
	}, [uid])

	const path = chat.roomsCollection
	const query = useMemo(
		() => ({
			listen: true,
			where,
			orderBy,
			...config,
			path
		}),
		[config, where, path]
	)
	const { data, ...response } = useFuego<ExistingRoomDocument>(query, options)
	const rooms = useMemo(() => {
		function isListOfRoomDocs(
			inbox: typeof data
		): inbox is ExistingRoomDocument[] {
			return !!(inbox as ExistingRoomDocument[])
		}
		if (data && isListOfRoomDocs(data)) {
			const formatted: InboxModel = data.map(room => ({
				...room,
				lastMessage: {
					...room.lastMessage,
					createdAt: room.lastMessage.createdAt.toDate()
				},
				unreadCount: new Room(room).getUnreadCount()
			}))
			return formatted
		}
		return []
	}, [data])

	return { data: rooms, ...response, path }
}
