import { useEffect, useState, useMemo, useRef } from 'react'
import { useFuegoContext } from '@nandorojo/fuego'
import { Typing } from '../../classes/Room/types'

/**
 * useTyping automatically updates the backend whenever a user is typing.
 *
 * @param options - A dictionary to configure the typing.
 * @param options.roomId - **Required** unique id of the room you're typing in.
 * @param options.text - **Required** The current text state of your chat input
 * @param options.delay (Optional) Set the timeout delay to mark typing false. Set null if you don't want a time out.
 *
 * @example
 * ```javascript
 * // input text state
 * const [text, setText] = useState('')
 * // let's say we're getting our room id from our react-navigation params
 * const navigation = useNavigation()
 * const roomId = navigation.params.id
 *
 * useTyping({ roomId, text })
 *
 * <ChatComponent text={text} onChangeText={setText} />
 * ```
 *
 * @returns
 * Doesn't return anything. We live in an undefined world, I suppose.
 *
 * @remarks
 * The actual data of who is typing is stored in the chatroom object.
 * If you want to get this data realtime in a room, consider using useRoom({ listen: true }). This data will also be in useInbox().
 * See docs for useRoom or useInbox for more.
 *
 */
export default ({
	roomId,
	text,
	delay = 5000
}: {
	roomId: string
	text: string
	delay?: number | null
}) => {
	const { auth, firebase } = useFuegoContext()
	const [ready, setReady] = useState(false)
	const { currentUser } = auth()
	try {
		if (!currentUser)
			throw new Error(
				'ðŸ¤¯ error in useTyping hook. Looks like there is not a valid user signed in. \nConsider using the FuegoGate component from @nandorojo/fuego and wrapping it around your app.'
			)
	} catch (e) {
		console.error(e)
	}
	const { uid } = currentUser as firebase.User
	const databaseRef = useMemo(() => firebase.database().ref(`/typing/${uid}`), [
		uid,
		firebase
	])
	const previouslyTyped = useRef('')

	const timer = useRef<NodeJS.Timeout>()

	const lastStateSent = useRef<IsTyping['state']>('nothing')

	// initialize the typing set to false when we disconnect
	// once that is set up, then we can mark that we are indeed typing elsewhere
	// ^ that will be done in the next hook
	useEffect(() => {
		const subscriptionRef = firebase.database().ref('.info/connected')
		const notTyping: IsTyping = {
			state: 'nothing',
			lastChanged: firebase.database.ServerValue.TIMESTAMP,
			roomId
		}

		subscriptionRef.on('value', async snapshot => {
			if (!snapshot.val()) return

			try {
				await databaseRef.onDisconnect().set(notTyping)
				setReady(true)
			} catch (e) {
				console.error(`useTyping error within snapshot listener ${e}`)
			}
		})

		return () => {
			// clean up the listener on unmount
			subscriptionRef.off('value')
			;(async () => {
				try {
					lastStateSent.current = notTyping.state
					await databaseRef.set(notTyping)
				} catch (e) {
					console.error('useTyping errored on unmount setting not typing')
				}
			})()
		}
	}, [roomId, databaseRef, firebase])

	// every time we type something new, upload that we're typing
	// and after a certain delay, we mark typing false
	// however, if we type before that timer has completed,
	// we clean it up and start it over
	useEffect(() => {
		try {
			// we're ready to upload from the previous effect
			// ...and the text we typed just changed.
			// if text is empty, set to false
			if (ready && text !== previouslyTyped.current) {
				previouslyTyped.current = text

				const notTyping: IsTyping = {
					state: 'nothing',
					lastChanged: firebase.database.ServerValue.TIMESTAMP,
					roomId
				}
				const isTyping: IsTyping = {
					state: 'typing',
					lastChanged: firebase.database.ServerValue.TIMESTAMP,
					roomId
				}

				// if the text is empty, we set it to not typing
				const setValue = text ? isTyping : notTyping

				// don't resend the state we just sent to avoid redundancy
				if (setValue.state !== lastStateSent.current) {
					lastStateSent.current = setValue.state
					databaseRef.set(setValue)
				}

				// only need a notTyping timer timer if we're typing
				if (delay !== null && setValue.state === 'typing') {
					timer.current = setTimeout(() => {
						lastStateSent.current = notTyping.state
						databaseRef.set(notTyping)
					}, delay)
				}
			}
		} catch (e) {
			console.error('error in useTyping after timer', e)
		}

		return () => {
			if (timer.current) clearTimeout(timer.current)
		}
	}, [ready, text, roomId, delay, uid, databaseRef, firebase])
}

interface IsTyping extends Typing {
	roomId: string
}
