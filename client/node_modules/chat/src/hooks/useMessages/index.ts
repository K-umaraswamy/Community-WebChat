import { useMemo, useCallback, useState, useEffect, useRef } from 'react'
import { useFuego } from '@nandorojo/fuego'
import { UseMessagesConfig } from './types'
import Room from '../../classes/Room'
import {
	NewMessageModel,
	EditMessageModel,
	MessageModelDocument,
} from '../../classes/Message/types'
import Message from '../../classes/Message'
import {
	UseQueryConfig,
	QueryDataHandler,
} from '@nandorojo/fuego/lib/typescript/hooks/useFuego/types'

const LIMIT = 30

const orderBy: UseQueryConfig['orderBy'] = ['createdAt', 'desc']
/**
 *	React hook to set up a lisener for a room's messages
 *
 * 	@param { id } the roomId, along with other query options from `useFuego` hook
 *
 *	@returns { data: formattedMessages, loading, error, ref, path, empty, send, edit, fetchMore }
 * data is formatted for rendering.
 */
export default (
	{ id, ...config }: UseMessagesConfig,
	options: QueryDataHandler<MessageModelDocument> = {}
) => {
	const { messagesPath: path } = new Room({ id })
	const [limit, setLimit] = useState(LIMIT)
	const currentLimit = useRef(limit)
	const latestFetchMoreId = useRef<null | string>(null)
	const query = useMemo(
		() => ({
			listen: true,
			orderBy,
			...config,
			path,
			limit,
		}),
		[path, config, limit]
	)
	useEffect(() => {
		currentLimit.current = limit
	}, [limit])
	const { data, loading, error, ref } = useFuego<MessageModelDocument>(
		query,
		options
	)
	const send = useCallback(
		(message: NewMessageModel[]) => {
			return new Message(message as NewMessageModel[]).formatForSend().send(id)
		},
		[id]
	)
	const edit = useCallback(
		(message: EditMessageModel) => {
			return new Message(message).edit(id)
		},
		[id]
	)
	const formattedMessages: NewMessageModel[] = useMemo(() => {
		function isArrayOfMessageDocuments(
			m: typeof data
		): m is MessageModelDocument[] {
			return !!(m as MessageModelDocument[])
		}
		if (data && isArrayOfMessageDocuments(data)) {
			const formatted: NewMessageModel[] = new Message(
				data
			).formatForRender() as NewMessageModel[]
			return formatted
		}
		return []
	}, [data])
	const fetchMore = () => {
		const lastMessageId =
			formattedMessages[formattedMessages.length - 1] &&
			formattedMessages[formattedMessages.length - 1].id
		// make sure we don't fetch more if the latest message is unchanged, or if it doesn't even exist
		if (lastMessageId && lastMessageId !== latestFetchMoreId.current) {
			latestFetchMoreId.current = lastMessageId
			setLimit(l => l + LIMIT)
		}
	}
	const empty: boolean = useMemo(
		() => !(formattedMessages && formattedMessages.length),
		[formattedMessages]
	)

	const fetchingMore = loading && formattedMessages.length

	// TODO add reply to message function

	return {
		data: formattedMessages,
		loading,
		error,
		ref,
		path,
		empty,
		send,
		edit,
		fetchMore,
		fetchingMore,
	}
}
