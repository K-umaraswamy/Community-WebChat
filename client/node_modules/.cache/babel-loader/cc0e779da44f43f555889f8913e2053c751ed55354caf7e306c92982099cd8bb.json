{"ast":null,"code":"/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2021 */\n\n/* jshint ignore:start */\nvar ICAL;\n(function () {\n  /* istanbul ignore next */\n  if (typeof module === 'object') {\n    // CommonJS, where exports may be different each time.\n    ICAL = module.exports;\n  } else if (typeof HTMLScriptElement !== 'undefined' && 'noModule' in HTMLScriptElement.prototype) {\n    // Until we use ES6 exports, using <script type=\"module\"> we define ICAL on the window global.\n    window.ICAL = ICAL = {};\n  } else if (typeof ICAL !== 'object') {\n    ICAL = {};\n  }\n})();\n/* jshint ignore:end */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * The number of characters before iCalendar line folding should occur\n * @type {Number}\n * @default 75\n */\nICAL.foldLength = 75;\n\n/**\n * The character(s) to be used for a newline. The default value is provided by\n * rfc5545.\n * @type {String}\n * @default \"\\r\\n\"\n */\nICAL.newLineChar = '\\r\\n';\n\n/**\n * Helper functions used in various places within ical.js\n * @namespace\n */\nICAL.helpers = {\n  /**\n   * Compiles a list of all referenced TZIDs in all subcomponents and\n   * removes any extra VTIMEZONE subcomponents. In addition, if any TZIDs\n   * are referenced by a component, but a VTIMEZONE does not exist,\n   * an attempt will be made to generate a VTIMEZONE using ICAL.TimezoneService.\n   *\n   * @param {ICAL.Component} vcal     The top-level VCALENDAR component.\n   * @return {ICAL.Component}         The ICAL.Component that was passed in.\n   */\n  updateTimezones: function (vcal) {\n    var allsubs, properties, vtimezones, reqTzid, i, tzid;\n    if (!vcal || vcal.name !== \"vcalendar\") {\n      //not a top-level vcalendar component\n      return vcal;\n    }\n\n    //Store vtimezone subcomponents in an object reference by tzid.\n    //Store properties from everything else in another array\n    allsubs = vcal.getAllSubcomponents();\n    properties = [];\n    vtimezones = {};\n    for (i = 0; i < allsubs.length; i++) {\n      if (allsubs[i].name === \"vtimezone\") {\n        tzid = allsubs[i].getFirstProperty(\"tzid\").getFirstValue();\n        vtimezones[tzid] = allsubs[i];\n      } else {\n        properties = properties.concat(allsubs[i].getAllProperties());\n      }\n    }\n\n    //create an object with one entry for each required tz\n    reqTzid = {};\n    for (i = 0; i < properties.length; i++) {\n      if (tzid = properties[i].getParameter(\"tzid\")) {\n        reqTzid[tzid] = true;\n      }\n    }\n\n    //delete any vtimezones that are not on the reqTzid list.\n    for (i in vtimezones) {\n      if (vtimezones.hasOwnProperty(i) && !reqTzid[i]) {\n        vcal.removeSubcomponent(vtimezones[i]);\n      }\n    }\n\n    //create any missing, but registered timezones\n    for (i in reqTzid) {\n      if (reqTzid.hasOwnProperty(i) && !vtimezones[i] && ICAL.TimezoneService.has(i)) {\n        vcal.addSubcomponent(ICAL.TimezoneService.get(i).component);\n      }\n    }\n    return vcal;\n  },\n  /**\n   * Checks if the given type is of the number type and also NaN.\n   *\n   * @param {Number} number     The number to check\n   * @return {Boolean}          True, if the number is strictly NaN\n   */\n  isStrictlyNaN: function (number) {\n    return typeof number === 'number' && isNaN(number);\n  },\n  /**\n   * Parses a string value that is expected to be an integer, when the valid is\n   * not an integer throws a decoration error.\n   *\n   * @param {String} string     Raw string input\n   * @return {Number}           Parsed integer\n   */\n  strictParseInt: function (string) {\n    var result = parseInt(string, 10);\n    if (ICAL.helpers.isStrictlyNaN(result)) {\n      throw new Error('Could not extract integer from \"' + string + '\"');\n    }\n    return result;\n  },\n  /**\n   * Creates or returns a class instance of a given type with the initialization\n   * data if the data is not already an instance of the given type.\n   *\n   * @example\n   * var time = new ICAL.Time(...);\n   * var result = ICAL.helpers.formatClassType(time, ICAL.Time);\n   *\n   * (result instanceof ICAL.Time)\n   * // => true\n   *\n   * result = ICAL.helpers.formatClassType({}, ICAL.Time);\n   * (result isntanceof ICAL.Time)\n   * // => true\n   *\n   *\n   * @param {Object} data       object initialization data\n   * @param {Object} type       object type (like ICAL.Time)\n   * @return {?}                An instance of the found type.\n   */\n  formatClassType: function formatClassType(data, type) {\n    if (typeof data === 'undefined') {\n      return undefined;\n    }\n    if (data instanceof type) {\n      return data;\n    }\n    return new type(data);\n  },\n  /**\n   * Identical to indexOf but will only match values when they are not preceded\n   * by a backslash character.\n   *\n   * @param {String} buffer         String to search\n   * @param {String} search         Value to look for\n   * @param {Number} pos            Start position\n   * @return {Number}               The position, or -1 if not found\n   */\n  unescapedIndexOf: function (buffer, search, pos) {\n    while ((pos = buffer.indexOf(search, pos)) !== -1) {\n      if (pos > 0 && buffer[pos - 1] === '\\\\') {\n        pos += 1;\n      } else {\n        return pos;\n      }\n    }\n    return -1;\n  },\n  /**\n   * Find the index for insertion using binary search.\n   *\n   * @param {Array} list            The list to search\n   * @param {?} seekVal             The value to insert\n   * @param {function(?,?)} cmpfunc The comparison func, that can\n   *                                  compare two seekVals\n   * @return {Number}               The insert position\n   */\n  binsearchInsert: function (list, seekVal, cmpfunc) {\n    if (!list.length) return 0;\n    var low = 0,\n      high = list.length - 1,\n      mid,\n      cmpval;\n    while (low <= high) {\n      mid = low + Math.floor((high - low) / 2);\n      cmpval = cmpfunc(seekVal, list[mid]);\n      if (cmpval < 0) high = mid - 1;else if (cmpval > 0) low = mid + 1;else break;\n    }\n    if (cmpval < 0) return mid; // insertion is displacing, so use mid outright.\n    else if (cmpval > 0) return mid + 1;else return mid;\n  },\n  /**\n   * Convenience function for debug output\n   * @private\n   */\n  dumpn: /* istanbul ignore next */function () {\n    if (!ICAL.debug) {\n      return;\n    }\n    if (typeof console !== 'undefined' && 'log' in console) {\n      ICAL.helpers.dumpn = function consoleDumpn(input) {\n        console.log(input);\n      };\n    } else {\n      ICAL.helpers.dumpn = function geckoDumpn(input) {\n        dump(input + '\\n');\n      };\n    }\n    ICAL.helpers.dumpn(arguments[0]);\n  },\n  /**\n   * Clone the passed object or primitive. By default a shallow clone will be\n   * executed.\n   *\n   * @param {*} aSrc            The thing to clone\n   * @param {Boolean=} aDeep    If true, a deep clone will be performed\n   * @return {*}                The copy of the thing\n   */\n  clone: function (aSrc, aDeep) {\n    if (!aSrc || typeof aSrc != \"object\") {\n      return aSrc;\n    } else if (aSrc instanceof Date) {\n      return new Date(aSrc.getTime());\n    } else if (\"clone\" in aSrc) {\n      return aSrc.clone();\n    } else if (Array.isArray(aSrc)) {\n      var arr = [];\n      for (var i = 0; i < aSrc.length; i++) {\n        arr.push(aDeep ? ICAL.helpers.clone(aSrc[i], true) : aSrc[i]);\n      }\n      return arr;\n    } else {\n      var obj = {};\n      for (var name in aSrc) {\n        // uses prototype method to allow use of Object.create(null);\n        /* istanbul ignore else */\n        if (Object.prototype.hasOwnProperty.call(aSrc, name)) {\n          if (aDeep) {\n            obj[name] = ICAL.helpers.clone(aSrc[name], true);\n          } else {\n            obj[name] = aSrc[name];\n          }\n        }\n      }\n      return obj;\n    }\n  },\n  /**\n   * Performs iCalendar line folding. A line ending character is inserted and\n   * the next line begins with a whitespace.\n   *\n   * @example\n   * SUMMARY:This line will be fold\n   *  ed right in the middle of a word.\n   *\n   * @param {String} aLine      The line to fold\n   * @return {String}           The folded line\n   */\n  foldline: function foldline(aLine) {\n    var result = \"\";\n    var line = aLine || \"\",\n      pos = 0,\n      line_length = 0;\n    //pos counts position in line for the UTF-16 presentation\n    //line_length counts the bytes for the UTF-8 presentation\n    while (line.length) {\n      var cp = line.codePointAt(pos);\n      if (cp < 128) ++line_length;else if (cp < 2048) line_length += 2; //needs 2 UTF-8 bytes\n      else if (cp < 65536) line_length += 3;else line_length += 4; //cp is less than 1114112\n      if (line_length < ICAL.foldLength + 1) pos += cp > 65535 ? 2 : 1;else {\n        result += ICAL.newLineChar + \" \" + line.substring(0, pos);\n        line = line.substring(pos);\n        pos = line_length = 0;\n      }\n    }\n    return result.substr(ICAL.newLineChar.length + 1);\n  },\n  /**\n   * Pads the given string or number with zeros so it will have at least two\n   * characters.\n   *\n   * @param {String|Number} data    The string or number to pad\n   * @return {String}               The number padded as a string\n   */\n  pad2: function pad(data) {\n    if (typeof data !== 'string') {\n      // handle fractions.\n      if (typeof data === 'number') {\n        data = parseInt(data);\n      }\n      data = String(data);\n    }\n    var len = data.length;\n    switch (len) {\n      case 0:\n        return '00';\n      case 1:\n        return '0' + data;\n      default:\n        return data;\n    }\n  },\n  /**\n   * Truncates the given number, correctly handling negative numbers.\n   *\n   * @param {Number} number     The number to truncate\n   * @return {Number}           The truncated number\n   */\n  trunc: function trunc(number) {\n    return number < 0 ? Math.ceil(number) : Math.floor(number);\n  },\n  /**\n   * Poor-man's cross-browser inheritance for JavaScript. Doesn't support all\n   * the features, but enough for our usage.\n   *\n   * @param {Function} base     The base class constructor function.\n   * @param {Function} child    The child class constructor function.\n   * @param {Object} extra      Extends the prototype with extra properties\n   *                              and methods\n   */\n  inherits: function (base, child, extra) {\n    function F() {}\n    F.prototype = base.prototype;\n    child.prototype = new F();\n    if (extra) {\n      ICAL.helpers.extend(extra, child.prototype);\n    }\n  },\n  /**\n   * Poor-man's cross-browser object extension. Doesn't support all the\n   * features, but enough for our usage. Note that the target's properties are\n   * not overwritten with the source properties.\n   *\n   * @example\n   * var child = ICAL.helpers.extend(parent, {\n   *   \"bar\": 123\n   * });\n   *\n   * @param {Object} source     The object to extend\n   * @param {Object} target     The object to extend with\n   * @return {Object}           Returns the target.\n   */\n  extend: function (source, target) {\n    for (var key in source) {\n      var descr = Object.getOwnPropertyDescriptor(source, key);\n      if (descr && !Object.getOwnPropertyDescriptor(target, key)) {\n        Object.defineProperty(target, key, descr);\n      }\n    }\n    return target;\n  }\n};\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/** @namespace ICAL */\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.design = function () {\n  'use strict';\n\n  var FROM_ICAL_NEWLINE = /\\\\\\\\|\\\\;|\\\\,|\\\\[Nn]/g;\n  var TO_ICAL_NEWLINE = /\\\\|;|,|\\n/g;\n  var FROM_VCARD_NEWLINE = /\\\\\\\\|\\\\,|\\\\[Nn]/g;\n  var TO_VCARD_NEWLINE = /\\\\|,|\\n/g;\n  function createTextType(fromNewline, toNewline) {\n    var result = {\n      matches: /.*/,\n      fromICAL: function (aValue, structuredEscape) {\n        return replaceNewline(aValue, fromNewline, structuredEscape);\n      },\n      toICAL: function (aValue, structuredEscape) {\n        var regEx = toNewline;\n        if (structuredEscape) regEx = new RegExp(regEx.source + '|' + structuredEscape);\n        return aValue.replace(regEx, function (str) {\n          switch (str) {\n            case \"\\\\\":\n              return \"\\\\\\\\\";\n            case \";\":\n              return \"\\\\;\";\n            case \",\":\n              return \"\\\\,\";\n            case \"\\n\":\n              return \"\\\\n\";\n            /* istanbul ignore next */\n            default:\n              return str;\n          }\n        });\n      }\n    };\n    return result;\n  }\n\n  // default types used multiple times\n  var DEFAULT_TYPE_TEXT = {\n    defaultType: \"text\"\n  };\n  var DEFAULT_TYPE_TEXT_MULTI = {\n    defaultType: \"text\",\n    multiValue: \",\"\n  };\n  var DEFAULT_TYPE_TEXT_STRUCTURED = {\n    defaultType: \"text\",\n    structuredValue: \";\"\n  };\n  var DEFAULT_TYPE_INTEGER = {\n    defaultType: \"integer\"\n  };\n  var DEFAULT_TYPE_DATETIME_DATE = {\n    defaultType: \"date-time\",\n    allowedTypes: [\"date-time\", \"date\"]\n  };\n  var DEFAULT_TYPE_DATETIME = {\n    defaultType: \"date-time\"\n  };\n  var DEFAULT_TYPE_URI = {\n    defaultType: \"uri\"\n  };\n  var DEFAULT_TYPE_UTCOFFSET = {\n    defaultType: \"utc-offset\"\n  };\n  var DEFAULT_TYPE_RECUR = {\n    defaultType: \"recur\"\n  };\n  var DEFAULT_TYPE_DATE_ANDOR_TIME = {\n    defaultType: \"date-and-or-time\",\n    allowedTypes: [\"date-time\", \"date\", \"text\"]\n  };\n  function replaceNewlineReplace(string) {\n    switch (string) {\n      case \"\\\\\\\\\":\n        return \"\\\\\";\n      case \"\\\\;\":\n        return \";\";\n      case \"\\\\,\":\n        return \",\";\n      case \"\\\\n\":\n      case \"\\\\N\":\n        return \"\\n\";\n      /* istanbul ignore next */\n      default:\n        return string;\n    }\n  }\n  function replaceNewline(value, newline, structuredEscape) {\n    // avoid regex when possible.\n    if (value.indexOf('\\\\') === -1) {\n      return value;\n    }\n    if (structuredEscape) newline = new RegExp(newline.source + '|\\\\\\\\' + structuredEscape);\n    return value.replace(newline, replaceNewlineReplace);\n  }\n  var commonProperties = {\n    \"categories\": DEFAULT_TYPE_TEXT_MULTI,\n    \"url\": DEFAULT_TYPE_URI,\n    \"version\": DEFAULT_TYPE_TEXT,\n    \"uid\": DEFAULT_TYPE_TEXT\n  };\n  var commonValues = {\n    \"boolean\": {\n      values: [\"TRUE\", \"FALSE\"],\n      fromICAL: function (aValue) {\n        switch (aValue) {\n          case 'TRUE':\n            return true;\n          case 'FALSE':\n            return false;\n          default:\n            //TODO: parser warning\n            return false;\n        }\n      },\n      toICAL: function (aValue) {\n        if (aValue) {\n          return 'TRUE';\n        }\n        return 'FALSE';\n      }\n    },\n    float: {\n      matches: /^[+-]?\\d+\\.\\d+$/,\n      fromICAL: function (aValue) {\n        var parsed = parseFloat(aValue);\n        if (ICAL.helpers.isStrictlyNaN(parsed)) {\n          // TODO: parser warning\n          return 0.0;\n        }\n        return parsed;\n      },\n      toICAL: function (aValue) {\n        return String(aValue);\n      }\n    },\n    integer: {\n      fromICAL: function (aValue) {\n        var parsed = parseInt(aValue);\n        if (ICAL.helpers.isStrictlyNaN(parsed)) {\n          return 0;\n        }\n        return parsed;\n      },\n      toICAL: function (aValue) {\n        return String(aValue);\n      }\n    },\n    \"utc-offset\": {\n      toICAL: function (aValue) {\n        if (aValue.length < 7) {\n          // no seconds\n          // -0500\n          return aValue.substr(0, 3) + aValue.substr(4, 2);\n        } else {\n          // seconds\n          // -050000\n          return aValue.substr(0, 3) + aValue.substr(4, 2) + aValue.substr(7, 2);\n        }\n      },\n      fromICAL: function (aValue) {\n        if (aValue.length < 6) {\n          // no seconds\n          // -05:00\n          return aValue.substr(0, 3) + ':' + aValue.substr(3, 2);\n        } else {\n          // seconds\n          // -05:00:00\n          return aValue.substr(0, 3) + ':' + aValue.substr(3, 2) + ':' + aValue.substr(5, 2);\n        }\n      },\n      decorate: function (aValue) {\n        return ICAL.UtcOffset.fromString(aValue);\n      },\n      undecorate: function (aValue) {\n        return aValue.toString();\n      }\n    }\n  };\n  var icalParams = {\n    // Although the syntax is DQUOTE uri DQUOTE, I don't think we should\n    // enfoce anything aside from it being a valid content line.\n    //\n    // At least some params require - if multi values are used - DQUOTEs\n    // for each of its values - e.g. delegated-from=\"uri1\",\"uri2\"\n    // To indicate this, I introduced the new k/v pair\n    // multiValueSeparateDQuote: true\n    //\n    // \"ALTREP\": { ... },\n\n    // CN just wants a param-value\n    // \"CN\": { ... }\n\n    \"cutype\": {\n      values: [\"INDIVIDUAL\", \"GROUP\", \"RESOURCE\", \"ROOM\", \"UNKNOWN\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    \"delegated-from\": {\n      valueType: \"cal-address\",\n      multiValue: \",\",\n      multiValueSeparateDQuote: true\n    },\n    \"delegated-to\": {\n      valueType: \"cal-address\",\n      multiValue: \",\",\n      multiValueSeparateDQuote: true\n    },\n    // \"DIR\": { ... }, // See ALTREP\n    \"encoding\": {\n      values: [\"8BIT\", \"BASE64\"]\n    },\n    // \"FMTTYPE\": { ... }, // See ALTREP\n    \"fbtype\": {\n      values: [\"FREE\", \"BUSY\", \"BUSY-UNAVAILABLE\", \"BUSY-TENTATIVE\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    // \"LANGUAGE\": { ... }, // See ALTREP\n    \"member\": {\n      valueType: \"cal-address\",\n      multiValue: \",\",\n      multiValueSeparateDQuote: true\n    },\n    \"partstat\": {\n      // TODO These values are actually different per-component\n      values: [\"NEEDS-ACTION\", \"ACCEPTED\", \"DECLINED\", \"TENTATIVE\", \"DELEGATED\", \"COMPLETED\", \"IN-PROCESS\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    \"range\": {\n      values: [\"THISANDFUTURE\"]\n    },\n    \"related\": {\n      values: [\"START\", \"END\"]\n    },\n    \"reltype\": {\n      values: [\"PARENT\", \"CHILD\", \"SIBLING\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    \"role\": {\n      values: [\"REQ-PARTICIPANT\", \"CHAIR\", \"OPT-PARTICIPANT\", \"NON-PARTICIPANT\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    \"rsvp\": {\n      values: [\"TRUE\", \"FALSE\"]\n    },\n    \"sent-by\": {\n      valueType: \"cal-address\"\n    },\n    \"tzid\": {\n      matches: /^\\//\n    },\n    \"value\": {\n      // since the value here is a 'type' lowercase is used.\n      values: [\"binary\", \"boolean\", \"cal-address\", \"date\", \"date-time\", \"duration\", \"float\", \"integer\", \"period\", \"recur\", \"text\", \"time\", \"uri\", \"utc-offset\"],\n      allowXName: true,\n      allowIanaToken: true\n    }\n  };\n\n  // When adding a value here, be sure to add it to the parameter types!\n  var icalValues = ICAL.helpers.extend(commonValues, {\n    text: createTextType(FROM_ICAL_NEWLINE, TO_ICAL_NEWLINE),\n    uri: {\n      // TODO\n      /* ... */\n    },\n    \"binary\": {\n      decorate: function (aString) {\n        return ICAL.Binary.fromString(aString);\n      },\n      undecorate: function (aBinary) {\n        return aBinary.toString();\n      }\n    },\n    \"cal-address\": {\n      // needs to be an uri\n    },\n    \"date\": {\n      decorate: function (aValue, aProp) {\n        if (design.strict) {\n          return ICAL.Time.fromDateString(aValue, aProp);\n        } else {\n          return ICAL.Time.fromString(aValue, aProp);\n        }\n      },\n      /**\n       * undecorates a time object.\n       */\n      undecorate: function (aValue) {\n        return aValue.toString();\n      },\n      fromICAL: function (aValue) {\n        // from: 20120901\n        // to: 2012-09-01\n        if (!design.strict && aValue.length >= 15) {\n          // This is probably a date-time, e.g. 20120901T130000Z\n          return icalValues[\"date-time\"].fromICAL(aValue);\n        } else {\n          return aValue.substr(0, 4) + '-' + aValue.substr(4, 2) + '-' + aValue.substr(6, 2);\n        }\n      },\n      toICAL: function (aValue) {\n        // from: 2012-09-01\n        // to: 20120901\n        var len = aValue.length;\n        if (len == 10) {\n          return aValue.substr(0, 4) + aValue.substr(5, 2) + aValue.substr(8, 2);\n        } else if (len >= 19) {\n          return icalValues[\"date-time\"].toICAL(aValue);\n        } else {\n          //TODO: serialize warning?\n          return aValue;\n        }\n      }\n    },\n    \"date-time\": {\n      fromICAL: function (aValue) {\n        // from: 20120901T130000\n        // to: 2012-09-01T13:00:00\n        if (!design.strict && aValue.length == 8) {\n          // This is probably a date, e.g. 20120901\n          return icalValues.date.fromICAL(aValue);\n        } else {\n          var result = aValue.substr(0, 4) + '-' + aValue.substr(4, 2) + '-' + aValue.substr(6, 2) + 'T' + aValue.substr(9, 2) + ':' + aValue.substr(11, 2) + ':' + aValue.substr(13, 2);\n          if (aValue[15] && aValue[15] === 'Z') {\n            result += 'Z';\n          }\n          return result;\n        }\n      },\n      toICAL: function (aValue) {\n        // from: 2012-09-01T13:00:00\n        // to: 20120901T130000\n        var len = aValue.length;\n        if (len == 10 && !design.strict) {\n          return icalValues.date.toICAL(aValue);\n        } else if (len >= 19) {\n          var result = aValue.substr(0, 4) + aValue.substr(5, 2) +\n          // grab the (DDTHH) segment\n          aValue.substr(8, 5) +\n          // MM\n          aValue.substr(14, 2) +\n          // SS\n          aValue.substr(17, 2);\n          if (aValue[19] && aValue[19] === 'Z') {\n            result += 'Z';\n          }\n          return result;\n        } else {\n          // TODO: error\n          return aValue;\n        }\n      },\n      decorate: function (aValue, aProp) {\n        if (design.strict) {\n          return ICAL.Time.fromDateTimeString(aValue, aProp);\n        } else {\n          return ICAL.Time.fromString(aValue, aProp);\n        }\n      },\n      undecorate: function (aValue) {\n        return aValue.toString();\n      }\n    },\n    duration: {\n      decorate: function (aValue) {\n        return ICAL.Duration.fromString(aValue);\n      },\n      undecorate: function (aValue) {\n        return aValue.toString();\n      }\n    },\n    period: {\n      fromICAL: function (string) {\n        var parts = string.split('/');\n        parts[0] = icalValues['date-time'].fromICAL(parts[0]);\n        if (!ICAL.Duration.isValueString(parts[1])) {\n          parts[1] = icalValues['date-time'].fromICAL(parts[1]);\n        }\n        return parts;\n      },\n      toICAL: function (parts) {\n        if (!design.strict && parts[0].length == 10) {\n          parts[0] = icalValues.date.toICAL(parts[0]);\n        } else {\n          parts[0] = icalValues['date-time'].toICAL(parts[0]);\n        }\n        if (!ICAL.Duration.isValueString(parts[1])) {\n          if (!design.strict && parts[1].length == 10) {\n            parts[1] = icalValues.date.toICAL(parts[1]);\n          } else {\n            parts[1] = icalValues['date-time'].toICAL(parts[1]);\n          }\n        }\n        return parts.join(\"/\");\n      },\n      decorate: function (aValue, aProp) {\n        return ICAL.Period.fromJSON(aValue, aProp, !design.strict);\n      },\n      undecorate: function (aValue) {\n        return aValue.toJSON();\n      }\n    },\n    recur: {\n      fromICAL: function (string) {\n        return ICAL.Recur._stringToData(string, true);\n      },\n      toICAL: function (data) {\n        var str = \"\";\n        for (var k in data) {\n          /* istanbul ignore if */\n          if (!Object.prototype.hasOwnProperty.call(data, k)) {\n            continue;\n          }\n          var val = data[k];\n          if (k == \"until\") {\n            if (val.length > 10) {\n              val = icalValues['date-time'].toICAL(val);\n            } else {\n              val = icalValues.date.toICAL(val);\n            }\n          } else if (k == \"wkst\") {\n            if (typeof val === 'number') {\n              val = ICAL.Recur.numericDayToIcalDay(val);\n            }\n          } else if (Array.isArray(val)) {\n            val = val.join(\",\");\n          }\n          str += k.toUpperCase() + \"=\" + val + \";\";\n        }\n        return str.substr(0, str.length - 1);\n      },\n      decorate: function decorate(aValue) {\n        return ICAL.Recur.fromData(aValue);\n      },\n      undecorate: function (aRecur) {\n        return aRecur.toJSON();\n      }\n    },\n    time: {\n      fromICAL: function (aValue) {\n        // from: MMHHSS(Z)?\n        // to: HH:MM:SS(Z)?\n        if (aValue.length < 6) {\n          // TODO: parser exception?\n          return aValue;\n        }\n\n        // HH::MM::SSZ?\n        var result = aValue.substr(0, 2) + ':' + aValue.substr(2, 2) + ':' + aValue.substr(4, 2);\n        if (aValue[6] === 'Z') {\n          result += 'Z';\n        }\n        return result;\n      },\n      toICAL: function (aValue) {\n        // from: HH:MM:SS(Z)?\n        // to: MMHHSS(Z)?\n        if (aValue.length < 8) {\n          //TODO: error\n          return aValue;\n        }\n        var result = aValue.substr(0, 2) + aValue.substr(3, 2) + aValue.substr(6, 2);\n        if (aValue[8] === 'Z') {\n          result += 'Z';\n        }\n        return result;\n      }\n    }\n  });\n  var icalProperties = ICAL.helpers.extend(commonProperties, {\n    \"action\": DEFAULT_TYPE_TEXT,\n    \"attach\": {\n      defaultType: \"uri\"\n    },\n    \"attendee\": {\n      defaultType: \"cal-address\"\n    },\n    \"calscale\": DEFAULT_TYPE_TEXT,\n    \"class\": DEFAULT_TYPE_TEXT,\n    \"comment\": DEFAULT_TYPE_TEXT,\n    \"completed\": DEFAULT_TYPE_DATETIME,\n    \"contact\": DEFAULT_TYPE_TEXT,\n    \"created\": DEFAULT_TYPE_DATETIME,\n    \"description\": DEFAULT_TYPE_TEXT,\n    \"dtend\": DEFAULT_TYPE_DATETIME_DATE,\n    \"dtstamp\": DEFAULT_TYPE_DATETIME,\n    \"dtstart\": DEFAULT_TYPE_DATETIME_DATE,\n    \"due\": DEFAULT_TYPE_DATETIME_DATE,\n    \"duration\": {\n      defaultType: \"duration\"\n    },\n    \"exdate\": {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\"],\n      multiValue: ','\n    },\n    \"exrule\": DEFAULT_TYPE_RECUR,\n    \"freebusy\": {\n      defaultType: \"period\",\n      multiValue: \",\"\n    },\n    \"geo\": {\n      defaultType: \"float\",\n      structuredValue: \";\"\n    },\n    \"last-modified\": DEFAULT_TYPE_DATETIME,\n    \"location\": DEFAULT_TYPE_TEXT,\n    \"method\": DEFAULT_TYPE_TEXT,\n    \"organizer\": {\n      defaultType: \"cal-address\"\n    },\n    \"percent-complete\": DEFAULT_TYPE_INTEGER,\n    \"priority\": DEFAULT_TYPE_INTEGER,\n    \"prodid\": DEFAULT_TYPE_TEXT,\n    \"related-to\": DEFAULT_TYPE_TEXT,\n    \"repeat\": DEFAULT_TYPE_INTEGER,\n    \"rdate\": {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\", \"period\"],\n      multiValue: ',',\n      detectType: function (string) {\n        if (string.indexOf('/') !== -1) {\n          return 'period';\n        }\n        return string.indexOf('T') === -1 ? 'date' : 'date-time';\n      }\n    },\n    \"recurrence-id\": DEFAULT_TYPE_DATETIME_DATE,\n    \"resources\": DEFAULT_TYPE_TEXT_MULTI,\n    \"request-status\": DEFAULT_TYPE_TEXT_STRUCTURED,\n    \"rrule\": DEFAULT_TYPE_RECUR,\n    \"sequence\": DEFAULT_TYPE_INTEGER,\n    \"status\": DEFAULT_TYPE_TEXT,\n    \"summary\": DEFAULT_TYPE_TEXT,\n    \"transp\": DEFAULT_TYPE_TEXT,\n    \"trigger\": {\n      defaultType: \"duration\",\n      allowedTypes: [\"duration\", \"date-time\"]\n    },\n    \"tzoffsetfrom\": DEFAULT_TYPE_UTCOFFSET,\n    \"tzoffsetto\": DEFAULT_TYPE_UTCOFFSET,\n    \"tzurl\": DEFAULT_TYPE_URI,\n    \"tzid\": DEFAULT_TYPE_TEXT,\n    \"tzname\": DEFAULT_TYPE_TEXT\n  });\n\n  // When adding a value here, be sure to add it to the parameter types!\n  var vcardValues = ICAL.helpers.extend(commonValues, {\n    text: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),\n    uri: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),\n    date: {\n      decorate: function (aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(aValue, \"date\");\n      },\n      undecorate: function (aValue) {\n        return aValue.toString();\n      },\n      fromICAL: function (aValue) {\n        if (aValue.length == 8) {\n          return icalValues.date.fromICAL(aValue);\n        } else if (aValue[0] == '-' && aValue.length == 6) {\n          return aValue.substr(0, 4) + '-' + aValue.substr(4);\n        } else {\n          return aValue;\n        }\n      },\n      toICAL: function (aValue) {\n        if (aValue.length == 10) {\n          return icalValues.date.toICAL(aValue);\n        } else if (aValue[0] == '-' && aValue.length == 7) {\n          return aValue.substr(0, 4) + aValue.substr(5);\n        } else {\n          return aValue;\n        }\n      }\n    },\n    time: {\n      decorate: function (aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(\"T\" + aValue, \"time\");\n      },\n      undecorate: function (aValue) {\n        return aValue.toString();\n      },\n      fromICAL: function (aValue) {\n        var splitzone = vcardValues.time._splitZone(aValue, true);\n        var zone = splitzone[0],\n          value = splitzone[1];\n\n        //console.log(\"SPLIT: \",splitzone);\n\n        if (value.length == 6) {\n          value = value.substr(0, 2) + ':' + value.substr(2, 2) + ':' + value.substr(4, 2);\n        } else if (value.length == 4 && value[0] != '-') {\n          value = value.substr(0, 2) + ':' + value.substr(2, 2);\n        } else if (value.length == 5) {\n          value = value.substr(0, 3) + ':' + value.substr(3, 2);\n        }\n        if (zone.length == 5 && (zone[0] == '-' || zone[0] == '+')) {\n          zone = zone.substr(0, 3) + ':' + zone.substr(3);\n        }\n        return value + zone;\n      },\n      toICAL: function (aValue) {\n        var splitzone = vcardValues.time._splitZone(aValue);\n        var zone = splitzone[0],\n          value = splitzone[1];\n        if (value.length == 8) {\n          value = value.substr(0, 2) + value.substr(3, 2) + value.substr(6, 2);\n        } else if (value.length == 5 && value[0] != '-') {\n          value = value.substr(0, 2) + value.substr(3, 2);\n        } else if (value.length == 6) {\n          value = value.substr(0, 3) + value.substr(4, 2);\n        }\n        if (zone.length == 6 && (zone[0] == '-' || zone[0] == '+')) {\n          zone = zone.substr(0, 3) + zone.substr(4);\n        }\n        return value + zone;\n      },\n      _splitZone: function (aValue, isFromIcal) {\n        var lastChar = aValue.length - 1;\n        var signChar = aValue.length - (isFromIcal ? 5 : 6);\n        var sign = aValue[signChar];\n        var zone, value;\n        if (aValue[lastChar] == 'Z') {\n          zone = aValue[lastChar];\n          value = aValue.substr(0, lastChar);\n        } else if (aValue.length > 6 && (sign == '-' || sign == '+')) {\n          zone = aValue.substr(signChar);\n          value = aValue.substr(0, signChar);\n        } else {\n          zone = \"\";\n          value = aValue;\n        }\n        return [zone, value];\n      }\n    },\n    \"date-time\": {\n      decorate: function (aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(aValue, \"date-time\");\n      },\n      undecorate: function (aValue) {\n        return aValue.toString();\n      },\n      fromICAL: function (aValue) {\n        return vcardValues['date-and-or-time'].fromICAL(aValue);\n      },\n      toICAL: function (aValue) {\n        return vcardValues['date-and-or-time'].toICAL(aValue);\n      }\n    },\n    \"date-and-or-time\": {\n      decorate: function (aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(aValue, \"date-and-or-time\");\n      },\n      undecorate: function (aValue) {\n        return aValue.toString();\n      },\n      fromICAL: function (aValue) {\n        var parts = aValue.split('T');\n        return (parts[0] ? vcardValues.date.fromICAL(parts[0]) : '') + (parts[1] ? 'T' + vcardValues.time.fromICAL(parts[1]) : '');\n      },\n      toICAL: function (aValue) {\n        var parts = aValue.split('T');\n        return vcardValues.date.toICAL(parts[0]) + (parts[1] ? 'T' + vcardValues.time.toICAL(parts[1]) : '');\n      }\n    },\n    timestamp: icalValues['date-time'],\n    \"language-tag\": {\n      matches: /^[a-zA-Z0-9-]+$/ // Could go with a more strict regex here\n    }\n  });\n\n  var vcardParams = {\n    \"type\": {\n      valueType: \"text\",\n      multiValue: \",\"\n    },\n    \"value\": {\n      // since the value here is a 'type' lowercase is used.\n      values: [\"text\", \"uri\", \"date\", \"time\", \"date-time\", \"date-and-or-time\", \"timestamp\", \"boolean\", \"integer\", \"float\", \"utc-offset\", \"language-tag\"],\n      allowXName: true,\n      allowIanaToken: true\n    }\n  };\n  var vcardProperties = ICAL.helpers.extend(commonProperties, {\n    \"adr\": {\n      defaultType: \"text\",\n      structuredValue: \";\",\n      multiValue: \",\"\n    },\n    \"anniversary\": DEFAULT_TYPE_DATE_ANDOR_TIME,\n    \"bday\": DEFAULT_TYPE_DATE_ANDOR_TIME,\n    \"caladruri\": DEFAULT_TYPE_URI,\n    \"caluri\": DEFAULT_TYPE_URI,\n    \"clientpidmap\": DEFAULT_TYPE_TEXT_STRUCTURED,\n    \"email\": DEFAULT_TYPE_TEXT,\n    \"fburl\": DEFAULT_TYPE_URI,\n    \"fn\": DEFAULT_TYPE_TEXT,\n    \"gender\": DEFAULT_TYPE_TEXT_STRUCTURED,\n    \"geo\": DEFAULT_TYPE_URI,\n    \"impp\": DEFAULT_TYPE_URI,\n    \"key\": DEFAULT_TYPE_URI,\n    \"kind\": DEFAULT_TYPE_TEXT,\n    \"lang\": {\n      defaultType: \"language-tag\"\n    },\n    \"logo\": DEFAULT_TYPE_URI,\n    \"member\": DEFAULT_TYPE_URI,\n    \"n\": {\n      defaultType: \"text\",\n      structuredValue: \";\",\n      multiValue: \",\"\n    },\n    \"nickname\": DEFAULT_TYPE_TEXT_MULTI,\n    \"note\": DEFAULT_TYPE_TEXT,\n    \"org\": {\n      defaultType: \"text\",\n      structuredValue: \";\"\n    },\n    \"photo\": DEFAULT_TYPE_URI,\n    \"related\": DEFAULT_TYPE_URI,\n    \"rev\": {\n      defaultType: \"timestamp\"\n    },\n    \"role\": DEFAULT_TYPE_TEXT,\n    \"sound\": DEFAULT_TYPE_URI,\n    \"source\": DEFAULT_TYPE_URI,\n    \"tel\": {\n      defaultType: \"uri\",\n      allowedTypes: [\"uri\", \"text\"]\n    },\n    \"title\": DEFAULT_TYPE_TEXT,\n    \"tz\": {\n      defaultType: \"text\",\n      allowedTypes: [\"text\", \"utc-offset\", \"uri\"]\n    },\n    \"xml\": DEFAULT_TYPE_TEXT\n  });\n  var vcard3Values = ICAL.helpers.extend(commonValues, {\n    binary: icalValues.binary,\n    date: vcardValues.date,\n    \"date-time\": vcardValues[\"date-time\"],\n    \"phone-number\": {\n      // TODO\n      /* ... */\n    },\n    uri: icalValues.uri,\n    text: icalValues.text,\n    time: icalValues.time,\n    vcard: icalValues.text,\n    \"utc-offset\": {\n      toICAL: function (aValue) {\n        return aValue.substr(0, 7);\n      },\n      fromICAL: function (aValue) {\n        return aValue.substr(0, 7);\n      },\n      decorate: function (aValue) {\n        return ICAL.UtcOffset.fromString(aValue);\n      },\n      undecorate: function (aValue) {\n        return aValue.toString();\n      }\n    }\n  });\n  var vcard3Params = {\n    \"type\": {\n      valueType: \"text\",\n      multiValue: \",\"\n    },\n    \"value\": {\n      // since the value here is a 'type' lowercase is used.\n      values: [\"text\", \"uri\", \"date\", \"date-time\", \"phone-number\", \"time\", \"boolean\", \"integer\", \"float\", \"utc-offset\", \"vcard\", \"binary\"],\n      allowXName: true,\n      allowIanaToken: true\n    }\n  };\n  var vcard3Properties = ICAL.helpers.extend(commonProperties, {\n    fn: DEFAULT_TYPE_TEXT,\n    n: {\n      defaultType: \"text\",\n      structuredValue: \";\",\n      multiValue: \",\"\n    },\n    nickname: DEFAULT_TYPE_TEXT_MULTI,\n    photo: {\n      defaultType: \"binary\",\n      allowedTypes: [\"binary\", \"uri\"]\n    },\n    bday: {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\"],\n      detectType: function (string) {\n        return string.indexOf('T') === -1 ? 'date' : 'date-time';\n      }\n    },\n    adr: {\n      defaultType: \"text\",\n      structuredValue: \";\",\n      multiValue: \",\"\n    },\n    label: DEFAULT_TYPE_TEXT,\n    tel: {\n      defaultType: \"phone-number\"\n    },\n    email: DEFAULT_TYPE_TEXT,\n    mailer: DEFAULT_TYPE_TEXT,\n    tz: {\n      defaultType: \"utc-offset\",\n      allowedTypes: [\"utc-offset\", \"text\"]\n    },\n    geo: {\n      defaultType: \"float\",\n      structuredValue: \";\"\n    },\n    title: DEFAULT_TYPE_TEXT,\n    role: DEFAULT_TYPE_TEXT,\n    logo: {\n      defaultType: \"binary\",\n      allowedTypes: [\"binary\", \"uri\"]\n    },\n    agent: {\n      defaultType: \"vcard\",\n      allowedTypes: [\"vcard\", \"text\", \"uri\"]\n    },\n    org: DEFAULT_TYPE_TEXT_STRUCTURED,\n    note: DEFAULT_TYPE_TEXT_MULTI,\n    prodid: DEFAULT_TYPE_TEXT,\n    rev: {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\"],\n      detectType: function (string) {\n        return string.indexOf('T') === -1 ? 'date' : 'date-time';\n      }\n    },\n    \"sort-string\": DEFAULT_TYPE_TEXT,\n    sound: {\n      defaultType: \"binary\",\n      allowedTypes: [\"binary\", \"uri\"]\n    },\n    class: DEFAULT_TYPE_TEXT,\n    key: {\n      defaultType: \"binary\",\n      allowedTypes: [\"binary\", \"text\"]\n    }\n  });\n\n  /**\n   * iCalendar design set\n   * @type {ICAL.design.designSet}\n   */\n  var icalSet = {\n    value: icalValues,\n    param: icalParams,\n    property: icalProperties\n  };\n\n  /**\n   * vCard 4.0 design set\n   * @type {ICAL.design.designSet}\n   */\n  var vcardSet = {\n    value: vcardValues,\n    param: vcardParams,\n    property: vcardProperties\n  };\n\n  /**\n   * vCard 3.0 design set\n   * @type {ICAL.design.designSet}\n   */\n  var vcard3Set = {\n    value: vcard3Values,\n    param: vcard3Params,\n    property: vcard3Properties\n  };\n\n  /**\n   * The design data, used by the parser to determine types for properties and\n   * other metadata needed to produce correct jCard/jCal data.\n   *\n   * @alias ICAL.design\n   * @namespace\n   */\n  var design = {\n    /**\n     * A designSet describes value, parameter and property data. It is used by\n     * ther parser and stringifier in components and properties to determine they\n     * should be represented.\n     *\n     * @typedef {Object} designSet\n     * @memberOf ICAL.design\n     * @property {Object} value       Definitions for value types, keys are type names\n     * @property {Object} param       Definitions for params, keys are param names\n     * @property {Object} property    Defintions for properties, keys are property names\n     */\n\n    /**\n     * Can be set to false to make the parser more lenient.\n     */\n    strict: true,\n    /**\n     * The default set for new properties and components if none is specified.\n     * @type {ICAL.design.designSet}\n     */\n    defaultSet: icalSet,\n    /**\n     * The default type for unknown properties\n     * @type {String}\n     */\n    defaultType: 'unknown',\n    /**\n     * Holds the design set for known top-level components\n     *\n     * @type {Object}\n     * @property {ICAL.design.designSet} vcard       vCard VCARD\n     * @property {ICAL.design.designSet} vevent      iCalendar VEVENT\n     * @property {ICAL.design.designSet} vtodo       iCalendar VTODO\n     * @property {ICAL.design.designSet} vjournal    iCalendar VJOURNAL\n     * @property {ICAL.design.designSet} valarm      iCalendar VALARM\n     * @property {ICAL.design.designSet} vtimezone   iCalendar VTIMEZONE\n     * @property {ICAL.design.designSet} daylight    iCalendar DAYLIGHT\n     * @property {ICAL.design.designSet} standard    iCalendar STANDARD\n     *\n     * @example\n     * var propertyName = 'fn';\n     * var componentDesign = ICAL.design.components.vcard;\n     * var propertyDetails = componentDesign.property[propertyName];\n     * if (propertyDetails.defaultType == 'text') {\n     *   // Yep, sure is...\n     * }\n     */\n    components: {\n      vcard: vcardSet,\n      vcard3: vcard3Set,\n      vevent: icalSet,\n      vtodo: icalSet,\n      vjournal: icalSet,\n      valarm: icalSet,\n      vtimezone: icalSet,\n      daylight: icalSet,\n      standard: icalSet\n    },\n    /**\n     * The design set for iCalendar (rfc5545/rfc7265) components.\n     * @type {ICAL.design.designSet}\n     */\n    icalendar: icalSet,\n    /**\n     * The design set for vCard (rfc6350/rfc7095) components.\n     * @type {ICAL.design.designSet}\n     */\n    vcard: vcardSet,\n    /**\n     * The design set for vCard (rfc2425/rfc2426/rfc7095) components.\n     * @type {ICAL.design.designSet}\n     */\n    vcard3: vcard3Set,\n    /**\n     * Gets the design set for the given component name.\n     *\n     * @param {String} componentName        The name of the component\n     * @return {ICAL.design.designSet}      The design set for the component\n     */\n    getDesignSet: function (componentName) {\n      var isInDesign = componentName && componentName in design.components;\n      return isInDesign ? design.components[componentName] : design.defaultSet;\n    }\n  };\n  return design;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * Contains various functions to convert jCal and jCard data back into\n * iCalendar and vCard.\n * @namespace\n */\nICAL.stringify = function () {\n  'use strict';\n\n  var LINE_ENDING = '\\r\\n';\n  var DEFAULT_VALUE_TYPE = 'unknown';\n  var design = ICAL.design;\n  var helpers = ICAL.helpers;\n\n  /**\n   * Convert a full jCal/jCard array into a iCalendar/vCard string.\n   *\n   * @function ICAL.stringify\n   * @variation function\n   * @param {Array} jCal    The jCal/jCard document\n   * @return {String}       The stringified iCalendar/vCard document\n   */\n  function stringify(jCal) {\n    if (typeof jCal[0] == \"string\") {\n      // This is a single component\n      jCal = [jCal];\n    }\n    var i = 0;\n    var len = jCal.length;\n    var result = '';\n    for (; i < len; i++) {\n      result += stringify.component(jCal[i]) + LINE_ENDING;\n    }\n    return result;\n  }\n\n  /**\n   * Converts an jCal component array into a ICAL string.\n   * Recursive will resolve sub-components.\n   *\n   * Exact component/property order is not saved all\n   * properties will come before subcomponents.\n   *\n   * @function ICAL.stringify.component\n   * @param {Array} component\n   *        jCal/jCard fragment of a component\n   * @param {ICAL.design.designSet} designSet\n   *        The design data to use for this component\n   * @return {String}       The iCalendar/vCard string\n   */\n  stringify.component = function (component, designSet) {\n    var name = component[0].toUpperCase();\n    var result = 'BEGIN:' + name + LINE_ENDING;\n    var props = component[1];\n    var propIdx = 0;\n    var propLen = props.length;\n    var designSetName = component[0];\n    // rfc6350 requires that in vCard 4.0 the first component is the VERSION\n    // component with as value 4.0, note that 3.0 does not have this requirement.\n    if (designSetName === 'vcard' && component[1].length > 0 && !(component[1][0][0] === \"version\" && component[1][0][3] === \"4.0\")) {\n      designSetName = \"vcard3\";\n    }\n    designSet = designSet || design.getDesignSet(designSetName);\n    for (; propIdx < propLen; propIdx++) {\n      result += stringify.property(props[propIdx], designSet) + LINE_ENDING;\n    }\n\n    // Ignore subcomponents if none exist, e.g. in vCard.\n    var comps = component[2] || [];\n    var compIdx = 0;\n    var compLen = comps.length;\n    for (; compIdx < compLen; compIdx++) {\n      result += stringify.component(comps[compIdx], designSet) + LINE_ENDING;\n    }\n    result += 'END:' + name;\n    return result;\n  };\n\n  /**\n   * Converts a single jCal/jCard property to a iCalendar/vCard string.\n   *\n   * @function ICAL.stringify.property\n   * @param {Array} property\n   *        jCal/jCard property array\n   * @param {ICAL.design.designSet} designSet\n   *        The design data to use for this property\n   * @param {Boolean} noFold\n   *        If true, the line is not folded\n   * @return {String}       The iCalendar/vCard string\n   */\n  stringify.property = function (property, designSet, noFold) {\n    var name = property[0].toUpperCase();\n    var jsName = property[0];\n    var params = property[1];\n    var line = name;\n    var paramName;\n    for (paramName in params) {\n      var value = params[paramName];\n\n      /* istanbul ignore else */\n      if (params.hasOwnProperty(paramName)) {\n        var multiValue = paramName in designSet.param && designSet.param[paramName].multiValue;\n        if (multiValue && Array.isArray(value)) {\n          if (designSet.param[paramName].multiValueSeparateDQuote) {\n            multiValue = '\"' + multiValue + '\"';\n          }\n          value = value.map(stringify._rfc6868Unescape);\n          value = stringify.multiValue(value, multiValue, \"unknown\", null, designSet);\n        } else {\n          value = stringify._rfc6868Unescape(value);\n        }\n        line += ';' + paramName.toUpperCase();\n        line += '=' + stringify.propertyValue(value);\n      }\n    }\n    if (property.length === 3) {\n      // If there are no values, we must assume a blank value\n      return line + ':';\n    }\n    var valueType = property[2];\n    if (!designSet) {\n      designSet = design.defaultSet;\n    }\n    var propDetails;\n    var multiValue = false;\n    var structuredValue = false;\n    var isDefault = false;\n    if (jsName in designSet.property) {\n      propDetails = designSet.property[jsName];\n      if ('multiValue' in propDetails) {\n        multiValue = propDetails.multiValue;\n      }\n      if ('structuredValue' in propDetails && Array.isArray(property[3])) {\n        structuredValue = propDetails.structuredValue;\n      }\n      if ('defaultType' in propDetails) {\n        if (valueType === propDetails.defaultType) {\n          isDefault = true;\n        }\n      } else {\n        if (valueType === DEFAULT_VALUE_TYPE) {\n          isDefault = true;\n        }\n      }\n    } else {\n      if (valueType === DEFAULT_VALUE_TYPE) {\n        isDefault = true;\n      }\n    }\n\n    // push the VALUE property if type is not the default\n    // for the current property.\n    if (!isDefault) {\n      // value will never contain ;/:/, so we don't escape it here.\n      line += ';VALUE=' + valueType.toUpperCase();\n    }\n    line += ':';\n    if (multiValue && structuredValue) {\n      line += stringify.multiValue(property[3], structuredValue, valueType, multiValue, designSet, structuredValue);\n    } else if (multiValue) {\n      line += stringify.multiValue(property.slice(3), multiValue, valueType, null, designSet, false);\n    } else if (structuredValue) {\n      line += stringify.multiValue(property[3], structuredValue, valueType, null, designSet, structuredValue);\n    } else {\n      line += stringify.value(property[3], valueType, designSet, false);\n    }\n    return noFold ? line : ICAL.helpers.foldline(line);\n  };\n\n  /**\n   * Handles escaping of property values that may contain:\n   *\n   *    COLON (:), SEMICOLON (;), or COMMA (,)\n   *\n   * If any of the above are present the result is wrapped\n   * in double quotes.\n   *\n   * @function ICAL.stringify.propertyValue\n   * @param {String} value      Raw property value\n   * @return {String}           Given or escaped value when needed\n   */\n  stringify.propertyValue = function (value) {\n    if (helpers.unescapedIndexOf(value, ',') === -1 && helpers.unescapedIndexOf(value, ':') === -1 && helpers.unescapedIndexOf(value, ';') === -1) {\n      return value;\n    }\n    return '\"' + value + '\"';\n  };\n\n  /**\n   * Converts an array of ical values into a single\n   * string based on a type and a delimiter value (like \",\").\n   *\n   * @function ICAL.stringify.multiValue\n   * @param {Array} values      List of values to convert\n   * @param {String} delim      Used to join the values (\",\", \";\", \":\")\n   * @param {String} type       Lowecase ical value type\n   *        (like boolean, date-time, etc..)\n   * @param {?String} innerMulti If set, each value will again be processed\n   *        Used for structured values\n   * @param {ICAL.design.designSet} designSet\n   *        The design data to use for this property\n   *\n   * @return {String}           iCalendar/vCard string for value\n   */\n  stringify.multiValue = function (values, delim, type, innerMulti, designSet, structuredValue) {\n    var result = '';\n    var len = values.length;\n    var i = 0;\n    for (; i < len; i++) {\n      if (innerMulti && Array.isArray(values[i])) {\n        result += stringify.multiValue(values[i], innerMulti, type, null, designSet, structuredValue);\n      } else {\n        result += stringify.value(values[i], type, designSet, structuredValue);\n      }\n      if (i !== len - 1) {\n        result += delim;\n      }\n    }\n    return result;\n  };\n\n  /**\n   * Processes a single ical value runs the associated \"toICAL\" method from the\n   * design value type if available to convert the value.\n   *\n   * @function ICAL.stringify.value\n   * @param {String|Number} value       A formatted value\n   * @param {String} type               Lowercase iCalendar/vCard value type\n   *  (like boolean, date-time, etc..)\n   * @return {String}                   iCalendar/vCard value for single value\n   */\n  stringify.value = function (value, type, designSet, structuredValue) {\n    if (type in designSet.value && 'toICAL' in designSet.value[type]) {\n      return designSet.value[type].toICAL(value, structuredValue);\n    }\n    return value;\n  };\n\n  /**\n   * Internal helper for rfc6868. Exposing this on ICAL.stringify so that\n   * hackers can disable the rfc6868 parsing if the really need to.\n   *\n   * @param {String} val        The value to unescape\n   * @return {String}           The escaped value\n   */\n  stringify._rfc6868Unescape = function (val) {\n    return val.replace(/[\\n^\"]/g, function (x) {\n      return RFC6868_REPLACE_MAP[x];\n    });\n  };\n  var RFC6868_REPLACE_MAP = {\n    '\"': \"^'\",\n    \"\\n\": \"^n\",\n    \"^\": \"^^\"\n  };\n  return stringify;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * Contains various functions to parse iCalendar and vCard data.\n * @namespace\n */\nICAL.parse = function () {\n  'use strict';\n\n  var CHAR = /[^ \\t]/;\n  var MULTIVALUE_DELIMITER = ',';\n  var VALUE_DELIMITER = ':';\n  var PARAM_DELIMITER = ';';\n  var PARAM_NAME_DELIMITER = '=';\n  var DEFAULT_VALUE_TYPE = 'unknown';\n  var DEFAULT_PARAM_TYPE = 'text';\n  var design = ICAL.design;\n  var helpers = ICAL.helpers;\n\n  /**\n   * An error that occurred during parsing.\n   *\n   * @param {String} message        The error message\n   * @memberof ICAL.parse\n   * @extends {Error}\n   * @class\n   */\n  function ParserError(message) {\n    this.message = message;\n    this.name = 'ParserError';\n    try {\n      throw new Error();\n    } catch (e) {\n      if (e.stack) {\n        var split = e.stack.split('\\n');\n        split.shift();\n        this.stack = split.join('\\n');\n      }\n    }\n  }\n  ParserError.prototype = Error.prototype;\n\n  /**\n   * Parses iCalendar or vCard data into a raw jCal object. Consult\n   * documentation on the {@tutorial layers|layers of parsing} for more\n   * details.\n   *\n   * @function ICAL.parse\n   * @variation function\n   * @todo Fix the API to be more clear on the return type\n   * @param {String} input      The string data to parse\n   * @return {Object|Object[]}  A single jCal object, or an array thereof\n   */\n  function parser(input) {\n    var state = {};\n    var root = state.component = [];\n    state.stack = [root];\n    parser._eachLine(input, function (err, line) {\n      parser._handleContentLine(line, state);\n    });\n\n    // when there are still items on the stack\n    // throw a fatal error, a component was not closed\n    // correctly in that case.\n    if (state.stack.length > 1) {\n      throw new ParserError('invalid ical body. component began but did not end');\n    }\n    state = null;\n    return root.length == 1 ? root[0] : root;\n  }\n\n  /**\n   * Parse an iCalendar property value into the jCal for a single property\n   *\n   * @function ICAL.parse.property\n   * @param {String} str\n   *   The iCalendar property string to parse\n   * @param {ICAL.design.designSet=} designSet\n   *   The design data to use for this property\n   * @return {Object}\n   *   The jCal Object containing the property\n   */\n  parser.property = function (str, designSet) {\n    var state = {\n      component: [[], []],\n      designSet: designSet || design.defaultSet\n    };\n    parser._handleContentLine(str, state);\n    return state.component[1][0];\n  };\n\n  /**\n   * Convenience method to parse a component. You can use ICAL.parse() directly\n   * instead.\n   *\n   * @function ICAL.parse.component\n   * @see ICAL.parse(function)\n   * @param {String} str    The iCalendar component string to parse\n   * @return {Object}       The jCal Object containing the component\n   */\n  parser.component = function (str) {\n    return parser(str);\n  };\n\n  // classes & constants\n  parser.ParserError = ParserError;\n\n  /**\n   * The state for parsing content lines from an iCalendar/vCard string.\n   *\n   * @private\n   * @memberof ICAL.parse\n   * @typedef {Object} parserState\n   * @property {ICAL.design.designSet} designSet    The design set to use for parsing\n   * @property {ICAL.Component[]} stack             The stack of components being processed\n   * @property {ICAL.Component} component           The currently active component\n   */\n\n  /**\n   * Handles a single line of iCalendar/vCard, updating the state.\n   *\n   * @private\n   * @function ICAL.parse._handleContentLine\n   * @param {String} line               The content line to process\n   * @param {ICAL.parse.parserState}    The current state of the line parsing\n   */\n  parser._handleContentLine = function (line, state) {\n    // break up the parts of the line\n    var valuePos = line.indexOf(VALUE_DELIMITER);\n    var paramPos = line.indexOf(PARAM_DELIMITER);\n    var lastParamIndex;\n    var lastValuePos;\n\n    // name of property or begin/end\n    var name;\n    var value;\n    // params is only overridden if paramPos !== -1.\n    // we can't do params = params || {} later on\n    // because it sacrifices ops.\n    var params = {};\n\n    /**\n     * Different property cases\n     *\n     *\n     * 1. RRULE:FREQ=foo\n     *    // FREQ= is not a param but the value\n     *\n     * 2. ATTENDEE;ROLE=REQ-PARTICIPANT;\n     *    // ROLE= is a param because : has not happened yet\n     */\n    // when the parameter delimiter is after the\n    // value delimiter then it is not a parameter.\n\n    if (paramPos !== -1 && valuePos !== -1) {\n      // when the parameter delimiter is after the\n      // value delimiter then it is not a parameter.\n      if (paramPos > valuePos) {\n        paramPos = -1;\n      }\n    }\n    var parsedParams;\n    if (paramPos !== -1) {\n      name = line.substring(0, paramPos).toLowerCase();\n      parsedParams = parser._parseParameters(line.substring(paramPos), 0, state.designSet);\n      if (parsedParams[2] == -1) {\n        throw new ParserError(\"Invalid parameters in '\" + line + \"'\");\n      }\n      params = parsedParams[0];\n      lastParamIndex = parsedParams[1].length + parsedParams[2] + paramPos;\n      if ((lastValuePos = line.substring(lastParamIndex).indexOf(VALUE_DELIMITER)) !== -1) {\n        value = line.substring(lastParamIndex + lastValuePos + 1);\n      } else {\n        throw new ParserError(\"Missing parameter value in '\" + line + \"'\");\n      }\n    } else if (valuePos !== -1) {\n      // without parmeters (BEGIN:VCAENDAR, CLASS:PUBLIC)\n      name = line.substring(0, valuePos).toLowerCase();\n      value = line.substring(valuePos + 1);\n      if (name === 'begin') {\n        var newComponent = [value.toLowerCase(), [], []];\n        if (state.stack.length === 1) {\n          state.component.push(newComponent);\n        } else {\n          state.component[2].push(newComponent);\n        }\n        state.stack.push(state.component);\n        state.component = newComponent;\n        if (!state.designSet) {\n          state.designSet = design.getDesignSet(state.component[0]);\n        }\n        return;\n      } else if (name === 'end') {\n        state.component = state.stack.pop();\n        return;\n      }\n      // If it is not begin/end, then this is a property with an empty value,\n      // which should be considered valid.\n    } else {\n      /**\n       * Invalid line.\n       * The rational to throw an error is we will\n       * never be certain that the rest of the file\n       * is sane and it is unlikely that we can serialize\n       * the result correctly either.\n       */\n      throw new ParserError('invalid line (no token \";\" or \":\") \"' + line + '\"');\n    }\n    var valueType;\n    var multiValue = false;\n    var structuredValue = false;\n    var propertyDetails;\n    if (name in state.designSet.property) {\n      propertyDetails = state.designSet.property[name];\n      if ('multiValue' in propertyDetails) {\n        multiValue = propertyDetails.multiValue;\n      }\n      if ('structuredValue' in propertyDetails) {\n        structuredValue = propertyDetails.structuredValue;\n      }\n      if (value && 'detectType' in propertyDetails) {\n        valueType = propertyDetails.detectType(value);\n      }\n    }\n\n    // attempt to determine value\n    if (!valueType) {\n      if (!('value' in params)) {\n        if (propertyDetails) {\n          valueType = propertyDetails.defaultType;\n        } else {\n          valueType = DEFAULT_VALUE_TYPE;\n        }\n      } else {\n        // possible to avoid this?\n        valueType = params.value.toLowerCase();\n      }\n    }\n    delete params.value;\n\n    /**\n     * Note on `var result` juggling:\n     *\n     * I observed that building the array in pieces has adverse\n     * effects on performance, so where possible we inline the creation.\n     * It is a little ugly but resulted in ~2000 additional ops/sec.\n     */\n\n    var result;\n    if (multiValue && structuredValue) {\n      value = parser._parseMultiValue(value, structuredValue, valueType, [], multiValue, state.designSet, structuredValue);\n      result = [name, params, valueType, value];\n    } else if (multiValue) {\n      result = [name, params, valueType];\n      parser._parseMultiValue(value, multiValue, valueType, result, null, state.designSet, false);\n    } else if (structuredValue) {\n      value = parser._parseMultiValue(value, structuredValue, valueType, [], null, state.designSet, structuredValue);\n      result = [name, params, valueType, value];\n    } else {\n      value = parser._parseValue(value, valueType, state.designSet, false);\n      result = [name, params, valueType, value];\n    }\n    // rfc6350 requires that in vCard 4.0 the first component is the VERSION\n    // component with as value 4.0, note that 3.0 does not have this requirement.\n    if (state.component[0] === 'vcard' && state.component[1].length === 0 && !(name === 'version' && value === '4.0')) {\n      state.designSet = design.getDesignSet(\"vcard3\");\n    }\n    state.component[1].push(result);\n  };\n\n  /**\n   * Parse a value from the raw value into the jCard/jCal value.\n   *\n   * @private\n   * @function ICAL.parse._parseValue\n   * @param {String} value          Original value\n   * @param {String} type           Type of value\n   * @param {Object} designSet      The design data to use for this value\n   * @return {Object} varies on type\n   */\n  parser._parseValue = function (value, type, designSet, structuredValue) {\n    if (type in designSet.value && 'fromICAL' in designSet.value[type]) {\n      return designSet.value[type].fromICAL(value, structuredValue);\n    }\n    return value;\n  };\n\n  /**\n   * Parse parameters from a string to object.\n   *\n   * @function ICAL.parse._parseParameters\n   * @private\n   * @param {String} line           A single unfolded line\n   * @param {Numeric} start         Position to start looking for properties\n   * @param {Object} designSet      The design data to use for this property\n   * @return {Object} key/value pairs\n   */\n  parser._parseParameters = function (line, start, designSet) {\n    var lastParam = start;\n    var pos = 0;\n    var delim = PARAM_NAME_DELIMITER;\n    var result = {};\n    var name, lcname;\n    var value,\n      valuePos = -1;\n    var type, multiValue, mvdelim;\n\n    // find the next '=' sign\n    // use lastParam and pos to find name\n    // check if \" is used if so get value from \"->\"\n    // then increment pos to find next ;\n\n    while (pos !== false && (pos = helpers.unescapedIndexOf(line, delim, pos + 1)) !== -1) {\n      name = line.substr(lastParam + 1, pos - lastParam - 1);\n      if (name.length == 0) {\n        throw new ParserError(\"Empty parameter name in '\" + line + \"'\");\n      }\n      lcname = name.toLowerCase();\n      mvdelim = false;\n      multiValue = false;\n      if (lcname in designSet.param && designSet.param[lcname].valueType) {\n        type = designSet.param[lcname].valueType;\n      } else {\n        type = DEFAULT_PARAM_TYPE;\n      }\n      if (lcname in designSet.param) {\n        multiValue = designSet.param[lcname].multiValue;\n        if (designSet.param[lcname].multiValueSeparateDQuote) {\n          mvdelim = parser._rfc6868Escape('\"' + multiValue + '\"');\n        }\n      }\n      var nextChar = line[pos + 1];\n      if (nextChar === '\"') {\n        valuePos = pos + 2;\n        pos = helpers.unescapedIndexOf(line, '\"', valuePos);\n        if (multiValue && pos != -1) {\n          var extendedValue = true;\n          while (extendedValue) {\n            if (line[pos + 1] == multiValue && line[pos + 2] == '\"') {\n              pos = helpers.unescapedIndexOf(line, '\"', pos + 3);\n            } else {\n              extendedValue = false;\n            }\n          }\n        }\n        if (pos === -1) {\n          throw new ParserError('invalid line (no matching double quote) \"' + line + '\"');\n        }\n        value = line.substr(valuePos, pos - valuePos);\n        lastParam = helpers.unescapedIndexOf(line, PARAM_DELIMITER, pos);\n        if (lastParam === -1) {\n          pos = false;\n        }\n      } else {\n        valuePos = pos + 1;\n\n        // move to next \";\"\n        var nextPos = helpers.unescapedIndexOf(line, PARAM_DELIMITER, valuePos);\n        var propValuePos = helpers.unescapedIndexOf(line, VALUE_DELIMITER, valuePos);\n        if (propValuePos !== -1 && nextPos > propValuePos) {\n          // this is a delimiter in the property value, let's stop here\n          nextPos = propValuePos;\n          pos = false;\n        } else if (nextPos === -1) {\n          // no \";\"\n          if (propValuePos === -1) {\n            nextPos = line.length;\n          } else {\n            nextPos = propValuePos;\n          }\n          pos = false;\n        } else {\n          lastParam = nextPos;\n          pos = nextPos;\n        }\n        value = line.substr(valuePos, nextPos - valuePos);\n      }\n      value = parser._rfc6868Escape(value);\n      if (multiValue) {\n        var delimiter = mvdelim || multiValue;\n        value = parser._parseMultiValue(value, delimiter, type, [], null, designSet);\n      } else {\n        value = parser._parseValue(value, type, designSet);\n      }\n      if (multiValue && lcname in result) {\n        if (Array.isArray(result[lcname])) {\n          result[lcname].push(value);\n        } else {\n          result[lcname] = [result[lcname], value];\n        }\n      } else {\n        result[lcname] = value;\n      }\n    }\n    return [result, value, valuePos];\n  };\n\n  /**\n   * Internal helper for rfc6868. Exposing this on ICAL.parse so that\n   * hackers can disable the rfc6868 parsing if the really need to.\n   *\n   * @function ICAL.parse._rfc6868Escape\n   * @param {String} val        The value to escape\n   * @return {String}           The escaped value\n   */\n  parser._rfc6868Escape = function (val) {\n    return val.replace(/\\^['n^]/g, function (x) {\n      return RFC6868_REPLACE_MAP[x];\n    });\n  };\n  var RFC6868_REPLACE_MAP = {\n    \"^'\": '\"',\n    \"^n\": \"\\n\",\n    \"^^\": \"^\"\n  };\n\n  /**\n   * Parse a multi value string. This function is used either for parsing\n   * actual multi-value property's values, or for handling parameter values. It\n   * can be used for both multi-value properties and structured value properties.\n   *\n   * @private\n   * @function ICAL.parse._parseMultiValue\n   * @param {String} buffer     The buffer containing the full value\n   * @param {String} delim      The multi-value delimiter\n   * @param {String} type       The value type to be parsed\n   * @param {Array.<?>} result        The array to append results to, varies on value type\n   * @param {String} innerMulti The inner delimiter to split each value with\n   * @param {ICAL.design.designSet} designSet   The design data for this value\n   * @return {?|Array.<?>}            Either an array of results, or the first result\n   */\n  parser._parseMultiValue = function (buffer, delim, type, result, innerMulti, designSet, structuredValue) {\n    var pos = 0;\n    var lastPos = 0;\n    var value;\n    if (delim.length === 0) {\n      return buffer;\n    }\n\n    // split each piece\n    while ((pos = helpers.unescapedIndexOf(buffer, delim, lastPos)) !== -1) {\n      value = buffer.substr(lastPos, pos - lastPos);\n      if (innerMulti) {\n        value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);\n      } else {\n        value = parser._parseValue(value, type, designSet, structuredValue);\n      }\n      result.push(value);\n      lastPos = pos + delim.length;\n    }\n\n    // on the last piece take the rest of string\n    value = buffer.substr(lastPos);\n    if (innerMulti) {\n      value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);\n    } else {\n      value = parser._parseValue(value, type, designSet, structuredValue);\n    }\n    result.push(value);\n    return result.length == 1 ? result[0] : result;\n  };\n\n  /**\n   * Process a complete buffer of iCalendar/vCard data line by line, correctly\n   * unfolding content. Each line will be processed with the given callback\n   *\n   * @private\n   * @function ICAL.parse._eachLine\n   * @param {String} buffer                         The buffer to process\n   * @param {function(?String, String)} callback    The callback for each line\n   */\n  parser._eachLine = function (buffer, callback) {\n    var len = buffer.length;\n    var lastPos = buffer.search(CHAR);\n    var pos = lastPos;\n    var line;\n    var firstChar;\n    var newlineOffset;\n    do {\n      pos = buffer.indexOf('\\n', lastPos) + 1;\n      if (pos > 1 && buffer[pos - 2] === '\\r') {\n        newlineOffset = 2;\n      } else {\n        newlineOffset = 1;\n      }\n      if (pos === 0) {\n        pos = len;\n        newlineOffset = 0;\n      }\n      firstChar = buffer[lastPos];\n      if (firstChar === ' ' || firstChar === '\\t') {\n        // add to line\n        line += buffer.substr(lastPos + 1, pos - lastPos - (newlineOffset + 1));\n      } else {\n        if (line) callback(null, line);\n        // push line\n        line = buffer.substr(lastPos, pos - lastPos - newlineOffset);\n      }\n      lastPos = pos;\n    } while (pos !== len);\n\n    // extra ending line\n    line = line.trim();\n    if (line.length) callback(null, line);\n  };\n  return parser;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.Component = function () {\n  'use strict';\n\n  var PROPERTY_INDEX = 1;\n  var COMPONENT_INDEX = 2;\n  var NAME_INDEX = 0;\n\n  /**\n   * @classdesc\n   * Wraps a jCal component, adding convenience methods to add, remove and\n   * update subcomponents and properties.\n   *\n   * @class\n   * @alias ICAL.Component\n   * @param {Array|String} jCal         Raw jCal component data OR name of new\n   *                                      component\n   * @param {ICAL.Component} parent     Parent component to associate\n   */\n  function Component(jCal, parent) {\n    if (typeof jCal === 'string') {\n      // jCal spec (name, properties, components)\n      jCal = [jCal, [], []];\n    }\n\n    // mostly for legacy reasons.\n    this.jCal = jCal;\n    this.parent = parent || null;\n  }\n  Component.prototype = {\n    /**\n     * Hydrated properties are inserted into the _properties array at the same\n     * position as in the jCal array, so it is possible that the array contains\n     * undefined values for unhydrdated properties. To avoid iterating the\n     * array when checking if all properties have been hydrated, we save the\n     * count here.\n     *\n     * @type {Number}\n     * @private\n     */\n    _hydratedPropertyCount: 0,\n    /**\n     * The same count as for _hydratedPropertyCount, but for subcomponents\n     *\n     * @type {Number}\n     * @private\n     */\n    _hydratedComponentCount: 0,\n    /**\n     * The name of this component\n     * @readonly\n     */\n    get name() {\n      return this.jCal[NAME_INDEX];\n    },\n    /**\n     * The design set for this component, e.g. icalendar vs vcard\n     *\n     * @type {ICAL.design.designSet}\n     * @private\n     */\n    get _designSet() {\n      var parentDesign = this.parent && this.parent._designSet;\n      return parentDesign || ICAL.design.getDesignSet(this.name);\n    },\n    _hydrateComponent: function (index) {\n      if (!this._components) {\n        this._components = [];\n        this._hydratedComponentCount = 0;\n      }\n      if (this._components[index]) {\n        return this._components[index];\n      }\n      var comp = new Component(this.jCal[COMPONENT_INDEX][index], this);\n      this._hydratedComponentCount++;\n      return this._components[index] = comp;\n    },\n    _hydrateProperty: function (index) {\n      if (!this._properties) {\n        this._properties = [];\n        this._hydratedPropertyCount = 0;\n      }\n      if (this._properties[index]) {\n        return this._properties[index];\n      }\n      var prop = new ICAL.Property(this.jCal[PROPERTY_INDEX][index], this);\n      this._hydratedPropertyCount++;\n      return this._properties[index] = prop;\n    },\n    /**\n     * Finds first sub component, optionally filtered by name.\n     *\n     * @param {String=} name        Optional name to filter by\n     * @return {?ICAL.Component}     The found subcomponent\n     */\n    getFirstSubcomponent: function (name) {\n      if (name) {\n        var i = 0;\n        var comps = this.jCal[COMPONENT_INDEX];\n        var len = comps.length;\n        for (; i < len; i++) {\n          if (comps[i][NAME_INDEX] === name) {\n            var result = this._hydrateComponent(i);\n            return result;\n          }\n        }\n      } else {\n        if (this.jCal[COMPONENT_INDEX].length) {\n          return this._hydrateComponent(0);\n        }\n      }\n\n      // ensure we return a value (strict mode)\n      return null;\n    },\n    /**\n     * Finds all sub components, optionally filtering by name.\n     *\n     * @param {String=} name            Optional name to filter by\n     * @return {ICAL.Component[]}       The found sub components\n     */\n    getAllSubcomponents: function (name) {\n      var jCalLen = this.jCal[COMPONENT_INDEX].length;\n      var i = 0;\n      if (name) {\n        var comps = this.jCal[COMPONENT_INDEX];\n        var result = [];\n        for (; i < jCalLen; i++) {\n          if (name === comps[i][NAME_INDEX]) {\n            result.push(this._hydrateComponent(i));\n          }\n        }\n        return result;\n      } else {\n        if (!this._components || this._hydratedComponentCount !== jCalLen) {\n          for (; i < jCalLen; i++) {\n            this._hydrateComponent(i);\n          }\n        }\n        return this._components || [];\n      }\n    },\n    /**\n     * Returns true when a named property exists.\n     *\n     * @param {String} name     The property name\n     * @return {Boolean}        True, when property is found\n     */\n    hasProperty: function (name) {\n      var props = this.jCal[PROPERTY_INDEX];\n      var len = props.length;\n      var i = 0;\n      for (; i < len; i++) {\n        // 0 is property name\n        if (props[i][NAME_INDEX] === name) {\n          return true;\n        }\n      }\n      return false;\n    },\n    /**\n     * Finds the first property, optionally with the given name.\n     *\n     * @param {String=} name        Lowercase property name\n     * @return {?ICAL.Property}     The found property\n     */\n    getFirstProperty: function (name) {\n      if (name) {\n        var i = 0;\n        var props = this.jCal[PROPERTY_INDEX];\n        var len = props.length;\n        for (; i < len; i++) {\n          if (props[i][NAME_INDEX] === name) {\n            var result = this._hydrateProperty(i);\n            return result;\n          }\n        }\n      } else {\n        if (this.jCal[PROPERTY_INDEX].length) {\n          return this._hydrateProperty(0);\n        }\n      }\n      return null;\n    },\n    /**\n     * Returns first property's value, if available.\n     *\n     * @param {String=} name    Lowercase property name\n     * @return {?String}        The found property value.\n     */\n    getFirstPropertyValue: function (name) {\n      var prop = this.getFirstProperty(name);\n      if (prop) {\n        return prop.getFirstValue();\n      }\n      return null;\n    },\n    /**\n     * Get all properties in the component, optionally filtered by name.\n     *\n     * @param {String=} name        Lowercase property name\n     * @return {ICAL.Property[]}    List of properties\n     */\n    getAllProperties: function (name) {\n      var jCalLen = this.jCal[PROPERTY_INDEX].length;\n      var i = 0;\n      if (name) {\n        var props = this.jCal[PROPERTY_INDEX];\n        var result = [];\n        for (; i < jCalLen; i++) {\n          if (name === props[i][NAME_INDEX]) {\n            result.push(this._hydrateProperty(i));\n          }\n        }\n        return result;\n      } else {\n        if (!this._properties || this._hydratedPropertyCount !== jCalLen) {\n          for (; i < jCalLen; i++) {\n            this._hydrateProperty(i);\n          }\n        }\n        return this._properties || [];\n      }\n    },\n    _removeObjectByIndex: function (jCalIndex, cache, index) {\n      cache = cache || [];\n      // remove cached version\n      if (cache[index]) {\n        var obj = cache[index];\n        if (\"parent\" in obj) {\n          obj.parent = null;\n        }\n      }\n      cache.splice(index, 1);\n\n      // remove it from the jCal\n      this.jCal[jCalIndex].splice(index, 1);\n    },\n    _removeObject: function (jCalIndex, cache, nameOrObject) {\n      var i = 0;\n      var objects = this.jCal[jCalIndex];\n      var len = objects.length;\n      var cached = this[cache];\n      if (typeof nameOrObject === 'string') {\n        for (; i < len; i++) {\n          if (objects[i][NAME_INDEX] === nameOrObject) {\n            this._removeObjectByIndex(jCalIndex, cached, i);\n            return true;\n          }\n        }\n      } else if (cached) {\n        for (; i < len; i++) {\n          if (cached[i] && cached[i] === nameOrObject) {\n            this._removeObjectByIndex(jCalIndex, cached, i);\n            return true;\n          }\n        }\n      }\n      return false;\n    },\n    _removeAllObjects: function (jCalIndex, cache, name) {\n      var cached = this[cache];\n\n      // Unfortunately we have to run through all children to reset their\n      // parent property.\n      var objects = this.jCal[jCalIndex];\n      var i = objects.length - 1;\n\n      // descending search required because splice\n      // is used and will effect the indices.\n      for (; i >= 0; i--) {\n        if (!name || objects[i][NAME_INDEX] === name) {\n          this._removeObjectByIndex(jCalIndex, cached, i);\n        }\n      }\n    },\n    /**\n     * Adds a single sub component.\n     *\n     * @param {ICAL.Component} component        The component to add\n     * @return {ICAL.Component}                 The passed in component\n     */\n    addSubcomponent: function (component) {\n      if (!this._components) {\n        this._components = [];\n        this._hydratedComponentCount = 0;\n      }\n      if (component.parent) {\n        component.parent.removeSubcomponent(component);\n      }\n      var idx = this.jCal[COMPONENT_INDEX].push(component.jCal);\n      this._components[idx - 1] = component;\n      this._hydratedComponentCount++;\n      component.parent = this;\n      return component;\n    },\n    /**\n     * Removes a single component by name or the instance of a specific\n     * component.\n     *\n     * @param {ICAL.Component|String} nameOrComp    Name of component, or component\n     * @return {Boolean}                            True when comp is removed\n     */\n    removeSubcomponent: function (nameOrComp) {\n      var removed = this._removeObject(COMPONENT_INDEX, '_components', nameOrComp);\n      if (removed) {\n        this._hydratedComponentCount--;\n      }\n      return removed;\n    },\n    /**\n     * Removes all components or (if given) all components by a particular\n     * name.\n     *\n     * @param {String=} name            Lowercase component name\n     */\n    removeAllSubcomponents: function (name) {\n      var removed = this._removeAllObjects(COMPONENT_INDEX, '_components', name);\n      this._hydratedComponentCount = 0;\n      return removed;\n    },\n    /**\n     * Adds an {@link ICAL.Property} to the component.\n     *\n     * @param {ICAL.Property} property      The property to add\n     * @return {ICAL.Property}              The passed in property\n     */\n    addProperty: function (property) {\n      if (!(property instanceof ICAL.Property)) {\n        throw new TypeError('must instance of ICAL.Property');\n      }\n      if (!this._properties) {\n        this._properties = [];\n        this._hydratedPropertyCount = 0;\n      }\n      if (property.parent) {\n        property.parent.removeProperty(property);\n      }\n      var idx = this.jCal[PROPERTY_INDEX].push(property.jCal);\n      this._properties[idx - 1] = property;\n      this._hydratedPropertyCount++;\n      property.parent = this;\n      return property;\n    },\n    /**\n     * Helper method to add a property with a value to the component.\n     *\n     * @param {String}               name         Property name to add\n     * @param {String|Number|Object} value        Property value\n     * @return {ICAL.Property}                    The created property\n     */\n    addPropertyWithValue: function (name, value) {\n      var prop = new ICAL.Property(name);\n      prop.setValue(value);\n      this.addProperty(prop);\n      return prop;\n    },\n    /**\n     * Helper method that will update or create a property of the given name\n     * and sets its value. If multiple properties with the given name exist,\n     * only the first is updated.\n     *\n     * @param {String}               name         Property name to update\n     * @param {String|Number|Object} value        Property value\n     * @return {ICAL.Property}                    The created property\n     */\n    updatePropertyWithValue: function (name, value) {\n      var prop = this.getFirstProperty(name);\n      if (prop) {\n        prop.setValue(value);\n      } else {\n        prop = this.addPropertyWithValue(name, value);\n      }\n      return prop;\n    },\n    /**\n     * Removes a single property by name or the instance of the specific\n     * property.\n     *\n     * @param {String|ICAL.Property} nameOrProp     Property name or instance to remove\n     * @return {Boolean}                            True, when deleted\n     */\n    removeProperty: function (nameOrProp) {\n      var removed = this._removeObject(PROPERTY_INDEX, '_properties', nameOrProp);\n      if (removed) {\n        this._hydratedPropertyCount--;\n      }\n      return removed;\n    },\n    /**\n     * Removes all properties associated with this component, optionally\n     * filtered by name.\n     *\n     * @param {String=} name        Lowercase property name\n     * @return {Boolean}            True, when deleted\n     */\n    removeAllProperties: function (name) {\n      var removed = this._removeAllObjects(PROPERTY_INDEX, '_properties', name);\n      this._hydratedPropertyCount = 0;\n      return removed;\n    },\n    /**\n     * Returns the Object representation of this component. The returned object\n     * is a live jCal object and should be cloned if modified.\n     * @return {Object}\n     */\n    toJSON: function () {\n      return this.jCal;\n    },\n    /**\n     * The string representation of this component.\n     * @return {String}\n     */\n    toString: function () {\n      return ICAL.stringify.component(this.jCal, this._designSet);\n    }\n  };\n\n  /**\n   * Create an {@link ICAL.Component} by parsing the passed iCalendar string.\n   *\n   * @param {String} str        The iCalendar string to parse\n   */\n  Component.fromString = function (str) {\n    return new Component(ICAL.parse.component(str));\n  };\n  return Component;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.Property = function () {\n  'use strict';\n\n  var NAME_INDEX = 0;\n  var PROP_INDEX = 1;\n  var TYPE_INDEX = 2;\n  var VALUE_INDEX = 3;\n  var design = ICAL.design;\n\n  /**\n   * @classdesc\n   * Provides a layer on top of the raw jCal object for manipulating a single\n   * property, with its parameters and value.\n   *\n   * @description\n   * It is important to note that mutations done in the wrapper\n   * directly mutate the jCal object used to initialize.\n   *\n   * Can also be used to create new properties by passing\n   * the name of the property (as a String).\n   *\n   * @class\n   * @alias ICAL.Property\n   * @param {Array|String} jCal         Raw jCal representation OR\n   *  the new name of the property\n   *\n   * @param {ICAL.Component=} parent    Parent component\n   */\n  function Property(jCal, parent) {\n    this._parent = parent || null;\n    if (typeof jCal === 'string') {\n      // We are creating the property by name and need to detect the type\n      this.jCal = [jCal, {}, design.defaultType];\n      this.jCal[TYPE_INDEX] = this.getDefaultType();\n    } else {\n      this.jCal = jCal;\n    }\n    this._updateType();\n  }\n  Property.prototype = {\n    /**\n     * The value type for this property\n     * @readonly\n     * @type {String}\n     */\n    get type() {\n      return this.jCal[TYPE_INDEX];\n    },\n    /**\n     * The name of this property, in lowercase.\n     * @readonly\n     * @type {String}\n     */\n    get name() {\n      return this.jCal[NAME_INDEX];\n    },\n    /**\n     * The parent component for this property.\n     * @type {ICAL.Component}\n     */\n    get parent() {\n      return this._parent;\n    },\n    set parent(p) {\n      // Before setting the parent, check if the design set has changed. If it\n      // has, we later need to update the type if it was unknown before.\n      var designSetChanged = !this._parent || p && p._designSet != this._parent._designSet;\n      this._parent = p;\n      if (this.type == design.defaultType && designSetChanged) {\n        this.jCal[TYPE_INDEX] = this.getDefaultType();\n        this._updateType();\n      }\n      return p;\n    },\n    /**\n     * The design set for this property, e.g. icalendar vs vcard\n     *\n     * @type {ICAL.design.designSet}\n     * @private\n     */\n    get _designSet() {\n      return this.parent ? this.parent._designSet : design.defaultSet;\n    },\n    /**\n     * Updates the type metadata from the current jCal type and design set.\n     *\n     * @private\n     */\n    _updateType: function () {\n      var designSet = this._designSet;\n      if (this.type in designSet.value) {\n        var designType = designSet.value[this.type];\n        if ('decorate' in designSet.value[this.type]) {\n          this.isDecorated = true;\n        } else {\n          this.isDecorated = false;\n        }\n        if (this.name in designSet.property) {\n          this.isMultiValue = 'multiValue' in designSet.property[this.name];\n          this.isStructuredValue = 'structuredValue' in designSet.property[this.name];\n        }\n      }\n    },\n    /**\n     * Hydrate a single value. The act of hydrating means turning the raw jCal\n     * value into a potentially wrapped object, for example {@link ICAL.Time}.\n     *\n     * @private\n     * @param {Number} index        The index of the value to hydrate\n     * @return {Object}             The decorated value.\n     */\n    _hydrateValue: function (index) {\n      if (this._values && this._values[index]) {\n        return this._values[index];\n      }\n\n      // for the case where there is no value.\n      if (this.jCal.length <= VALUE_INDEX + index) {\n        return null;\n      }\n      if (this.isDecorated) {\n        if (!this._values) {\n          this._values = [];\n        }\n        return this._values[index] = this._decorate(this.jCal[VALUE_INDEX + index]);\n      } else {\n        return this.jCal[VALUE_INDEX + index];\n      }\n    },\n    /**\n     * Decorate a single value, returning its wrapped object. This is used by\n     * the hydrate function to actually wrap the value.\n     *\n     * @private\n     * @param {?} value         The value to decorate\n     * @return {Object}         The decorated value\n     */\n    _decorate: function (value) {\n      return this._designSet.value[this.type].decorate(value, this);\n    },\n    /**\n     * Undecorate a single value, returning its raw jCal data.\n     *\n     * @private\n     * @param {Object} value         The value to undecorate\n     * @return {?}                   The undecorated value\n     */\n    _undecorate: function (value) {\n      return this._designSet.value[this.type].undecorate(value, this);\n    },\n    /**\n     * Sets the value at the given index while also hydrating it. The passed\n     * value can either be a decorated or undecorated value.\n     *\n     * @private\n     * @param {?} value             The value to set\n     * @param {Number} index        The index to set it at\n     */\n    _setDecoratedValue: function (value, index) {\n      if (!this._values) {\n        this._values = [];\n      }\n      if (typeof value === 'object' && 'icaltype' in value) {\n        // decorated value\n        this.jCal[VALUE_INDEX + index] = this._undecorate(value);\n        this._values[index] = value;\n      } else {\n        // undecorated value\n        this.jCal[VALUE_INDEX + index] = value;\n        this._values[index] = this._decorate(value);\n      }\n    },\n    /**\n     * Gets a parameter on the property.\n     *\n     * @param {String}        name   Parameter name (lowercase)\n     * @return {Array|String}        Parameter value\n     */\n    getParameter: function (name) {\n      if (name in this.jCal[PROP_INDEX]) {\n        return this.jCal[PROP_INDEX][name];\n      } else {\n        return undefined;\n      }\n    },\n    /**\n     * Gets first parameter on the property.\n     *\n     * @param {String}        name   Parameter name (lowercase)\n     * @return {String}        Parameter value\n     */\n    getFirstParameter: function (name) {\n      var parameters = this.getParameter(name);\n      if (Array.isArray(parameters)) {\n        return parameters[0];\n      }\n      return parameters;\n    },\n    /**\n     * Sets a parameter on the property.\n     *\n     * @param {String}       name     The parameter name\n     * @param {Array|String} value    The parameter value\n     */\n    setParameter: function (name, value) {\n      var lcname = name.toLowerCase();\n      if (typeof value === \"string\" && lcname in this._designSet.param && 'multiValue' in this._designSet.param[lcname]) {\n        value = [value];\n      }\n      this.jCal[PROP_INDEX][name] = value;\n    },\n    /**\n     * Removes a parameter\n     *\n     * @param {String} name     The parameter name\n     */\n    removeParameter: function (name) {\n      delete this.jCal[PROP_INDEX][name];\n    },\n    /**\n     * Get the default type based on this property's name.\n     *\n     * @return {String}     The default type for this property\n     */\n    getDefaultType: function () {\n      var name = this.jCal[NAME_INDEX];\n      var designSet = this._designSet;\n      if (name in designSet.property) {\n        var details = designSet.property[name];\n        if ('defaultType' in details) {\n          return details.defaultType;\n        }\n      }\n      return design.defaultType;\n    },\n    /**\n     * Sets type of property and clears out any existing values of the current\n     * type.\n     *\n     * @param {String} type     New iCAL type (see design.*.values)\n     */\n    resetType: function (type) {\n      this.removeAllValues();\n      this.jCal[TYPE_INDEX] = type;\n      this._updateType();\n    },\n    /**\n     * Finds the first property value.\n     *\n     * @return {String}         First property value\n     */\n    getFirstValue: function () {\n      return this._hydrateValue(0);\n    },\n    /**\n     * Gets all values on the property.\n     *\n     * NOTE: this creates an array during each call.\n     *\n     * @return {Array}          List of values\n     */\n    getValues: function () {\n      var len = this.jCal.length - VALUE_INDEX;\n      if (len < 1) {\n        // it is possible for a property to have no value.\n        return [];\n      }\n      var i = 0;\n      var result = [];\n      for (; i < len; i++) {\n        result[i] = this._hydrateValue(i);\n      }\n      return result;\n    },\n    /**\n     * Removes all values from this property\n     */\n    removeAllValues: function () {\n      if (this._values) {\n        this._values.length = 0;\n      }\n      this.jCal.length = 3;\n    },\n    /**\n     * Sets the values of the property.  Will overwrite the existing values.\n     * This can only be used for multi-value properties.\n     *\n     * @param {Array} values    An array of values\n     */\n    setValues: function (values) {\n      if (!this.isMultiValue) {\n        throw new Error(this.name + ': does not not support mulitValue.\\n' + 'override isMultiValue');\n      }\n      var len = values.length;\n      var i = 0;\n      this.removeAllValues();\n      if (len > 0 && typeof values[0] === 'object' && 'icaltype' in values[0]) {\n        this.resetType(values[0].icaltype);\n      }\n      if (this.isDecorated) {\n        for (; i < len; i++) {\n          this._setDecoratedValue(values[i], i);\n        }\n      } else {\n        for (; i < len; i++) {\n          this.jCal[VALUE_INDEX + i] = values[i];\n        }\n      }\n    },\n    /**\n     * Sets the current value of the property. If this is a multi-value\n     * property, all other values will be removed.\n     *\n     * @param {String|Object} value     New property value.\n     */\n    setValue: function (value) {\n      this.removeAllValues();\n      if (typeof value === 'object' && 'icaltype' in value) {\n        this.resetType(value.icaltype);\n      }\n      if (this.isDecorated) {\n        this._setDecoratedValue(value, 0);\n      } else {\n        this.jCal[VALUE_INDEX] = value;\n      }\n    },\n    /**\n     * Returns the Object representation of this component. The returned object\n     * is a live jCal object and should be cloned if modified.\n     * @return {Object}\n     */\n    toJSON: function () {\n      return this.jCal;\n    },\n    /**\n     * The string representation of this component.\n     * @return {String}\n     */\n    toICALString: function () {\n      return ICAL.stringify.property(this.jCal, this._designSet, true);\n    }\n  };\n\n  /**\n   * Create an {@link ICAL.Property} by parsing the passed iCalendar string.\n   *\n   * @param {String} str                        The iCalendar string to parse\n   * @param {ICAL.design.designSet=} designSet  The design data to use for this property\n   * @return {ICAL.Property}                    The created iCalendar property\n   */\n  Property.fromString = function (str, designSet) {\n    return new Property(ICAL.parse.property(str, designSet));\n  };\n  return Property;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.UtcOffset = function () {\n  /**\n   * @classdesc\n   * This class represents the \"duration\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @class\n   * @alias ICAL.UtcOffset\n   * @param {Object} aData          An object with members of the utc offset\n   * @param {Number=} aData.hours   The hours for the utc offset\n   * @param {Number=} aData.minutes The minutes in the utc offset\n   * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1\n   */\n  function UtcOffset(aData) {\n    this.fromData(aData);\n  }\n  UtcOffset.prototype = {\n    /**\n     * The hours in the utc-offset\n     * @type {Number}\n     */\n    hours: 0,\n    /**\n     * The minutes in the utc-offset\n     * @type {Number}\n     */\n    minutes: 0,\n    /**\n     * The sign of the utc offset, 1 for positive offset, -1 for negative\n     * offsets.\n     * @type {Number}\n     */\n    factor: 1,\n    /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"utc-offset\"\n     */\n    icaltype: \"utc-offset\",\n    /**\n     * Returns a clone of the utc offset object.\n     *\n     * @return {ICAL.UtcOffset}     The cloned object\n     */\n    clone: function () {\n      return ICAL.UtcOffset.fromSeconds(this.toSeconds());\n    },\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} aData          An object with members of the utc offset\n     * @param {Number=} aData.hours   The hours for the utc offset\n     * @param {Number=} aData.minutes The minutes in the utc offset\n     * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1\n     */\n    fromData: function (aData) {\n      if (aData) {\n        for (var key in aData) {\n          /* istanbul ignore else */\n          if (aData.hasOwnProperty(key)) {\n            this[key] = aData[key];\n          }\n        }\n      }\n      this._normalize();\n    },\n    /**\n     * Sets up the current instance from the given seconds value. The seconds\n     * value is truncated to the minute. Offsets are wrapped when the world\n     * ends, the hour after UTC+14:00 is UTC-12:00.\n     *\n     * @param {Number} aSeconds         The seconds to convert into an offset\n     */\n    fromSeconds: function (aSeconds) {\n      var secs = Math.abs(aSeconds);\n      this.factor = aSeconds < 0 ? -1 : 1;\n      this.hours = ICAL.helpers.trunc(secs / 3600);\n      secs -= this.hours * 3600;\n      this.minutes = ICAL.helpers.trunc(secs / 60);\n      return this;\n    },\n    /**\n     * Convert the current offset to a value in seconds\n     *\n     * @return {Number}                 The offset in seconds\n     */\n    toSeconds: function () {\n      return this.factor * (60 * this.minutes + 3600 * this.hours);\n    },\n    /**\n     * Compare this utc offset with another one.\n     *\n     * @param {ICAL.UtcOffset} other        The other offset to compare with\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */\n    compare: function icaltime_compare(other) {\n      var a = this.toSeconds();\n      var b = other.toSeconds();\n      return (a > b) - (b > a);\n    },\n    _normalize: function () {\n      // Range: 97200 seconds (with 1 hour inbetween)\n      var secs = this.toSeconds();\n      var factor = this.factor;\n      while (secs < -43200) {\n        // = UTC-12:00\n        secs += 97200;\n      }\n      while (secs > 50400) {\n        // = UTC+14:00\n        secs -= 97200;\n      }\n      this.fromSeconds(secs);\n\n      // Avoid changing the factor when on zero seconds\n      if (secs == 0) {\n        this.factor = factor;\n      }\n    },\n    /**\n     * The iCalendar string representation of this utc-offset.\n     * @return {String}\n     */\n    toICALString: function () {\n      return ICAL.design.icalendar.value['utc-offset'].toICAL(this.toString());\n    },\n    /**\n     * The string representation of this utc-offset.\n     * @return {String}\n     */\n    toString: function toString() {\n      return (this.factor == 1 ? \"+\" : \"-\") + ICAL.helpers.pad2(this.hours) + ':' + ICAL.helpers.pad2(this.minutes);\n    }\n  };\n\n  /**\n   * Creates a new {@link ICAL.UtcOffset} instance from the passed string.\n   *\n   * @param {String} aString    The string to parse\n   * @return {ICAL.Duration}    The created utc-offset instance\n   */\n  UtcOffset.fromString = function (aString) {\n    // -05:00\n    var options = {};\n    //TODO: support seconds per rfc5545 ?\n    options.factor = aString[0] === '+' ? 1 : -1;\n    options.hours = ICAL.helpers.strictParseInt(aString.substr(1, 2));\n    options.minutes = ICAL.helpers.strictParseInt(aString.substr(4, 2));\n    return new ICAL.UtcOffset(options);\n  };\n\n  /**\n   * Creates a new {@link ICAL.UtcOffset} instance from the passed seconds\n   * value.\n   *\n   * @param {Number} aSeconds       The number of seconds to convert\n   */\n  UtcOffset.fromSeconds = function (aSeconds) {\n    var instance = new UtcOffset();\n    instance.fromSeconds(aSeconds);\n    return instance;\n  };\n  return UtcOffset;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.Binary = function () {\n  /**\n   * @classdesc\n   * Represents the BINARY value type, which contains extra methods for\n   * encoding and decoding.\n   *\n   * @class\n   * @alias ICAL.Binary\n   * @param {String} aValue     The binary data for this value\n   */\n  function Binary(aValue) {\n    this.value = aValue;\n  }\n  Binary.prototype = {\n    /**\n     * The type name, to be used in the jCal object.\n     * @default \"binary\"\n     * @constant\n     */\n    icaltype: \"binary\",\n    /**\n     * Base64 decode the current value\n     *\n     * @return {String}         The base64-decoded value\n     */\n    decodeValue: function decodeValue() {\n      return this._b64_decode(this.value);\n    },\n    /**\n     * Encodes the passed parameter with base64 and sets the internal\n     * value to the result.\n     *\n     * @param {String} aValue      The raw binary value to encode\n     */\n    setEncodedValue: function setEncodedValue(aValue) {\n      this.value = this._b64_encode(aValue);\n    },\n    _b64_encode: function base64_encode(data) {\n      // http://kevin.vanzonneveld.net\n      // +   original by: Tyler Akins (http://rumkin.com)\n      // +   improved by: Bayron Guevara\n      // +   improved by: Thunder.m\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +   bugfixed by: Pellentesque Malesuada\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +   improved by: Rafał Kukawski (http://kukawski.pl)\n      // *     example 1: base64_encode('Kevin van Zonneveld');\n      // *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='\n      // mozilla has this native\n      // - but breaks in 2.0.0.12!\n      //if (typeof this.window['atob'] == 'function') {\n      //    return atob(data);\n      //}\n      var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" + \"abcdefghijklmnopqrstuvwxyz0123456789+/=\";\n      var o1,\n        o2,\n        o3,\n        h1,\n        h2,\n        h3,\n        h4,\n        bits,\n        i = 0,\n        ac = 0,\n        enc = \"\",\n        tmp_arr = [];\n      if (!data) {\n        return data;\n      }\n      do {\n        // pack three octets into four hexets\n        o1 = data.charCodeAt(i++);\n        o2 = data.charCodeAt(i++);\n        o3 = data.charCodeAt(i++);\n        bits = o1 << 16 | o2 << 8 | o3;\n        h1 = bits >> 18 & 0x3f;\n        h2 = bits >> 12 & 0x3f;\n        h3 = bits >> 6 & 0x3f;\n        h4 = bits & 0x3f;\n\n        // use hexets to index into b64, and append result to encoded string\n        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);\n      } while (i < data.length);\n      enc = tmp_arr.join('');\n      var r = data.length % 3;\n      return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);\n    },\n    _b64_decode: function base64_decode(data) {\n      // http://kevin.vanzonneveld.net\n      // +   original by: Tyler Akins (http://rumkin.com)\n      // +   improved by: Thunder.m\n      // +      input by: Aman Gupta\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +   bugfixed by: Onno Marsman\n      // +   bugfixed by: Pellentesque Malesuada\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +      input by: Brett Zamir (http://brett-zamir.me)\n      // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // *     example 1: base64_decode('S2V2aW4gdmFuIFpvbm5ldmVsZA==');\n      // *     returns 1: 'Kevin van Zonneveld'\n      // mozilla has this native\n      // - but breaks in 2.0.0.12!\n      //if (typeof this.window['btoa'] == 'function') {\n      //    return btoa(data);\n      //}\n      var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" + \"abcdefghijklmnopqrstuvwxyz0123456789+/=\";\n      var o1,\n        o2,\n        o3,\n        h1,\n        h2,\n        h3,\n        h4,\n        bits,\n        i = 0,\n        ac = 0,\n        dec = \"\",\n        tmp_arr = [];\n      if (!data) {\n        return data;\n      }\n      data += '';\n      do {\n        // unpack four hexets into three octets using index points in b64\n        h1 = b64.indexOf(data.charAt(i++));\n        h2 = b64.indexOf(data.charAt(i++));\n        h3 = b64.indexOf(data.charAt(i++));\n        h4 = b64.indexOf(data.charAt(i++));\n        bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;\n        o1 = bits >> 16 & 0xff;\n        o2 = bits >> 8 & 0xff;\n        o3 = bits & 0xff;\n        if (h3 == 64) {\n          tmp_arr[ac++] = String.fromCharCode(o1);\n        } else if (h4 == 64) {\n          tmp_arr[ac++] = String.fromCharCode(o1, o2);\n        } else {\n          tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);\n        }\n      } while (i < data.length);\n      dec = tmp_arr.join('');\n      return dec;\n    },\n    /**\n     * The string representation of this value\n     * @return {String}\n     */\n    toString: function () {\n      return this.value;\n    }\n  };\n\n  /**\n   * Creates a binary value from the given string.\n   *\n   * @param {String} aString        The binary value string\n   * @return {ICAL.Binary}          The binary value instance\n   */\n  Binary.fromString = function (aString) {\n    return new Binary(aString);\n  };\n  return Binary;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n(function () {\n  /**\n   * @classdesc\n   * This class represents the \"period\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @description\n   * The passed data object cannot contain both and end date and a duration.\n   *\n   * @class\n   * @param {Object} aData                  An object with members of the period\n   * @param {ICAL.Time=} aData.start        The start of the period\n   * @param {ICAL.Time=} aData.end          The end of the period\n   * @param {ICAL.Duration=} aData.duration The duration of the period\n   */\n  ICAL.Period = function icalperiod(aData) {\n    this.wrappedJSObject = this;\n    if (aData && 'start' in aData) {\n      if (aData.start && !(aData.start instanceof ICAL.Time)) {\n        throw new TypeError('.start must be an instance of ICAL.Time');\n      }\n      this.start = aData.start;\n    }\n    if (aData && aData.end && aData.duration) {\n      throw new Error('cannot accept both end and duration');\n    }\n    if (aData && 'end' in aData) {\n      if (aData.end && !(aData.end instanceof ICAL.Time)) {\n        throw new TypeError('.end must be an instance of ICAL.Time');\n      }\n      this.end = aData.end;\n    }\n    if (aData && 'duration' in aData) {\n      if (aData.duration && !(aData.duration instanceof ICAL.Duration)) {\n        throw new TypeError('.duration must be an instance of ICAL.Duration');\n      }\n      this.duration = aData.duration;\n    }\n  };\n  ICAL.Period.prototype = {\n    /**\n     * The start of the period\n     * @type {ICAL.Time}\n     */\n    start: null,\n    /**\n     * The end of the period\n     * @type {ICAL.Time}\n     */\n    end: null,\n    /**\n     * The duration of the period\n     * @type {ICAL.Duration}\n     */\n    duration: null,\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icalperiod\"\n     */\n    icalclass: \"icalperiod\",\n    /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"period\"\n     */\n    icaltype: \"period\",\n    /**\n     * Returns a clone of the duration object.\n     *\n     * @return {ICAL.Period}      The cloned object\n     */\n    clone: function () {\n      return ICAL.Period.fromData({\n        start: this.start ? this.start.clone() : null,\n        end: this.end ? this.end.clone() : null,\n        duration: this.duration ? this.duration.clone() : null\n      });\n    },\n    /**\n     * Calculates the duration of the period, either directly or by subtracting\n     * start from end date.\n     *\n     * @return {ICAL.Duration}      The calculated duration\n     */\n    getDuration: function duration() {\n      if (this.duration) {\n        return this.duration;\n      } else {\n        return this.end.subtractDate(this.start);\n      }\n    },\n    /**\n     * Calculates the end date of the period, either directly or by adding\n     * duration to start date.\n     *\n     * @return {ICAL.Time}          The calculated end date\n     */\n    getEnd: function () {\n      if (this.end) {\n        return this.end;\n      } else {\n        var end = this.start.clone();\n        end.addDuration(this.duration);\n        return end;\n      }\n    },\n    /**\n     * The string representation of this period.\n     * @return {String}\n     */\n    toString: function toString() {\n      return this.start + \"/\" + (this.end || this.duration);\n    },\n    /**\n     * The jCal representation of this period type.\n     * @return {Object}\n     */\n    toJSON: function () {\n      return [this.start.toString(), (this.end || this.duration).toString()];\n    },\n    /**\n     * The iCalendar string representation of this period.\n     * @return {String}\n     */\n    toICALString: function () {\n      return this.start.toICALString() + \"/\" + (this.end || this.duration).toICALString();\n    }\n  };\n\n  /**\n   * Creates a new {@link ICAL.Period} instance from the passed string.\n   *\n   * @param {String} str            The string to parse\n   * @param {ICAL.Property} prop    The property this period will be on\n   * @return {ICAL.Period}          The created period instance\n   */\n  ICAL.Period.fromString = function fromString(str, prop) {\n    var parts = str.split('/');\n    if (parts.length !== 2) {\n      throw new Error('Invalid string value: \"' + str + '\" must contain a \"/\" char.');\n    }\n    var options = {\n      start: ICAL.Time.fromDateTimeString(parts[0], prop)\n    };\n    var end = parts[1];\n    if (ICAL.Duration.isValueString(end)) {\n      options.duration = ICAL.Duration.fromString(end);\n    } else {\n      options.end = ICAL.Time.fromDateTimeString(end, prop);\n    }\n    return new ICAL.Period(options);\n  };\n\n  /**\n   * Creates a new {@link ICAL.Period} instance from the given data object.\n   * The passed data object cannot contain both and end date and a duration.\n   *\n   * @param {Object} aData                  An object with members of the period\n   * @param {ICAL.Time=} aData.start        The start of the period\n   * @param {ICAL.Time=} aData.end          The end of the period\n   * @param {ICAL.Duration=} aData.duration The duration of the period\n   * @return {ICAL.Period}                  The period instance\n   */\n  ICAL.Period.fromData = function fromData(aData) {\n    return new ICAL.Period(aData);\n  };\n\n  /**\n   * Returns a new period instance from the given jCal data array. The first\n   * member is always the start date string, the second member is either a\n   * duration or end date string.\n   *\n   * @param {Array<String,String>} aData    The jCal data array\n   * @param {ICAL.Property} aProp           The property this jCal data is on\n   * @param {Boolean} aLenient              If true, data value can be both date and date-time\n   * @return {ICAL.Period}                  The period instance\n   */\n  ICAL.Period.fromJSON = function (aData, aProp, aLenient) {\n    function fromDateOrDateTimeString(aValue, aProp) {\n      if (aLenient) {\n        return ICAL.Time.fromString(aValue, aProp);\n      } else {\n        return ICAL.Time.fromDateTimeString(aValue, aProp);\n      }\n    }\n    if (ICAL.Duration.isValueString(aData[1])) {\n      return ICAL.Period.fromData({\n        start: fromDateOrDateTimeString(aData[0], aProp),\n        duration: ICAL.Duration.fromString(aData[1])\n      });\n    } else {\n      return ICAL.Period.fromData({\n        start: fromDateOrDateTimeString(aData[0], aProp),\n        end: fromDateOrDateTimeString(aData[1], aProp)\n      });\n    }\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n(function () {\n  var DURATION_LETTERS = /([PDWHMTS]{1,1})/;\n\n  /**\n   * @classdesc\n   * This class represents the \"duration\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @class\n   * @alias ICAL.Duration\n   * @param {Object} data               An object with members of the duration\n   * @param {Number} data.weeks         Duration in weeks\n   * @param {Number} data.days          Duration in days\n   * @param {Number} data.hours         Duration in hours\n   * @param {Number} data.minutes       Duration in minutes\n   * @param {Number} data.seconds       Duration in seconds\n   * @param {Boolean} data.isNegative   If true, the duration is negative\n   */\n  ICAL.Duration = function icalduration(data) {\n    this.wrappedJSObject = this;\n    this.fromData(data);\n  };\n  ICAL.Duration.prototype = {\n    /**\n     * The weeks in this duration\n     * @type {Number}\n     * @default 0\n     */\n    weeks: 0,\n    /**\n     * The days in this duration\n     * @type {Number}\n     * @default 0\n     */\n    days: 0,\n    /**\n     * The days in this duration\n     * @type {Number}\n     * @default 0\n     */\n    hours: 0,\n    /**\n     * The minutes in this duration\n     * @type {Number}\n     * @default 0\n     */\n    minutes: 0,\n    /**\n     * The seconds in this duration\n     * @type {Number}\n     * @default 0\n     */\n    seconds: 0,\n    /**\n     * The seconds in this duration\n     * @type {Boolean}\n     * @default false\n     */\n    isNegative: false,\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icalduration\"\n     */\n    icalclass: \"icalduration\",\n    /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"duration\"\n     */\n    icaltype: \"duration\",\n    /**\n     * Returns a clone of the duration object.\n     *\n     * @return {ICAL.Duration}      The cloned object\n     */\n    clone: function clone() {\n      return ICAL.Duration.fromData(this);\n    },\n    /**\n     * The duration value expressed as a number of seconds.\n     *\n     * @return {Number}             The duration value in seconds\n     */\n    toSeconds: function toSeconds() {\n      var seconds = this.seconds + 60 * this.minutes + 3600 * this.hours + 86400 * this.days + 7 * 86400 * this.weeks;\n      return this.isNegative ? -seconds : seconds;\n    },\n    /**\n     * Reads the passed seconds value into this duration object. Afterwards,\n     * members like {@link ICAL.Duration#days days} and {@link ICAL.Duration#weeks weeks} will be set up\n     * accordingly.\n     *\n     * @param {Number} aSeconds     The duration value in seconds\n     * @return {ICAL.Duration}      Returns this instance\n     */\n    fromSeconds: function fromSeconds(aSeconds) {\n      var secs = Math.abs(aSeconds);\n      this.isNegative = aSeconds < 0;\n      this.days = ICAL.helpers.trunc(secs / 86400);\n\n      // If we have a flat number of weeks, use them.\n      if (this.days % 7 == 0) {\n        this.weeks = this.days / 7;\n        this.days = 0;\n      } else {\n        this.weeks = 0;\n      }\n      secs -= (this.days + 7 * this.weeks) * 86400;\n      this.hours = ICAL.helpers.trunc(secs / 3600);\n      secs -= this.hours * 3600;\n      this.minutes = ICAL.helpers.trunc(secs / 60);\n      secs -= this.minutes * 60;\n      this.seconds = secs;\n      return this;\n    },\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} aData               An object with members of the duration\n     * @param {Number} aData.weeks         Duration in weeks\n     * @param {Number} aData.days          Duration in days\n     * @param {Number} aData.hours         Duration in hours\n     * @param {Number} aData.minutes       Duration in minutes\n     * @param {Number} aData.seconds       Duration in seconds\n     * @param {Boolean} aData.isNegative   If true, the duration is negative\n     */\n    fromData: function fromData(aData) {\n      var propsToCopy = [\"weeks\", \"days\", \"hours\", \"minutes\", \"seconds\", \"isNegative\"];\n      for (var key in propsToCopy) {\n        /* istanbul ignore if */\n        if (!propsToCopy.hasOwnProperty(key)) {\n          continue;\n        }\n        var prop = propsToCopy[key];\n        if (aData && prop in aData) {\n          this[prop] = aData[prop];\n        } else {\n          this[prop] = 0;\n        }\n      }\n    },\n    /**\n     * Resets the duration instance to the default values, i.e. PT0S\n     */\n    reset: function reset() {\n      this.isNegative = false;\n      this.weeks = 0;\n      this.days = 0;\n      this.hours = 0;\n      this.minutes = 0;\n      this.seconds = 0;\n    },\n    /**\n     * Compares the duration instance with another one.\n     *\n     * @param {ICAL.Duration} aOther        The instance to compare with\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */\n    compare: function compare(aOther) {\n      var thisSeconds = this.toSeconds();\n      var otherSeconds = aOther.toSeconds();\n      return (thisSeconds > otherSeconds) - (thisSeconds < otherSeconds);\n    },\n    /**\n     * Normalizes the duration instance. For example, a duration with a value\n     * of 61 seconds will be normalized to 1 minute and 1 second.\n     */\n    normalize: function normalize() {\n      this.fromSeconds(this.toSeconds());\n    },\n    /**\n     * The string representation of this duration.\n     * @return {String}\n     */\n    toString: function toString() {\n      if (this.toSeconds() == 0) {\n        return \"PT0S\";\n      } else {\n        var str = \"\";\n        if (this.isNegative) str += \"-\";\n        str += \"P\";\n        if (this.weeks) str += this.weeks + \"W\";\n        if (this.days) str += this.days + \"D\";\n        if (this.hours || this.minutes || this.seconds) {\n          str += \"T\";\n          if (this.hours) str += this.hours + \"H\";\n          if (this.minutes) str += this.minutes + \"M\";\n          if (this.seconds) str += this.seconds + \"S\";\n        }\n        return str;\n      }\n    },\n    /**\n     * The iCalendar string representation of this duration.\n     * @return {String}\n     */\n    toICALString: function () {\n      return this.toString();\n    }\n  };\n\n  /**\n   * Returns a new ICAL.Duration instance from the passed seconds value.\n   *\n   * @param {Number} aSeconds       The seconds to create the instance from\n   * @return {ICAL.Duration}        The newly created duration instance\n   */\n  ICAL.Duration.fromSeconds = function icalduration_from_seconds(aSeconds) {\n    return new ICAL.Duration().fromSeconds(aSeconds);\n  };\n\n  /**\n   * Internal helper function to handle a chunk of a duration.\n   *\n   * @param {String} letter type of duration chunk\n   * @param {String} number numeric value or -/+\n   * @param {Object} dict target to assign values to\n   */\n  function parseDurationChunk(letter, number, object) {\n    var type;\n    switch (letter) {\n      case 'P':\n        if (number && number === '-') {\n          object.isNegative = true;\n        } else {\n          object.isNegative = false;\n        }\n        // period\n        break;\n      case 'D':\n        type = 'days';\n        break;\n      case 'W':\n        type = 'weeks';\n        break;\n      case 'H':\n        type = 'hours';\n        break;\n      case 'M':\n        type = 'minutes';\n        break;\n      case 'S':\n        type = 'seconds';\n        break;\n      default:\n        // Not a valid chunk\n        return 0;\n    }\n    if (type) {\n      if (!number && number !== 0) {\n        throw new Error('invalid duration value: Missing number before \"' + letter + '\"');\n      }\n      var num = parseInt(number, 10);\n      if (ICAL.helpers.isStrictlyNaN(num)) {\n        throw new Error('invalid duration value: Invalid number \"' + number + '\" before \"' + letter + '\"');\n      }\n      object[type] = num;\n    }\n    return 1;\n  }\n\n  /**\n   * Checks if the given string is an iCalendar duration value.\n   *\n   * @param {String} value      The raw ical value\n   * @return {Boolean}          True, if the given value is of the\n   *                              duration ical type\n   */\n  ICAL.Duration.isValueString = function (string) {\n    return string[0] === 'P' || string[1] === 'P';\n  };\n\n  /**\n   * Creates a new {@link ICAL.Duration} instance from the passed string.\n   *\n   * @param {String} aStr       The string to parse\n   * @return {ICAL.Duration}    The created duration instance\n   */\n  ICAL.Duration.fromString = function icalduration_from_string(aStr) {\n    var pos = 0;\n    var dict = Object.create(null);\n    var chunks = 0;\n    while ((pos = aStr.search(DURATION_LETTERS)) !== -1) {\n      var type = aStr[pos];\n      var numeric = aStr.substr(0, pos);\n      aStr = aStr.substr(pos + 1);\n      chunks += parseDurationChunk(type, numeric, dict);\n    }\n    if (chunks < 2) {\n      // There must be at least a chunk with \"P\" and some unit chunk\n      throw new Error('invalid duration value: Not enough duration components in \"' + aStr + '\"');\n    }\n    return new ICAL.Duration(dict);\n  };\n\n  /**\n   * Creates a new ICAL.Duration instance from the given data object.\n   *\n   * @param {Object} aData               An object with members of the duration\n   * @param {Number} aData.weeks         Duration in weeks\n   * @param {Number} aData.days          Duration in days\n   * @param {Number} aData.hours         Duration in hours\n   * @param {Number} aData.minutes       Duration in minutes\n   * @param {Number} aData.seconds       Duration in seconds\n   * @param {Boolean} aData.isNegative   If true, the duration is negative\n   * @return {ICAL.Duration}             The createad duration instance\n   */\n  ICAL.Duration.fromData = function icalduration_from_data(aData) {\n    return new ICAL.Duration(aData);\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2012 */\n\n(function () {\n  var OPTIONS = [\"tzid\", \"location\", \"tznames\", \"latitude\", \"longitude\"];\n\n  /**\n   * @classdesc\n   * Timezone representation, created by passing in a tzid and component.\n   *\n   * @example\n   * var vcalendar;\n   * var timezoneComp = vcalendar.getFirstSubcomponent('vtimezone');\n   * var tzid = timezoneComp.getFirstPropertyValue('tzid');\n   *\n   * var timezone = new ICAL.Timezone({\n   *   component: timezoneComp,\n   *   tzid\n   * });\n   *\n   * @class\n   * @param {ICAL.Component|Object} data options for class\n   * @param {String|ICAL.Component} data.component\n   *        If data is a simple object, then this member can be set to either a\n   *        string containing the component data, or an already parsed\n   *        ICAL.Component\n   * @param {String} data.tzid      The timezone identifier\n   * @param {String} data.location  The timezone locationw\n   * @param {String} data.tznames   An alternative string representation of the\n   *                                  timezone\n   * @param {Number} data.latitude  The latitude of the timezone\n   * @param {Number} data.longitude The longitude of the timezone\n   */\n  ICAL.Timezone = function icaltimezone(data) {\n    this.wrappedJSObject = this;\n    this.fromData(data);\n  };\n  ICAL.Timezone.prototype = {\n    /**\n     * Timezone identifier\n     * @type {String}\n     */\n    tzid: \"\",\n    /**\n     * Timezone location\n     * @type {String}\n     */\n    location: \"\",\n    /**\n     * Alternative timezone name, for the string representation\n     * @type {String}\n     */\n    tznames: \"\",\n    /**\n     * The primary latitude for the timezone.\n     * @type {Number}\n     */\n    latitude: 0.0,\n    /**\n     * The primary longitude for the timezone.\n     * @type {Number}\n     */\n    longitude: 0.0,\n    /**\n     * The vtimezone component for this timezone.\n     * @type {ICAL.Component}\n     */\n    component: null,\n    /**\n     * The year this timezone has been expanded to. All timezone transition\n     * dates until this year are known and can be used for calculation\n     *\n     * @private\n     * @type {Number}\n     */\n    expandedUntilYear: 0,\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icaltimezone\"\n     */\n    icalclass: \"icaltimezone\",\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {ICAL.Component|Object} aData options for class\n     * @param {String|ICAL.Component} aData.component\n     *        If aData is a simple object, then this member can be set to either a\n     *        string containing the component data, or an already parsed\n     *        ICAL.Component\n     * @param {String} aData.tzid      The timezone identifier\n     * @param {String} aData.location  The timezone locationw\n     * @param {String} aData.tznames   An alternative string representation of the\n     *                                  timezone\n     * @param {Number} aData.latitude  The latitude of the timezone\n     * @param {Number} aData.longitude The longitude of the timezone\n     */\n    fromData: function fromData(aData) {\n      this.expandedUntilYear = 0;\n      this.changes = [];\n      if (aData instanceof ICAL.Component) {\n        // Either a component is passed directly\n        this.component = aData;\n      } else {\n        // Otherwise the component may be in the data object\n        if (aData && \"component\" in aData) {\n          if (typeof aData.component == \"string\") {\n            // If a string was passed, parse it as a component\n            var jCal = ICAL.parse(aData.component);\n            this.component = new ICAL.Component(jCal);\n          } else if (aData.component instanceof ICAL.Component) {\n            // If it was a component already, then just set it\n            this.component = aData.component;\n          } else {\n            // Otherwise just null out the component\n            this.component = null;\n          }\n        }\n\n        // Copy remaining passed properties\n        for (var key in OPTIONS) {\n          /* istanbul ignore else */\n          if (OPTIONS.hasOwnProperty(key)) {\n            var prop = OPTIONS[key];\n            if (aData && prop in aData) {\n              this[prop] = aData[prop];\n            }\n          }\n        }\n      }\n\n      // If we have a component but no TZID, attempt to get it from the\n      // component's properties.\n      if (this.component instanceof ICAL.Component && !this.tzid) {\n        this.tzid = this.component.getFirstPropertyValue('tzid');\n      }\n      return this;\n    },\n    /**\n     * Finds the utcOffset the given time would occur in this timezone.\n     *\n     * @param {ICAL.Time} tt        The time to check for\n     * @return {Number} utc offset in seconds\n     */\n    utcOffset: function utcOffset(tt) {\n      if (this == ICAL.Timezone.utcTimezone || this == ICAL.Timezone.localTimezone) {\n        return 0;\n      }\n      this._ensureCoverage(tt.year);\n      if (!this.changes.length) {\n        return 0;\n      }\n      var tt_change = {\n        year: tt.year,\n        month: tt.month,\n        day: tt.day,\n        hour: tt.hour,\n        minute: tt.minute,\n        second: tt.second\n      };\n      var change_num = this._findNearbyChange(tt_change);\n      var change_num_to_use = -1;\n      var step = 1;\n\n      // TODO: replace with bin search?\n      for (;;) {\n        var change = ICAL.helpers.clone(this.changes[change_num], true);\n        if (change.utcOffset < change.prevUtcOffset) {\n          ICAL.Timezone.adjust_change(change, 0, 0, 0, change.utcOffset);\n        } else {\n          ICAL.Timezone.adjust_change(change, 0, 0, 0, change.prevUtcOffset);\n        }\n        var cmp = ICAL.Timezone._compare_change_fn(tt_change, change);\n        if (cmp >= 0) {\n          change_num_to_use = change_num;\n        } else {\n          step = -1;\n        }\n        if (step == -1 && change_num_to_use != -1) {\n          break;\n        }\n        change_num += step;\n        if (change_num < 0) {\n          return 0;\n        }\n        if (change_num >= this.changes.length) {\n          break;\n        }\n      }\n      var zone_change = this.changes[change_num_to_use];\n      var utcOffset_change = zone_change.utcOffset - zone_change.prevUtcOffset;\n      if (utcOffset_change < 0 && change_num_to_use > 0) {\n        var tmp_change = ICAL.helpers.clone(zone_change, true);\n        ICAL.Timezone.adjust_change(tmp_change, 0, 0, 0, tmp_change.prevUtcOffset);\n        if (ICAL.Timezone._compare_change_fn(tt_change, tmp_change) < 0) {\n          var prev_zone_change = this.changes[change_num_to_use - 1];\n          var want_daylight = false; // TODO\n\n          if (zone_change.is_daylight != want_daylight && prev_zone_change.is_daylight == want_daylight) {\n            zone_change = prev_zone_change;\n          }\n        }\n      }\n\n      // TODO return is_daylight?\n      return zone_change.utcOffset;\n    },\n    _findNearbyChange: function icaltimezone_find_nearby_change(change) {\n      // find the closest match\n      var idx = ICAL.helpers.binsearchInsert(this.changes, change, ICAL.Timezone._compare_change_fn);\n      if (idx >= this.changes.length) {\n        return this.changes.length - 1;\n      }\n      return idx;\n    },\n    _ensureCoverage: function (aYear) {\n      if (ICAL.Timezone._minimumExpansionYear == -1) {\n        var today = ICAL.Time.now();\n        ICAL.Timezone._minimumExpansionYear = today.year;\n      }\n      var changesEndYear = aYear;\n      if (changesEndYear < ICAL.Timezone._minimumExpansionYear) {\n        changesEndYear = ICAL.Timezone._minimumExpansionYear;\n      }\n      changesEndYear += ICAL.Timezone.EXTRA_COVERAGE;\n      if (changesEndYear > ICAL.Timezone.MAX_YEAR) {\n        changesEndYear = ICAL.Timezone.MAX_YEAR;\n      }\n      if (!this.changes.length || this.expandedUntilYear < aYear) {\n        var subcomps = this.component.getAllSubcomponents();\n        var compLen = subcomps.length;\n        var compIdx = 0;\n        for (; compIdx < compLen; compIdx++) {\n          this._expandComponent(subcomps[compIdx], changesEndYear, this.changes);\n        }\n        this.changes.sort(ICAL.Timezone._compare_change_fn);\n        this.expandedUntilYear = changesEndYear;\n      }\n    },\n    _expandComponent: function (aComponent, aYear, changes) {\n      if (!aComponent.hasProperty(\"dtstart\") || !aComponent.hasProperty(\"tzoffsetto\") || !aComponent.hasProperty(\"tzoffsetfrom\")) {\n        return null;\n      }\n      var dtstart = aComponent.getFirstProperty(\"dtstart\").getFirstValue();\n      var change;\n      function convert_tzoffset(offset) {\n        return offset.factor * (offset.hours * 3600 + offset.minutes * 60);\n      }\n      function init_changes() {\n        var changebase = {};\n        changebase.is_daylight = aComponent.name == \"daylight\";\n        changebase.utcOffset = convert_tzoffset(aComponent.getFirstProperty(\"tzoffsetto\").getFirstValue());\n        changebase.prevUtcOffset = convert_tzoffset(aComponent.getFirstProperty(\"tzoffsetfrom\").getFirstValue());\n        return changebase;\n      }\n      if (!aComponent.hasProperty(\"rrule\") && !aComponent.hasProperty(\"rdate\")) {\n        change = init_changes();\n        change.year = dtstart.year;\n        change.month = dtstart.month;\n        change.day = dtstart.day;\n        change.hour = dtstart.hour;\n        change.minute = dtstart.minute;\n        change.second = dtstart.second;\n        ICAL.Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);\n        changes.push(change);\n      } else {\n        var props = aComponent.getAllProperties(\"rdate\");\n        for (var rdatekey in props) {\n          /* istanbul ignore if */\n          if (!props.hasOwnProperty(rdatekey)) {\n            continue;\n          }\n          var rdate = props[rdatekey];\n          var time = rdate.getFirstValue();\n          change = init_changes();\n          change.year = time.year;\n          change.month = time.month;\n          change.day = time.day;\n          if (time.isDate) {\n            change.hour = dtstart.hour;\n            change.minute = dtstart.minute;\n            change.second = dtstart.second;\n            if (dtstart.zone != ICAL.Timezone.utcTimezone) {\n              ICAL.Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);\n            }\n          } else {\n            change.hour = time.hour;\n            change.minute = time.minute;\n            change.second = time.second;\n            if (time.zone != ICAL.Timezone.utcTimezone) {\n              ICAL.Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);\n            }\n          }\n          changes.push(change);\n        }\n        var rrule = aComponent.getFirstProperty(\"rrule\");\n        if (rrule) {\n          rrule = rrule.getFirstValue();\n          change = init_changes();\n          if (rrule.until && rrule.until.zone == ICAL.Timezone.utcTimezone) {\n            rrule.until.adjust(0, 0, 0, change.prevUtcOffset);\n            rrule.until.zone = ICAL.Timezone.localTimezone;\n          }\n          var iterator = rrule.iterator(dtstart);\n          var occ;\n          while (occ = iterator.next()) {\n            change = init_changes();\n            if (occ.year > aYear || !occ) {\n              break;\n            }\n            change.year = occ.year;\n            change.month = occ.month;\n            change.day = occ.day;\n            change.hour = occ.hour;\n            change.minute = occ.minute;\n            change.second = occ.second;\n            change.isDate = occ.isDate;\n            ICAL.Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);\n            changes.push(change);\n          }\n        }\n      }\n      return changes;\n    },\n    /**\n     * The string representation of this timezone.\n     * @return {String}\n     */\n    toString: function toString() {\n      return this.tznames ? this.tznames : this.tzid;\n    }\n  };\n  ICAL.Timezone._compare_change_fn = function icaltimezone_compare_change_fn(a, b) {\n    if (a.year < b.year) return -1;else if (a.year > b.year) return 1;\n    if (a.month < b.month) return -1;else if (a.month > b.month) return 1;\n    if (a.day < b.day) return -1;else if (a.day > b.day) return 1;\n    if (a.hour < b.hour) return -1;else if (a.hour > b.hour) return 1;\n    if (a.minute < b.minute) return -1;else if (a.minute > b.minute) return 1;\n    if (a.second < b.second) return -1;else if (a.second > b.second) return 1;\n    return 0;\n  };\n\n  /**\n   * Convert the date/time from one zone to the next.\n   *\n   * @param {ICAL.Time} tt                  The time to convert\n   * @param {ICAL.Timezone} from_zone       The source zone to convert from\n   * @param {ICAL.Timezone} to_zone         The target zone to convert to\n   * @return {ICAL.Time}                    The converted date/time object\n   */\n  ICAL.Timezone.convert_time = function icaltimezone_convert_time(tt, from_zone, to_zone) {\n    if (tt.isDate || from_zone.tzid == to_zone.tzid || from_zone == ICAL.Timezone.localTimezone || to_zone == ICAL.Timezone.localTimezone) {\n      tt.zone = to_zone;\n      return tt;\n    }\n    var utcOffset = from_zone.utcOffset(tt);\n    tt.adjust(0, 0, 0, -utcOffset);\n    utcOffset = to_zone.utcOffset(tt);\n    tt.adjust(0, 0, 0, utcOffset);\n    return null;\n  };\n\n  /**\n   * Creates a new ICAL.Timezone instance from the passed data object.\n   *\n   * @param {ICAL.Component|Object} aData options for class\n   * @param {String|ICAL.Component} aData.component\n   *        If aData is a simple object, then this member can be set to either a\n   *        string containing the component data, or an already parsed\n   *        ICAL.Component\n   * @param {String} aData.tzid      The timezone identifier\n   * @param {String} aData.location  The timezone locationw\n   * @param {String} aData.tznames   An alternative string representation of the\n   *                                  timezone\n   * @param {Number} aData.latitude  The latitude of the timezone\n   * @param {Number} aData.longitude The longitude of the timezone\n   */\n  ICAL.Timezone.fromData = function icaltimezone_fromData(aData) {\n    var tt = new ICAL.Timezone();\n    return tt.fromData(aData);\n  };\n\n  /**\n   * The instance describing the UTC timezone\n   * @type {ICAL.Timezone}\n   * @constant\n   * @instance\n   */\n  ICAL.Timezone.utcTimezone = ICAL.Timezone.fromData({\n    tzid: \"UTC\"\n  });\n\n  /**\n   * The instance describing the local timezone\n   * @type {ICAL.Timezone}\n   * @constant\n   * @instance\n   */\n  ICAL.Timezone.localTimezone = ICAL.Timezone.fromData({\n    tzid: \"floating\"\n  });\n\n  /**\n   * Adjust a timezone change object.\n   * @private\n   * @param {Object} change     The timezone change object\n   * @param {Number} days       The extra amount of days\n   * @param {Number} hours      The extra amount of hours\n   * @param {Number} minutes    The extra amount of minutes\n   * @param {Number} seconds    The extra amount of seconds\n   */\n  ICAL.Timezone.adjust_change = function icaltimezone_adjust_change(change, days, hours, minutes, seconds) {\n    return ICAL.Time.prototype.adjust.call(change, days, hours, minutes, seconds, change);\n  };\n  ICAL.Timezone._minimumExpansionYear = -1;\n  ICAL.Timezone.MAX_YEAR = 2035; // TODO this is because of time_t, which we don't need. Still usefull?\n  ICAL.Timezone.EXTRA_COVERAGE = 5;\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.TimezoneService = function () {\n  var zones;\n\n  /**\n   * @classdesc\n   * Singleton class to contain timezones.  Right now it is all manual registry in\n   * the future we may use this class to download timezone information or handle\n   * loading pre-expanded timezones.\n   *\n   * @namespace\n   * @alias ICAL.TimezoneService\n   */\n  var TimezoneService = {\n    get count() {\n      return Object.keys(zones).length;\n    },\n    reset: function () {\n      zones = Object.create(null);\n      var utc = ICAL.Timezone.utcTimezone;\n      zones.Z = utc;\n      zones.UTC = utc;\n      zones.GMT = utc;\n    },\n    /**\n     * Checks if timezone id has been registered.\n     *\n     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\n     * @return {Boolean}        False, when not present\n     */\n    has: function (tzid) {\n      return !!zones[tzid];\n    },\n    /**\n     * Returns a timezone by its tzid if present.\n     *\n     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\n     * @return {?ICAL.Timezone} The timezone, or null if not found\n     */\n    get: function (tzid) {\n      return zones[tzid];\n    },\n    /**\n     * Registers a timezone object or component.\n     *\n     * @param {String=} name\n     *        The name of the timezone. Defaults to the component's TZID if not\n     *        passed.\n     * @param {ICAL.Component|ICAL.Timezone} zone\n     *        The initialized zone or vtimezone.\n     */\n    register: function (name, timezone) {\n      if (name instanceof ICAL.Component) {\n        if (name.name === 'vtimezone') {\n          timezone = new ICAL.Timezone(name);\n          name = timezone.tzid;\n        }\n      }\n      if (timezone instanceof ICAL.Timezone) {\n        zones[name] = timezone;\n      } else {\n        throw new TypeError('timezone must be ICAL.Timezone or ICAL.Component');\n      }\n    },\n    /**\n     * Removes a timezone by its tzid from the list.\n     *\n     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\n     * @return {?ICAL.Timezone} The removed timezone, or null if not registered\n     */\n    remove: function (tzid) {\n      return delete zones[tzid];\n    }\n  };\n\n  // initialize defaults\n  TimezoneService.reset();\n  return TimezoneService;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n(function () {\n  /**\n   * @classdesc\n   * iCalendar Time representation (similar to JS Date object).  Fully\n   * independent of system (OS) timezone / time.  Unlike JS Date, the month\n   * January is 1, not zero.\n   *\n   * @example\n   * var time = new ICAL.Time({\n   *   year: 2012,\n   *   month: 10,\n   *   day: 11\n   *   minute: 0,\n   *   second: 0,\n   *   isDate: false\n   * });\n   *\n   *\n   * @alias ICAL.Time\n   * @class\n   * @param {Object} data           Time initialization\n   * @param {Number=} data.year     The year for this date\n   * @param {Number=} data.month    The month for this date\n   * @param {Number=} data.day      The day for this date\n   * @param {Number=} data.hour     The hour for this date\n   * @param {Number=} data.minute   The minute for this date\n   * @param {Number=} data.second   The second for this date\n   * @param {Boolean=} data.isDate  If true, the instance represents a date (as\n   *                                  opposed to a date-time)\n   * @param {ICAL.Timezone} zone timezone this position occurs in\n   */\n  ICAL.Time = function icaltime(data, zone) {\n    this.wrappedJSObject = this;\n    var time = this._time = Object.create(null);\n\n    /* time defaults */\n    time.year = 0;\n    time.month = 1;\n    time.day = 1;\n    time.hour = 0;\n    time.minute = 0;\n    time.second = 0;\n    time.isDate = false;\n    this.fromData(data, zone);\n  };\n  ICAL.Time._dowCache = {};\n  ICAL.Time._wnCache = {};\n  ICAL.Time.prototype = {\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icaltime\"\n     */\n    icalclass: \"icaltime\",\n    _cachedUnixTime: null,\n    /**\n     * The type name, to be used in the jCal object. This value may change and\n     * is strictly defined by the {@link ICAL.Time#isDate isDate} member.\n     * @readonly\n     * @type {String}\n     * @default \"date-time\"\n     */\n    get icaltype() {\n      return this.isDate ? 'date' : 'date-time';\n    },\n    /**\n     * The timezone for this time.\n     * @type {ICAL.Timezone}\n     */\n    zone: null,\n    /**\n     * Internal uses to indicate that a change has been made and the next read\n     * operation must attempt to normalize the value (for example changing the\n     * day to 33).\n     *\n     * @type {Boolean}\n     * @private\n     */\n    _pendingNormalization: false,\n    /**\n     * Returns a clone of the time object.\n     *\n     * @return {ICAL.Time}              The cloned object\n     */\n    clone: function () {\n      return new ICAL.Time(this._time, this.zone);\n    },\n    /**\n     * Reset the time instance to epoch time\n     */\n    reset: function icaltime_reset() {\n      this.fromData(ICAL.Time.epochTime);\n      this.zone = ICAL.Timezone.utcTimezone;\n    },\n    /**\n     * Reset the time instance to the given date/time values.\n     *\n     * @param {Number} year             The year to set\n     * @param {Number} month            The month to set\n     * @param {Number} day              The day to set\n     * @param {Number} hour             The hour to set\n     * @param {Number} minute           The minute to set\n     * @param {Number} second           The second to set\n     * @param {ICAL.Timezone} timezone  The timezone to set\n     */\n    resetTo: function icaltime_resetTo(year, month, day, hour, minute, second, timezone) {\n      this.fromData({\n        year: year,\n        month: month,\n        day: day,\n        hour: hour,\n        minute: minute,\n        second: second,\n        zone: timezone\n      });\n    },\n    /**\n     * Set up the current instance from the Javascript date value.\n     *\n     * @param {?Date} aDate     The Javascript Date to read, or null to reset\n     * @param {Boolean} useUTC  If true, the UTC values of the date will be used\n     */\n    fromJSDate: function icaltime_fromJSDate(aDate, useUTC) {\n      if (!aDate) {\n        this.reset();\n      } else {\n        if (useUTC) {\n          this.zone = ICAL.Timezone.utcTimezone;\n          this.year = aDate.getUTCFullYear();\n          this.month = aDate.getUTCMonth() + 1;\n          this.day = aDate.getUTCDate();\n          this.hour = aDate.getUTCHours();\n          this.minute = aDate.getUTCMinutes();\n          this.second = aDate.getUTCSeconds();\n        } else {\n          this.zone = ICAL.Timezone.localTimezone;\n          this.year = aDate.getFullYear();\n          this.month = aDate.getMonth() + 1;\n          this.day = aDate.getDate();\n          this.hour = aDate.getHours();\n          this.minute = aDate.getMinutes();\n          this.second = aDate.getSeconds();\n        }\n      }\n      this._cachedUnixTime = null;\n      return this;\n    },\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} aData            Time initialization\n     * @param {Number=} aData.year      The year for this date\n     * @param {Number=} aData.month     The month for this date\n     * @param {Number=} aData.day       The day for this date\n     * @param {Number=} aData.hour      The hour for this date\n     * @param {Number=} aData.minute    The minute for this date\n     * @param {Number=} aData.second    The second for this date\n     * @param {Boolean=} aData.isDate   If true, the instance represents a date\n     *                                    (as opposed to a date-time)\n     * @param {ICAL.Timezone=} aZone    Timezone this position occurs in\n     */\n    fromData: function fromData(aData, aZone) {\n      if (aData) {\n        for (var key in aData) {\n          /* istanbul ignore else */\n          if (Object.prototype.hasOwnProperty.call(aData, key)) {\n            // ical type cannot be set\n            if (key === 'icaltype') continue;\n            this[key] = aData[key];\n          }\n        }\n      }\n      if (aZone) {\n        this.zone = aZone;\n      }\n      if (aData && !(\"isDate\" in aData)) {\n        this.isDate = !(\"hour\" in aData);\n      } else if (aData && \"isDate\" in aData) {\n        this.isDate = aData.isDate;\n      }\n      if (aData && \"timezone\" in aData) {\n        var zone = ICAL.TimezoneService.get(aData.timezone);\n        this.zone = zone || ICAL.Timezone.localTimezone;\n      }\n      if (aData && \"zone\" in aData) {\n        this.zone = aData.zone;\n      }\n      if (!this.zone) {\n        this.zone = ICAL.Timezone.localTimezone;\n      }\n      this._cachedUnixTime = null;\n      return this;\n    },\n    /**\n     * Calculate the day of week.\n     * @param {ICAL.Time.weekDay=} aWeekStart\n     *        The week start weekday, defaults to SUNDAY\n     * @return {ICAL.Time.weekDay}\n     */\n    dayOfWeek: function icaltime_dayOfWeek(aWeekStart) {\n      var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n      var dowCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + firstDow;\n      if (dowCacheKey in ICAL.Time._dowCache) {\n        return ICAL.Time._dowCache[dowCacheKey];\n      }\n\n      // Using Zeller's algorithm\n      var q = this.day;\n      var m = this.month + (this.month < 3 ? 12 : 0);\n      var Y = this.year - (this.month < 3 ? 1 : 0);\n      var h = q + Y + ICAL.helpers.trunc((m + 1) * 26 / 10) + ICAL.helpers.trunc(Y / 4);\n      /* istanbul ignore else */\n      if (true /* gregorian */) {\n        h += ICAL.helpers.trunc(Y / 100) * 6 + ICAL.helpers.trunc(Y / 400);\n      } else {\n        h += 5;\n      }\n\n      // Normalize to 1 = wkst\n      h = (h + 7 - firstDow) % 7 + 1;\n      ICAL.Time._dowCache[dowCacheKey] = h;\n      return h;\n    },\n    /**\n     * Calculate the day of year.\n     * @return {Number}\n     */\n    dayOfYear: function dayOfYear() {\n      var is_leap = ICAL.Time.isLeapYear(this.year) ? 1 : 0;\n      var diypm = ICAL.Time.daysInYearPassedMonth;\n      return diypm[is_leap][this.month - 1] + this.day;\n    },\n    /**\n     * Returns a copy of the current date/time, rewound to the start of the\n     * week. The resulting ICAL.Time instance is of icaltype date, even if this\n     * is a date-time.\n     *\n     * @param {ICAL.Time.weekDay=} aWeekStart\n     *        The week start weekday, defaults to SUNDAY\n     * @return {ICAL.Time}      The start of the week (cloned)\n     */\n    startOfWeek: function startOfWeek(aWeekStart) {\n      var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n      var result = this.clone();\n      result.day -= (this.dayOfWeek() + 7 - firstDow) % 7;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n    /**\n     * Returns a copy of the current date/time, shifted to the end of the week.\n     * The resulting ICAL.Time instance is of icaltype date, even if this is a\n     * date-time.\n     *\n     * @param {ICAL.Time.weekDay=} aWeekStart\n     *        The week start weekday, defaults to SUNDAY\n     * @return {ICAL.Time}      The end of the week (cloned)\n     */\n    endOfWeek: function endOfWeek(aWeekStart) {\n      var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n      var result = this.clone();\n      result.day += (7 - this.dayOfWeek() + firstDow - ICAL.Time.SUNDAY) % 7;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n    /**\n     * Returns a copy of the current date/time, rewound to the start of the\n     * month. The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The start of the month (cloned)\n     */\n    startOfMonth: function startOfMonth() {\n      var result = this.clone();\n      result.day = 1;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n    /**\n     * Returns a copy of the current date/time, shifted to the end of the\n     * month.  The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The end of the month (cloned)\n     */\n    endOfMonth: function endOfMonth() {\n      var result = this.clone();\n      result.day = ICAL.Time.daysInMonth(result.month, result.year);\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n    /**\n     * Returns a copy of the current date/time, rewound to the start of the\n     * year. The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The start of the year (cloned)\n     */\n    startOfYear: function startOfYear() {\n      var result = this.clone();\n      result.day = 1;\n      result.month = 1;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n    /**\n     * Returns a copy of the current date/time, shifted to the end of the\n     * year.  The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The end of the year (cloned)\n     */\n    endOfYear: function endOfYear() {\n      var result = this.clone();\n      result.day = 31;\n      result.month = 12;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n    /**\n     * First calculates the start of the week, then returns the day of year for\n     * this date. If the day falls into the previous year, the day is zero or negative.\n     *\n     * @param {ICAL.Time.weekDay=} aFirstDayOfWeek\n     *        The week start weekday, defaults to SUNDAY\n     * @return {Number}     The calculated day of year\n     */\n    startDoyWeek: function startDoyWeek(aFirstDayOfWeek) {\n      var firstDow = aFirstDayOfWeek || ICAL.Time.SUNDAY;\n      var delta = this.dayOfWeek() - firstDow;\n      if (delta < 0) delta += 7;\n      return this.dayOfYear() - delta;\n    },\n    /**\n     * Get the dominical letter for the current year. Letters range from A - G\n     * for common years, and AG to GF for leap years.\n     *\n     * @param {Number} yr           The year to retrieve the letter for\n     * @return {String}             The dominical letter.\n     */\n    getDominicalLetter: function () {\n      return ICAL.Time.getDominicalLetter(this.year);\n    },\n    /**\n     * Finds the nthWeekDay relative to the current month (not day).  The\n     * returned value is a day relative the month that this month belongs to so\n     * 1 would indicate the first of the month and 40 would indicate a day in\n     * the following month.\n     *\n     * @param {Number} aDayOfWeek   Day of the week see the day name constants\n     * @param {Number} aPos         Nth occurrence of a given week day values\n     *        of 1 and 0 both indicate the first weekday of that type. aPos may\n     *        be either positive or negative\n     *\n     * @return {Number} numeric value indicating a day relative\n     *                   to the current month of this time object\n     */\n    nthWeekDay: function icaltime_nthWeekDay(aDayOfWeek, aPos) {\n      var daysInMonth = ICAL.Time.daysInMonth(this.month, this.year);\n      var weekday;\n      var pos = aPos;\n      var start = 0;\n      var otherDay = this.clone();\n      if (pos >= 0) {\n        otherDay.day = 1;\n\n        // because 0 means no position has been given\n        // 1 and 0 indicate the same day.\n        if (pos != 0) {\n          // remove the extra numeric value\n          pos--;\n        }\n\n        // set current start offset to current day.\n        start = otherDay.day;\n\n        // find the current day of week\n        var startDow = otherDay.dayOfWeek();\n\n        // calculate the difference between current\n        // day of the week and desired day of the week\n        var offset = aDayOfWeek - startDow;\n\n        // if the offset goes into the past\n        // week we add 7 so it goes into the next\n        // week. We only want to go forward in time here.\n        if (offset < 0)\n          // this is really important otherwise we would\n          // end up with dates from in the past.\n          offset += 7;\n\n        // add offset to start so start is the same\n        // day of the week as the desired day of week.\n        start += offset;\n\n        // because we are going to add (and multiply)\n        // the numeric value of the day we subtract it\n        // from the start position so not to add it twice.\n        start -= aDayOfWeek;\n\n        // set week day\n        weekday = aDayOfWeek;\n      } else {\n        // then we set it to the last day in the current month\n        otherDay.day = daysInMonth;\n\n        // find the ends weekday\n        var endDow = otherDay.dayOfWeek();\n        pos++;\n        weekday = endDow - aDayOfWeek;\n        if (weekday < 0) {\n          weekday += 7;\n        }\n        weekday = daysInMonth - weekday;\n      }\n      weekday += pos * 7;\n      return start + weekday;\n    },\n    /**\n     * Checks if current time is the nth weekday, relative to the current\n     * month.  Will always return false when rule resolves outside of current\n     * month.\n     *\n     * @param {ICAL.Time.weekDay} aDayOfWeek       Day of week to check\n     * @param {Number} aPos                        Relative position\n     * @return {Boolean}                           True, if it is the nth weekday\n     */\n    isNthWeekDay: function (aDayOfWeek, aPos) {\n      var dow = this.dayOfWeek();\n      if (aPos === 0 && dow === aDayOfWeek) {\n        return true;\n      }\n\n      // get pos\n      var day = this.nthWeekDay(aDayOfWeek, aPos);\n      if (day === this.day) {\n        return true;\n      }\n      return false;\n    },\n    /**\n     * Calculates the ISO 8601 week number. The first week of a year is the\n     * week that contains the first Thursday. The year can have 53 weeks, if\n     * January 1st is a Friday.\n     *\n     * Note there are regions where the first week of the year is the one that\n     * starts on January 1st, which may offset the week number. Also, if a\n     * different week start is specified, this will also affect the week\n     * number.\n     *\n     * @see ICAL.Time.weekOneStarts\n     * @param {ICAL.Time.weekDay} aWeekStart        The weekday the week starts with\n     * @return {Number}                             The ISO week number\n     */\n    weekNumber: function weekNumber(aWeekStart) {\n      var wnCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + aWeekStart;\n      if (wnCacheKey in ICAL.Time._wnCache) {\n        return ICAL.Time._wnCache[wnCacheKey];\n      }\n      // This function courtesty of Julian Bucknall, published under the MIT license\n      // http://www.boyet.com/articles/publishedarticles/calculatingtheisoweeknumb.html\n      // plus some fixes to be able to use different week starts.\n      var week1;\n      var dt = this.clone();\n      dt.isDate = true;\n      var isoyear = this.year;\n      if (dt.month == 12 && dt.day > 25) {\n        week1 = ICAL.Time.weekOneStarts(isoyear + 1, aWeekStart);\n        if (dt.compare(week1) < 0) {\n          week1 = ICAL.Time.weekOneStarts(isoyear, aWeekStart);\n        } else {\n          isoyear++;\n        }\n      } else {\n        week1 = ICAL.Time.weekOneStarts(isoyear, aWeekStart);\n        if (dt.compare(week1) < 0) {\n          week1 = ICAL.Time.weekOneStarts(--isoyear, aWeekStart);\n        }\n      }\n      var daysBetween = dt.subtractDate(week1).toSeconds() / 86400;\n      var answer = ICAL.helpers.trunc(daysBetween / 7) + 1;\n      ICAL.Time._wnCache[wnCacheKey] = answer;\n      return answer;\n    },\n    /**\n     * Adds the duration to the current time. The instance is modified in\n     * place.\n     *\n     * @param {ICAL.Duration} aDuration         The duration to add\n     */\n    addDuration: function icaltime_add(aDuration) {\n      var mult = aDuration.isNegative ? -1 : 1;\n\n      // because of the duration optimizations it is much\n      // more efficient to grab all the values up front\n      // then set them directly (which will avoid a normalization call).\n      // So we don't actually normalize until we need it.\n      var second = this.second;\n      var minute = this.minute;\n      var hour = this.hour;\n      var day = this.day;\n      second += mult * aDuration.seconds;\n      minute += mult * aDuration.minutes;\n      hour += mult * aDuration.hours;\n      day += mult * aDuration.days;\n      day += mult * 7 * aDuration.weeks;\n      this.second = second;\n      this.minute = minute;\n      this.hour = hour;\n      this.day = day;\n      this._cachedUnixTime = null;\n    },\n    /**\n     * Subtract the date details (_excluding_ timezone).  Useful for finding\n     * the relative difference between two time objects excluding their\n     * timezone differences.\n     *\n     * @param {ICAL.Time} aDate     The date to substract\n     * @return {ICAL.Duration}      The difference as a duration\n     */\n    subtractDate: function icaltime_subtract(aDate) {\n      var unixTime = this.toUnixTime() + this.utcOffset();\n      var other = aDate.toUnixTime() + aDate.utcOffset();\n      return ICAL.Duration.fromSeconds(unixTime - other);\n    },\n    /**\n     * Subtract the date details, taking timezones into account.\n     *\n     * @param {ICAL.Time} aDate  The date to subtract\n     * @return {ICAL.Duration}  The difference in duration\n     */\n    subtractDateTz: function icaltime_subtract_abs(aDate) {\n      var unixTime = this.toUnixTime();\n      var other = aDate.toUnixTime();\n      return ICAL.Duration.fromSeconds(unixTime - other);\n    },\n    /**\n     * Compares the ICAL.Time instance with another one.\n     *\n     * @param {ICAL.Duration} aOther        The instance to compare with\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */\n    compare: function icaltime_compare(other) {\n      var a = this.toUnixTime();\n      var b = other.toUnixTime();\n      if (a > b) return 1;\n      if (b > a) return -1;\n      return 0;\n    },\n    /**\n     * Compares only the date part of this instance with another one.\n     *\n     * @param {ICAL.Duration} other         The instance to compare with\n     * @param {ICAL.Timezone} tz            The timezone to compare in\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */\n    compareDateOnlyTz: function icaltime_compareDateOnlyTz(other, tz) {\n      function cmp(attr) {\n        return ICAL.Time._cmp_attr(a, b, attr);\n      }\n      var a = this.convertToZone(tz);\n      var b = other.convertToZone(tz);\n      var rc = 0;\n      if ((rc = cmp(\"year\")) != 0) return rc;\n      if ((rc = cmp(\"month\")) != 0) return rc;\n      if ((rc = cmp(\"day\")) != 0) return rc;\n      return rc;\n    },\n    /**\n     * Convert the instance into another timezone. The returned ICAL.Time\n     * instance is always a copy.\n     *\n     * @param {ICAL.Timezone} zone      The zone to convert to\n     * @return {ICAL.Time}              The copy, converted to the zone\n     */\n    convertToZone: function convertToZone(zone) {\n      var copy = this.clone();\n      var zone_equals = this.zone.tzid == zone.tzid;\n      if (!this.isDate && !zone_equals) {\n        ICAL.Timezone.convert_time(copy, this.zone, zone);\n      }\n      copy.zone = zone;\n      return copy;\n    },\n    /**\n     * Calculates the UTC offset of the current date/time in the timezone it is\n     * in.\n     *\n     * @return {Number}     UTC offset in seconds\n     */\n    utcOffset: function utc_offset() {\n      if (this.zone == ICAL.Timezone.localTimezone || this.zone == ICAL.Timezone.utcTimezone) {\n        return 0;\n      } else {\n        return this.zone.utcOffset(this);\n      }\n    },\n    /**\n     * Returns an RFC 5545 compliant ical representation of this object.\n     *\n     * @return {String} ical date/date-time\n     */\n    toICALString: function () {\n      var string = this.toString();\n      if (string.length > 10) {\n        return ICAL.design.icalendar.value['date-time'].toICAL(string);\n      } else {\n        return ICAL.design.icalendar.value.date.toICAL(string);\n      }\n    },\n    /**\n     * The string representation of this date/time, in jCal form\n     * (including : and - separators).\n     * @return {String}\n     */\n    toString: function toString() {\n      var result = this.year + '-' + ICAL.helpers.pad2(this.month) + '-' + ICAL.helpers.pad2(this.day);\n      if (!this.isDate) {\n        result += 'T' + ICAL.helpers.pad2(this.hour) + ':' + ICAL.helpers.pad2(this.minute) + ':' + ICAL.helpers.pad2(this.second);\n        if (this.zone === ICAL.Timezone.utcTimezone) {\n          result += 'Z';\n        }\n      }\n      return result;\n    },\n    /**\n     * Converts the current instance to a Javascript date\n     * @return {Date}\n     */\n    toJSDate: function toJSDate() {\n      if (this.zone == ICAL.Timezone.localTimezone) {\n        if (this.isDate) {\n          return new Date(this.year, this.month - 1, this.day);\n        } else {\n          return new Date(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, 0);\n        }\n      } else {\n        return new Date(this.toUnixTime() * 1000);\n      }\n    },\n    _normalize: function icaltime_normalize() {\n      var isDate = this._time.isDate;\n      if (this._time.isDate) {\n        this._time.hour = 0;\n        this._time.minute = 0;\n        this._time.second = 0;\n      }\n      this.adjust(0, 0, 0, 0);\n      return this;\n    },\n    /**\n     * Adjust the date/time by the given offset\n     *\n     * @param {Number} aExtraDays       The extra amount of days\n     * @param {Number} aExtraHours      The extra amount of hours\n     * @param {Number} aExtraMinutes    The extra amount of minutes\n     * @param {Number} aExtraSeconds    The extra amount of seconds\n     * @param {Number=} aTime           The time to adjust, defaults to the\n     *                                    current instance.\n     */\n    adjust: function icaltime_adjust(aExtraDays, aExtraHours, aExtraMinutes, aExtraSeconds, aTime) {\n      var minutesOverflow,\n        hoursOverflow,\n        daysOverflow = 0,\n        yearsOverflow = 0;\n      var second, minute, hour, day;\n      var daysInMonth;\n      var time = aTime || this._time;\n      if (!time.isDate) {\n        second = time.second + aExtraSeconds;\n        time.second = second % 60;\n        minutesOverflow = ICAL.helpers.trunc(second / 60);\n        if (time.second < 0) {\n          time.second += 60;\n          minutesOverflow--;\n        }\n        minute = time.minute + aExtraMinutes + minutesOverflow;\n        time.minute = minute % 60;\n        hoursOverflow = ICAL.helpers.trunc(minute / 60);\n        if (time.minute < 0) {\n          time.minute += 60;\n          hoursOverflow--;\n        }\n        hour = time.hour + aExtraHours + hoursOverflow;\n        time.hour = hour % 24;\n        daysOverflow = ICAL.helpers.trunc(hour / 24);\n        if (time.hour < 0) {\n          time.hour += 24;\n          daysOverflow--;\n        }\n      }\n\n      // Adjust month and year first, because we need to know what month the day\n      // is in before adjusting it.\n      if (time.month > 12) {\n        yearsOverflow = ICAL.helpers.trunc((time.month - 1) / 12);\n      } else if (time.month < 1) {\n        yearsOverflow = ICAL.helpers.trunc(time.month / 12) - 1;\n      }\n      time.year += yearsOverflow;\n      time.month -= 12 * yearsOverflow;\n\n      // Now take care of the days (and adjust month if needed)\n      day = time.day + aExtraDays + daysOverflow;\n      if (day > 0) {\n        for (;;) {\n          daysInMonth = ICAL.Time.daysInMonth(time.month, time.year);\n          if (day <= daysInMonth) {\n            break;\n          }\n          time.month++;\n          if (time.month > 12) {\n            time.year++;\n            time.month = 1;\n          }\n          day -= daysInMonth;\n        }\n      } else {\n        while (day <= 0) {\n          if (time.month == 1) {\n            time.year--;\n            time.month = 12;\n          } else {\n            time.month--;\n          }\n          day += ICAL.Time.daysInMonth(time.month, time.year);\n        }\n      }\n      time.day = day;\n      this._cachedUnixTime = null;\n      return this;\n    },\n    /**\n     * Sets up the current instance from unix time, the number of seconds since\n     * January 1st, 1970.\n     *\n     * @param {Number} seconds      The seconds to set up with\n     */\n    fromUnixTime: function fromUnixTime(seconds) {\n      this.zone = ICAL.Timezone.utcTimezone;\n      var epoch = ICAL.Time.epochTime.clone();\n      epoch.adjust(0, 0, 0, seconds);\n      this.year = epoch.year;\n      this.month = epoch.month;\n      this.day = epoch.day;\n      this.hour = epoch.hour;\n      this.minute = epoch.minute;\n      this.second = Math.floor(epoch.second);\n      this._cachedUnixTime = null;\n    },\n    /**\n     * Converts the current instance to seconds since January 1st 1970.\n     *\n     * @return {Number}         Seconds since 1970\n     */\n    toUnixTime: function toUnixTime() {\n      if (this._cachedUnixTime !== null) {\n        return this._cachedUnixTime;\n      }\n      var offset = this.utcOffset();\n\n      // we use the offset trick to ensure\n      // that we are getting the actual UTC time\n      var ms = Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second - offset);\n\n      // seconds\n      this._cachedUnixTime = ms / 1000;\n      return this._cachedUnixTime;\n    },\n    /**\n     * Converts time to into Object which can be serialized then re-created\n     * using the constructor.\n     *\n     * @example\n     * // toJSON will automatically be called\n     * var json = JSON.stringify(mytime);\n     *\n     * var deserialized = JSON.parse(json);\n     *\n     * var time = new ICAL.Time(deserialized);\n     *\n     * @return {Object}\n     */\n    toJSON: function () {\n      var copy = ['year', 'month', 'day', 'hour', 'minute', 'second', 'isDate'];\n      var result = Object.create(null);\n      var i = 0;\n      var len = copy.length;\n      var prop;\n      for (; i < len; i++) {\n        prop = copy[i];\n        result[prop] = this[prop];\n      }\n      if (this.zone) {\n        result.timezone = this.zone.tzid;\n      }\n      return result;\n    }\n  };\n  (function setupNormalizeAttributes() {\n    // This needs to run before any instances are created!\n    function defineAttr(attr) {\n      Object.defineProperty(ICAL.Time.prototype, attr, {\n        get: function getTimeAttr() {\n          if (this._pendingNormalization) {\n            this._normalize();\n            this._pendingNormalization = false;\n          }\n          return this._time[attr];\n        },\n        set: function setTimeAttr(val) {\n          // Check if isDate will be set and if was not set to normalize date.\n          // This avoids losing days when seconds, minutes and hours are zeroed\n          // what normalize will do when time is a date.\n          if (attr === \"isDate\" && val && !this._time.isDate) {\n            this.adjust(0, 0, 0, 0);\n          }\n          this._cachedUnixTime = null;\n          this._pendingNormalization = true;\n          this._time[attr] = val;\n          return val;\n        }\n      });\n    }\n\n    /* istanbul ignore else */\n    if (\"defineProperty\" in Object) {\n      defineAttr(\"year\");\n      defineAttr(\"month\");\n      defineAttr(\"day\");\n      defineAttr(\"hour\");\n      defineAttr(\"minute\");\n      defineAttr(\"second\");\n      defineAttr(\"isDate\");\n    }\n  })();\n\n  /**\n   * Returns the days in the given month\n   *\n   * @param {Number} month      The month to check\n   * @param {Number} year       The year to check\n   * @return {Number}           The number of days in the month\n   */\n  ICAL.Time.daysInMonth = function icaltime_daysInMonth(month, year) {\n    var _daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    var days = 30;\n    if (month < 1 || month > 12) return days;\n    days = _daysInMonth[month];\n    if (month == 2) {\n      days += ICAL.Time.isLeapYear(year);\n    }\n    return days;\n  };\n\n  /**\n   * Checks if the year is a leap year\n   *\n   * @param {Number} year       The year to check\n   * @return {Boolean}          True, if the year is a leap year\n   */\n  ICAL.Time.isLeapYear = function isLeapYear(year) {\n    if (year <= 1752) {\n      return year % 4 == 0;\n    } else {\n      return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;\n    }\n  };\n\n  /**\n   * Create a new ICAL.Time from the day of year and year. The date is returned\n   * in floating timezone.\n   *\n   * @param {Number} aDayOfYear     The day of year\n   * @param {Number} aYear          The year to create the instance in\n   * @return {ICAL.Time}            The created instance with the calculated date\n   */\n  ICAL.Time.fromDayOfYear = function icaltime_fromDayOfYear(aDayOfYear, aYear) {\n    var year = aYear;\n    var doy = aDayOfYear;\n    var tt = new ICAL.Time();\n    tt.auto_normalize = false;\n    var is_leap = ICAL.Time.isLeapYear(year) ? 1 : 0;\n    if (doy < 1) {\n      year--;\n      is_leap = ICAL.Time.isLeapYear(year) ? 1 : 0;\n      doy += ICAL.Time.daysInYearPassedMonth[is_leap][12];\n      return ICAL.Time.fromDayOfYear(doy, year);\n    } else if (doy > ICAL.Time.daysInYearPassedMonth[is_leap][12]) {\n      is_leap = ICAL.Time.isLeapYear(year) ? 1 : 0;\n      doy -= ICAL.Time.daysInYearPassedMonth[is_leap][12];\n      year++;\n      return ICAL.Time.fromDayOfYear(doy, year);\n    }\n    tt.year = year;\n    tt.isDate = true;\n    for (var month = 11; month >= 0; month--) {\n      if (doy > ICAL.Time.daysInYearPassedMonth[is_leap][month]) {\n        tt.month = month + 1;\n        tt.day = doy - ICAL.Time.daysInYearPassedMonth[is_leap][month];\n        break;\n      }\n    }\n    tt.auto_normalize = true;\n    return tt;\n  };\n\n  /**\n   * Returns a new ICAL.Time instance from a date string, e.g 2015-01-02.\n   *\n   * @deprecated                Use {@link ICAL.Time.fromDateString} instead\n   * @param {String} str        The string to create from\n   * @return {ICAL.Time}        The date/time instance\n   */\n  ICAL.Time.fromStringv2 = function fromString(str) {\n    return new ICAL.Time({\n      year: parseInt(str.substr(0, 4), 10),\n      month: parseInt(str.substr(5, 2), 10),\n      day: parseInt(str.substr(8, 2), 10),\n      isDate: true\n    });\n  };\n\n  /**\n   * Returns a new ICAL.Time instance from a date string, e.g 2015-01-02.\n   *\n   * @param {String} aValue     The string to create from\n   * @return {ICAL.Time}        The date/time instance\n   */\n  ICAL.Time.fromDateString = function (aValue) {\n    // Dates should have no timezone.\n    // Google likes to sometimes specify Z on dates\n    // we specifically ignore that to avoid issues.\n\n    // YYYY-MM-DD\n    // 2012-10-10\n    return new ICAL.Time({\n      year: ICAL.helpers.strictParseInt(aValue.substr(0, 4)),\n      month: ICAL.helpers.strictParseInt(aValue.substr(5, 2)),\n      day: ICAL.helpers.strictParseInt(aValue.substr(8, 2)),\n      isDate: true\n    });\n  };\n\n  /**\n   * Returns a new ICAL.Time instance from a date-time string, e.g\n   * 2015-01-02T03:04:05. If a property is specified, the timezone is set up\n   * from the property's TZID parameter.\n   *\n   * @param {String} aValue         The string to create from\n   * @param {ICAL.Property=} prop   The property the date belongs to\n   * @return {ICAL.Time}            The date/time instance\n   */\n  ICAL.Time.fromDateTimeString = function (aValue, prop) {\n    if (aValue.length < 19) {\n      throw new Error('invalid date-time value: \"' + aValue + '\"');\n    }\n    var zone;\n    if (aValue[19] && aValue[19] === 'Z') {\n      zone = 'Z';\n    } else if (prop) {\n      zone = prop.getParameter('tzid');\n    }\n\n    // 2012-10-10T10:10:10(Z)?\n    var time = new ICAL.Time({\n      year: ICAL.helpers.strictParseInt(aValue.substr(0, 4)),\n      month: ICAL.helpers.strictParseInt(aValue.substr(5, 2)),\n      day: ICAL.helpers.strictParseInt(aValue.substr(8, 2)),\n      hour: ICAL.helpers.strictParseInt(aValue.substr(11, 2)),\n      minute: ICAL.helpers.strictParseInt(aValue.substr(14, 2)),\n      second: ICAL.helpers.strictParseInt(aValue.substr(17, 2)),\n      timezone: zone\n    });\n    return time;\n  };\n\n  /**\n   * Returns a new ICAL.Time instance from a date or date-time string,\n   *\n   * @param {String} aValue         The string to create from\n   * @param {ICAL.Property=} prop   The property the date belongs to\n   * @return {ICAL.Time}            The date/time instance\n   */\n  ICAL.Time.fromString = function fromString(aValue, aProperty) {\n    if (aValue.length > 10) {\n      return ICAL.Time.fromDateTimeString(aValue, aProperty);\n    } else {\n      return ICAL.Time.fromDateString(aValue);\n    }\n  };\n\n  /**\n   * Creates a new ICAL.Time instance from the given Javascript Date.\n   *\n   * @param {?Date} aDate     The Javascript Date to read, or null to reset\n   * @param {Boolean} useUTC  If true, the UTC values of the date will be used\n   */\n  ICAL.Time.fromJSDate = function fromJSDate(aDate, useUTC) {\n    var tt = new ICAL.Time();\n    return tt.fromJSDate(aDate, useUTC);\n  };\n\n  /**\n   * Creates a new ICAL.Time instance from the the passed data object.\n   *\n   * @param {Object} aData            Time initialization\n   * @param {Number=} aData.year      The year for this date\n   * @param {Number=} aData.month     The month for this date\n   * @param {Number=} aData.day       The day for this date\n   * @param {Number=} aData.hour      The hour for this date\n   * @param {Number=} aData.minute    The minute for this date\n   * @param {Number=} aData.second    The second for this date\n   * @param {Boolean=} aData.isDate   If true, the instance represents a date\n   *                                    (as opposed to a date-time)\n   * @param {ICAL.Timezone=} aZone    Timezone this position occurs in\n   */\n  ICAL.Time.fromData = function fromData(aData, aZone) {\n    var t = new ICAL.Time();\n    return t.fromData(aData, aZone);\n  };\n\n  /**\n   * Creates a new ICAL.Time instance from the current moment.\n   * The instance is “floating” - has no timezone relation.\n   * To create an instance considering the time zone, call\n   * ICAL.Time.fromJSDate(new Date(), true)\n   * @return {ICAL.Time}\n   */\n  ICAL.Time.now = function icaltime_now() {\n    return ICAL.Time.fromJSDate(new Date(), false);\n  };\n\n  /**\n   * Returns the date on which ISO week number 1 starts.\n   *\n   * @see ICAL.Time#weekNumber\n   * @param {Number} aYear                  The year to search in\n   * @param {ICAL.Time.weekDay=} aWeekStart The week start weekday, used for calculation.\n   * @return {ICAL.Time}                    The date on which week number 1 starts\n   */\n  ICAL.Time.weekOneStarts = function weekOneStarts(aYear, aWeekStart) {\n    var t = ICAL.Time.fromData({\n      year: aYear,\n      month: 1,\n      day: 1,\n      isDate: true\n    });\n    var dow = t.dayOfWeek();\n    var wkst = aWeekStart || ICAL.Time.DEFAULT_WEEK_START;\n    if (dow > ICAL.Time.THURSDAY) {\n      t.day += 7;\n    }\n    if (wkst > ICAL.Time.THURSDAY) {\n      t.day -= 7;\n    }\n    t.day -= dow - wkst;\n    return t;\n  };\n\n  /**\n   * Get the dominical letter for the given year. Letters range from A - G for\n   * common years, and AG to GF for leap years.\n   *\n   * @param {Number} yr           The year to retrieve the letter for\n   * @return {String}             The dominical letter.\n   */\n  ICAL.Time.getDominicalLetter = function (yr) {\n    var LTRS = \"GFEDCBA\";\n    var dom = (yr + (yr / 4 | 0) + (yr / 400 | 0) - (yr / 100 | 0) - 1) % 7;\n    var isLeap = ICAL.Time.isLeapYear(yr);\n    if (isLeap) {\n      return LTRS[(dom + 6) % 7] + LTRS[dom];\n    } else {\n      return LTRS[dom];\n    }\n  };\n\n  /**\n   * January 1st, 1970 as an ICAL.Time.\n   * @type {ICAL.Time}\n   * @constant\n   * @instance\n   */\n  ICAL.Time.epochTime = ICAL.Time.fromData({\n    year: 1970,\n    month: 1,\n    day: 1,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    isDate: false,\n    timezone: \"Z\"\n  });\n  ICAL.Time._cmp_attr = function _cmp_attr(a, b, attr) {\n    if (a[attr] > b[attr]) return 1;\n    if (a[attr] < b[attr]) return -1;\n    return 0;\n  };\n\n  /**\n   * The days that have passed in the year after a given month. The array has\n   * two members, one being an array of passed days for non-leap years, the\n   * other analog for leap years.\n   * @example\n   * var isLeapYear = ICAL.Time.isLeapYear(year);\n   * var passedDays = ICAL.Time.daysInYearPassedMonth[isLeapYear][month];\n   * @type {Array.<Array.<Number>>}\n   */\n  ICAL.Time.daysInYearPassedMonth = [[0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365], [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366]];\n\n  /**\n   * The weekday, 1 = SUNDAY, 7 = SATURDAY. Access via\n   * ICAL.Time.MONDAY, ICAL.Time.TUESDAY, ...\n   *\n   * @typedef {Number} weekDay\n   * @memberof ICAL.Time\n   */\n\n  ICAL.Time.SUNDAY = 1;\n  ICAL.Time.MONDAY = 2;\n  ICAL.Time.TUESDAY = 3;\n  ICAL.Time.WEDNESDAY = 4;\n  ICAL.Time.THURSDAY = 5;\n  ICAL.Time.FRIDAY = 6;\n  ICAL.Time.SATURDAY = 7;\n\n  /**\n   * The default weekday for the WKST part.\n   * @constant\n   * @default ICAL.Time.MONDAY\n   */\n  ICAL.Time.DEFAULT_WEEK_START = ICAL.Time.MONDAY;\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2015 */\n\n(function () {\n  /**\n   * Describes a vCard time, which has slight differences to the ICAL.Time.\n   * Properties can be null if not specified, for example for dates with\n   * reduced accuracy or truncation.\n   *\n   * Note that currently not all methods are correctly re-implemented for\n   * VCardTime. For example, comparison will have undefined results when some\n   * members are null.\n   *\n   * Also, normalization is not yet implemented for this class!\n   *\n   * @alias ICAL.VCardTime\n   * @class\n   * @extends {ICAL.Time}\n   * @param {Object} data                           The data for the time instance\n   * @param {Number=} data.year                     The year for this date\n   * @param {Number=} data.month                    The month for this date\n   * @param {Number=} data.day                      The day for this date\n   * @param {Number=} data.hour                     The hour for this date\n   * @param {Number=} data.minute                   The minute for this date\n   * @param {Number=} data.second                   The second for this date\n   * @param {ICAL.Timezone|ICAL.UtcOffset} zone     The timezone to use\n   * @param {String} icaltype                       The type for this date/time object\n   */\n  ICAL.VCardTime = function (data, zone, icaltype) {\n    this.wrappedJSObject = this;\n    var time = this._time = Object.create(null);\n    time.year = null;\n    time.month = null;\n    time.day = null;\n    time.hour = null;\n    time.minute = null;\n    time.second = null;\n    this.icaltype = icaltype || \"date-and-or-time\";\n    this.fromData(data, zone);\n  };\n  ICAL.helpers.inherits(ICAL.Time, ICAL.VCardTime, /** @lends ICAL.VCardTime */{\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"vcardtime\"\n     */\n    icalclass: \"vcardtime\",\n    /**\n     * The type name, to be used in the jCal object.\n     * @type {String}\n     * @default \"date-and-or-time\"\n     */\n    icaltype: \"date-and-or-time\",\n    /**\n     * The timezone. This can either be floating, UTC, or an instance of\n     * ICAL.UtcOffset.\n     * @type {ICAL.Timezone|ICAL.UtcOFfset}\n     */\n    zone: null,\n    /**\n     * Returns a clone of the vcard date/time object.\n     *\n     * @return {ICAL.VCardTime}     The cloned object\n     */\n    clone: function () {\n      return new ICAL.VCardTime(this._time, this.zone, this.icaltype);\n    },\n    _normalize: function () {\n      return this;\n    },\n    /**\n     * @inheritdoc\n     */\n    utcOffset: function () {\n      if (this.zone instanceof ICAL.UtcOffset) {\n        return this.zone.toSeconds();\n      } else {\n        return ICAL.Time.prototype.utcOffset.apply(this, arguments);\n      }\n    },\n    /**\n     * Returns an RFC 6350 compliant representation of this object.\n     *\n     * @return {String}         vcard date/time string\n     */\n    toICALString: function () {\n      return ICAL.design.vcard.value[this.icaltype].toICAL(this.toString());\n    },\n    /**\n     * The string representation of this date/time, in jCard form\n     * (including : and - separators).\n     * @return {String}\n     */\n    toString: function toString() {\n      var p2 = ICAL.helpers.pad2;\n      var y = this.year,\n        m = this.month,\n        d = this.day;\n      var h = this.hour,\n        mm = this.minute,\n        s = this.second;\n      var hasYear = y !== null,\n        hasMonth = m !== null,\n        hasDay = d !== null;\n      var hasHour = h !== null,\n        hasMinute = mm !== null,\n        hasSecond = s !== null;\n      var datepart = (hasYear ? p2(y) + (hasMonth || hasDay ? '-' : '') : hasMonth || hasDay ? '--' : '') + (hasMonth ? p2(m) : '') + (hasDay ? '-' + p2(d) : '');\n      var timepart = (hasHour ? p2(h) : '-') + (hasHour && hasMinute ? ':' : '') + (hasMinute ? p2(mm) : '') + (!hasHour && !hasMinute ? '-' : '') + (hasMinute && hasSecond ? ':' : '') + (hasSecond ? p2(s) : '');\n      var zone;\n      if (this.zone === ICAL.Timezone.utcTimezone) {\n        zone = 'Z';\n      } else if (this.zone instanceof ICAL.UtcOffset) {\n        zone = this.zone.toString();\n      } else if (this.zone === ICAL.Timezone.localTimezone) {\n        zone = '';\n      } else if (this.zone instanceof ICAL.Timezone) {\n        var offset = ICAL.UtcOffset.fromSeconds(this.zone.utcOffset(this));\n        zone = offset.toString();\n      } else {\n        zone = '';\n      }\n      switch (this.icaltype) {\n        case \"time\":\n          return timepart + zone;\n        case \"date-and-or-time\":\n        case \"date-time\":\n          return datepart + (timepart == '--' ? '' : 'T' + timepart + zone);\n        case \"date\":\n          return datepart;\n      }\n      return null;\n    }\n  });\n\n  /**\n   * Returns a new ICAL.VCardTime instance from a date and/or time string.\n   *\n   * @param {String} aValue     The string to create from\n   * @param {String} aIcalType  The type for this instance, e.g. date-and-or-time\n   * @return {ICAL.VCardTime}   The date/time instance\n   */\n  ICAL.VCardTime.fromDateAndOrTimeString = function (aValue, aIcalType) {\n    function part(v, s, e) {\n      return v ? ICAL.helpers.strictParseInt(v.substr(s, e)) : null;\n    }\n    var parts = aValue.split('T');\n    var dt = parts[0],\n      tmz = parts[1];\n    var splitzone = tmz ? ICAL.design.vcard.value.time._splitZone(tmz) : [];\n    var zone = splitzone[0],\n      tm = splitzone[1];\n    var stoi = ICAL.helpers.strictParseInt;\n    var dtlen = dt ? dt.length : 0;\n    var tmlen = tm ? tm.length : 0;\n    var hasDashDate = dt && dt[0] == '-' && dt[1] == '-';\n    var hasDashTime = tm && tm[0] == '-';\n    var o = {\n      year: hasDashDate ? null : part(dt, 0, 4),\n      month: hasDashDate && (dtlen == 4 || dtlen == 7) ? part(dt, 2, 2) : dtlen == 7 ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 5, 2) : null,\n      day: dtlen == 5 ? part(dt, 3, 2) : dtlen == 7 && hasDashDate ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 8, 2) : null,\n      hour: hasDashTime ? null : part(tm, 0, 2),\n      minute: hasDashTime && tmlen == 3 ? part(tm, 1, 2) : tmlen > 4 ? hasDashTime ? part(tm, 1, 2) : part(tm, 3, 2) : null,\n      second: tmlen == 4 ? part(tm, 2, 2) : tmlen == 6 ? part(tm, 4, 2) : tmlen == 8 ? part(tm, 6, 2) : null\n    };\n    if (zone == 'Z') {\n      zone = ICAL.Timezone.utcTimezone;\n    } else if (zone && zone[3] == ':') {\n      zone = ICAL.UtcOffset.fromString(zone);\n    } else {\n      zone = null;\n    }\n    return new ICAL.VCardTime(o, zone, aIcalType);\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n(function () {\n  var DOW_MAP = {\n    SU: ICAL.Time.SUNDAY,\n    MO: ICAL.Time.MONDAY,\n    TU: ICAL.Time.TUESDAY,\n    WE: ICAL.Time.WEDNESDAY,\n    TH: ICAL.Time.THURSDAY,\n    FR: ICAL.Time.FRIDAY,\n    SA: ICAL.Time.SATURDAY\n  };\n  var REVERSE_DOW_MAP = {};\n  for (var key in DOW_MAP) {\n    /* istanbul ignore else */\n    if (DOW_MAP.hasOwnProperty(key)) {\n      REVERSE_DOW_MAP[DOW_MAP[key]] = key;\n    }\n  }\n  var COPY_PARTS = [\"BYSECOND\", \"BYMINUTE\", \"BYHOUR\", \"BYDAY\", \"BYMONTHDAY\", \"BYYEARDAY\", \"BYWEEKNO\", \"BYMONTH\", \"BYSETPOS\"];\n\n  /**\n   * @classdesc\n   * This class represents the \"recur\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @class\n   * @alias ICAL.Recur\n   * @param {Object} data                               An object with members of the recurrence\n   * @param {ICAL.Recur.frequencyValues=} data.freq     The frequency value\n   * @param {Number=} data.interval                     The INTERVAL value\n   * @param {ICAL.Time.weekDay=} data.wkst              The week start value\n   * @param {ICAL.Time=} data.until                     The end of the recurrence set\n   * @param {Number=} data.count                        The number of occurrences\n   * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part\n   * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part\n   * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part\n   * @param {Array.<String>=} data.byday                The BYDAY values\n   * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part\n   * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part\n   * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part\n   * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part\n   * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part\n   */\n  ICAL.Recur = function icalrecur(data) {\n    this.wrappedJSObject = this;\n    this.parts = {};\n    if (data && typeof data === 'object') {\n      this.fromData(data);\n    }\n  };\n  ICAL.Recur.prototype = {\n    /**\n     * An object holding the BY-parts of the recurrence rule\n     * @type {Object}\n     */\n    parts: null,\n    /**\n     * The interval value for the recurrence rule.\n     * @type {Number}\n     */\n    interval: 1,\n    /**\n     * The week start day\n     *\n     * @type {ICAL.Time.weekDay}\n     * @default ICAL.Time.MONDAY\n     */\n    wkst: ICAL.Time.MONDAY,\n    /**\n     * The end of the recurrence\n     * @type {?ICAL.Time}\n     */\n    until: null,\n    /**\n     * The maximum number of occurrences\n     * @type {?Number}\n     */\n    count: null,\n    /**\n     * The frequency value.\n     * @type {ICAL.Recur.frequencyValues}\n     */\n    freq: null,\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icalrecur\"\n     */\n    icalclass: \"icalrecur\",\n    /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"recur\"\n     */\n    icaltype: \"recur\",\n    /**\n     * Create a new iterator for this recurrence rule. The passed start date\n     * must be the start date of the event, not the start of the range to\n     * search in.\n     *\n     * @example\n     * var recur = comp.getFirstPropertyValue('rrule');\n     * var dtstart = comp.getFirstPropertyValue('dtstart');\n     * var iter = recur.iterator(dtstart);\n     * for (var next = iter.next(); next; next = iter.next()) {\n     *   if (next.compare(rangeStart) < 0) {\n     *     continue;\n     *   }\n     *   console.log(next.toString());\n     * }\n     *\n     * @param {ICAL.Time} aStart        The item's start date\n     * @return {ICAL.RecurIterator}     The recurrence iterator\n     */\n    iterator: function (aStart) {\n      return new ICAL.RecurIterator({\n        rule: this,\n        dtstart: aStart\n      });\n    },\n    /**\n     * Returns a clone of the recurrence object.\n     *\n     * @return {ICAL.Recur}      The cloned object\n     */\n    clone: function clone() {\n      return new ICAL.Recur(this.toJSON());\n    },\n    /**\n     * Checks if the current rule is finite, i.e. has a count or until part.\n     *\n     * @return {Boolean}        True, if the rule is finite\n     */\n    isFinite: function isfinite() {\n      return !!(this.count || this.until);\n    },\n    /**\n     * Checks if the current rule has a count part, and not limited by an until\n     * part.\n     *\n     * @return {Boolean}        True, if the rule is by count\n     */\n    isByCount: function isbycount() {\n      return !!(this.count && !this.until);\n    },\n    /**\n     * Adds a component (part) to the recurrence rule. This is not a component\n     * in the sense of {@link ICAL.Component}, but a part of the recurrence\n     * rule, i.e. BYMONTH.\n     *\n     * @param {String} aType            The name of the component part\n     * @param {Array|String} aValue     The component value\n     */\n    addComponent: function addPart(aType, aValue) {\n      var ucname = aType.toUpperCase();\n      if (ucname in this.parts) {\n        this.parts[ucname].push(aValue);\n      } else {\n        this.parts[ucname] = [aValue];\n      }\n    },\n    /**\n     * Sets the component value for the given by-part.\n     *\n     * @param {String} aType        The component part name\n     * @param {Array} aValues       The component values\n     */\n    setComponent: function setComponent(aType, aValues) {\n      this.parts[aType.toUpperCase()] = aValues.slice();\n    },\n    /**\n     * Gets (a copy) of the requested component value.\n     *\n     * @param {String} aType        The component part name\n     * @return {Array}              The component part value\n     */\n    getComponent: function getComponent(aType) {\n      var ucname = aType.toUpperCase();\n      return ucname in this.parts ? this.parts[ucname].slice() : [];\n    },\n    /**\n     * Retrieves the next occurrence after the given recurrence id. See the\n     * guide on {@tutorial terminology} for more details.\n     *\n     * NOTE: Currently, this method iterates all occurrences from the start\n     * date. It should not be called in a loop for performance reasons. If you\n     * would like to get more than one occurrence, you can iterate the\n     * occurrences manually, see the example on the\n     * {@link ICAL.Recur#iterator iterator} method.\n     *\n     * @param {ICAL.Time} aStartTime        The start of the event series\n     * @param {ICAL.Time} aRecurrenceId     The date of the last occurrence\n     * @return {ICAL.Time}                  The next occurrence after\n     */\n    getNextOccurrence: function getNextOccurrence(aStartTime, aRecurrenceId) {\n      var iter = this.iterator(aStartTime);\n      var next, cdt;\n      do {\n        next = iter.next();\n      } while (next && next.compare(aRecurrenceId) <= 0);\n      if (next && aRecurrenceId.zone) {\n        next.zone = aRecurrenceId.zone;\n      }\n      return next;\n    },\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} data                               An object with members of the recurrence\n     * @param {ICAL.Recur.frequencyValues=} data.freq     The frequency value\n     * @param {Number=} data.interval                     The INTERVAL value\n     * @param {ICAL.Time.weekDay=} data.wkst              The week start value\n     * @param {ICAL.Time=} data.until                     The end of the recurrence set\n     * @param {Number=} data.count                        The number of occurrences\n     * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part\n     * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part\n     * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part\n     * @param {Array.<String>=} data.byday                The BYDAY values\n     * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part\n     * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part\n     * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part\n     * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part\n     * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part\n     */\n    fromData: function (data) {\n      for (var key in data) {\n        var uckey = key.toUpperCase();\n        if (uckey in partDesign) {\n          if (Array.isArray(data[key])) {\n            this.parts[uckey] = data[key];\n          } else {\n            this.parts[uckey] = [data[key]];\n          }\n        } else {\n          this[key] = data[key];\n        }\n      }\n      if (this.interval && typeof this.interval != \"number\") {\n        optionDesign.INTERVAL(this.interval, this);\n      }\n      if (this.wkst && typeof this.wkst != \"number\") {\n        this.wkst = ICAL.Recur.icalDayToNumericDay(this.wkst);\n      }\n      if (this.until && !(this.until instanceof ICAL.Time)) {\n        this.until = ICAL.Time.fromString(this.until);\n      }\n    },\n    /**\n     * The jCal representation of this recurrence type.\n     * @return {Object}\n     */\n    toJSON: function () {\n      var res = Object.create(null);\n      res.freq = this.freq;\n      if (this.count) {\n        res.count = this.count;\n      }\n      if (this.interval > 1) {\n        res.interval = this.interval;\n      }\n      for (var k in this.parts) {\n        /* istanbul ignore if */\n        if (!this.parts.hasOwnProperty(k)) {\n          continue;\n        }\n        var kparts = this.parts[k];\n        if (Array.isArray(kparts) && kparts.length == 1) {\n          res[k.toLowerCase()] = kparts[0];\n        } else {\n          res[k.toLowerCase()] = ICAL.helpers.clone(this.parts[k]);\n        }\n      }\n      if (this.until) {\n        res.until = this.until.toString();\n      }\n      if ('wkst' in this && this.wkst !== ICAL.Time.DEFAULT_WEEK_START) {\n        res.wkst = ICAL.Recur.numericDayToIcalDay(this.wkst);\n      }\n      return res;\n    },\n    /**\n     * The string representation of this recurrence rule.\n     * @return {String}\n     */\n    toString: function icalrecur_toString() {\n      // TODO retain order\n      var str = \"FREQ=\" + this.freq;\n      if (this.count) {\n        str += \";COUNT=\" + this.count;\n      }\n      if (this.interval > 1) {\n        str += \";INTERVAL=\" + this.interval;\n      }\n      for (var k in this.parts) {\n        /* istanbul ignore else */\n        if (this.parts.hasOwnProperty(k)) {\n          str += \";\" + k + \"=\" + this.parts[k];\n        }\n      }\n      if (this.until) {\n        str += ';UNTIL=' + this.until.toICALString();\n      }\n      if ('wkst' in this && this.wkst !== ICAL.Time.DEFAULT_WEEK_START) {\n        str += ';WKST=' + ICAL.Recur.numericDayToIcalDay(this.wkst);\n      }\n      return str;\n    }\n  };\n  function parseNumericValue(type, min, max, value) {\n    var result = value;\n    if (value[0] === '+') {\n      result = value.substr(1);\n    }\n    result = ICAL.helpers.strictParseInt(result);\n    if (min !== undefined && value < min) {\n      throw new Error(type + ': invalid value \"' + value + '\" must be > ' + min);\n    }\n    if (max !== undefined && value > max) {\n      throw new Error(type + ': invalid value \"' + value + '\" must be < ' + min);\n    }\n    return result;\n  }\n\n  /**\n   * Convert an ical representation of a day (SU, MO, etc..)\n   * into a numeric value of that day.\n   *\n   * @param {String} string     The iCalendar day name\n   * @param {ICAL.Time.weekDay=} aWeekStart\n   *        The week start weekday, defaults to SUNDAY\n   * @return {Number}           Numeric value of given day\n   */\n  ICAL.Recur.icalDayToNumericDay = function toNumericDay(string, aWeekStart) {\n    //XXX: this is here so we can deal\n    //     with possibly invalid string values.\n    var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n    return (DOW_MAP[string] - firstDow + 7) % 7 + 1;\n  };\n\n  /**\n   * Convert a numeric day value into its ical representation (SU, MO, etc..)\n   *\n   * @param {Number} num        Numeric value of given day\n   * @param {ICAL.Time.weekDay=} aWeekStart\n   *        The week start weekday, defaults to SUNDAY\n   * @return {String}           The ICAL day value, e.g SU,MO,...\n   */\n  ICAL.Recur.numericDayToIcalDay = function toIcalDay(num, aWeekStart) {\n    //XXX: this is here so we can deal with possibly invalid number values.\n    //     Also, this allows consistent mapping between day numbers and day\n    //     names for external users.\n    var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n    var dow = num + firstDow - ICAL.Time.SUNDAY;\n    if (dow > 7) {\n      dow -= 7;\n    }\n    return REVERSE_DOW_MAP[dow];\n  };\n  var VALID_DAY_NAMES = /^(SU|MO|TU|WE|TH|FR|SA)$/;\n  var VALID_BYDAY_PART = /^([+-])?(5[0-3]|[1-4][0-9]|[1-9])?(SU|MO|TU|WE|TH|FR|SA)$/;\n\n  /**\n   * Possible frequency values for the FREQ part\n   * (YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY, SECONDLY)\n   *\n   * @typedef {String} frequencyValues\n   * @memberof ICAL.Recur\n   */\n\n  var ALLOWED_FREQ = ['SECONDLY', 'MINUTELY', 'HOURLY', 'DAILY', 'WEEKLY', 'MONTHLY', 'YEARLY'];\n  var optionDesign = {\n    FREQ: function (value, dict, fmtIcal) {\n      // yes this is actually equal or faster then regex.\n      // upside here is we can enumerate the valid values.\n      if (ALLOWED_FREQ.indexOf(value) !== -1) {\n        dict.freq = value;\n      } else {\n        throw new Error('invalid frequency \"' + value + '\" expected: \"' + ALLOWED_FREQ.join(', ') + '\"');\n      }\n    },\n    COUNT: function (value, dict, fmtIcal) {\n      dict.count = ICAL.helpers.strictParseInt(value);\n    },\n    INTERVAL: function (value, dict, fmtIcal) {\n      dict.interval = ICAL.helpers.strictParseInt(value);\n      if (dict.interval < 1) {\n        // 0 or negative values are not allowed, some engines seem to generate\n        // it though. Assume 1 instead.\n        dict.interval = 1;\n      }\n    },\n    UNTIL: function (value, dict, fmtIcal) {\n      if (value.length > 10) {\n        dict.until = ICAL.design.icalendar.value['date-time'].fromICAL(value);\n      } else {\n        dict.until = ICAL.design.icalendar.value.date.fromICAL(value);\n      }\n      if (!fmtIcal) {\n        dict.until = ICAL.Time.fromString(dict.until);\n      }\n    },\n    WKST: function (value, dict, fmtIcal) {\n      if (VALID_DAY_NAMES.test(value)) {\n        dict.wkst = ICAL.Recur.icalDayToNumericDay(value);\n      } else {\n        throw new Error('invalid WKST value \"' + value + '\"');\n      }\n    }\n  };\n  var partDesign = {\n    BYSECOND: parseNumericValue.bind(this, 'BYSECOND', 0, 60),\n    BYMINUTE: parseNumericValue.bind(this, 'BYMINUTE', 0, 59),\n    BYHOUR: parseNumericValue.bind(this, 'BYHOUR', 0, 23),\n    BYDAY: function (value) {\n      if (VALID_BYDAY_PART.test(value)) {\n        return value;\n      } else {\n        throw new Error('invalid BYDAY value \"' + value + '\"');\n      }\n    },\n    BYMONTHDAY: parseNumericValue.bind(this, 'BYMONTHDAY', -31, 31),\n    BYYEARDAY: parseNumericValue.bind(this, 'BYYEARDAY', -366, 366),\n    BYWEEKNO: parseNumericValue.bind(this, 'BYWEEKNO', -53, 53),\n    BYMONTH: parseNumericValue.bind(this, 'BYMONTH', 1, 12),\n    BYSETPOS: parseNumericValue.bind(this, 'BYSETPOS', -366, 366)\n  };\n\n  /**\n   * Creates a new {@link ICAL.Recur} instance from the passed string.\n   *\n   * @param {String} string         The string to parse\n   * @return {ICAL.Recur}           The created recurrence instance\n   */\n  ICAL.Recur.fromString = function (string) {\n    var data = ICAL.Recur._stringToData(string, false);\n    return new ICAL.Recur(data);\n  };\n\n  /**\n   * Creates a new {@link ICAL.Recur} instance using members from the passed\n   * data object.\n   *\n   * @param {Object} aData                              An object with members of the recurrence\n   * @param {ICAL.Recur.frequencyValues=} aData.freq    The frequency value\n   * @param {Number=} aData.interval                    The INTERVAL value\n   * @param {ICAL.Time.weekDay=} aData.wkst             The week start value\n   * @param {ICAL.Time=} aData.until                    The end of the recurrence set\n   * @param {Number=} aData.count                       The number of occurrences\n   * @param {Array.<Number>=} aData.bysecond            The seconds for the BYSECOND part\n   * @param {Array.<Number>=} aData.byminute            The minutes for the BYMINUTE part\n   * @param {Array.<Number>=} aData.byhour              The hours for the BYHOUR part\n   * @param {Array.<String>=} aData.byday               The BYDAY values\n   * @param {Array.<Number>=} aData.bymonthday          The days for the BYMONTHDAY part\n   * @param {Array.<Number>=} aData.byyearday           The days for the BYYEARDAY part\n   * @param {Array.<Number>=} aData.byweekno            The weeks for the BYWEEKNO part\n   * @param {Array.<Number>=} aData.bymonth             The month for the BYMONTH part\n   * @param {Array.<Number>=} aData.bysetpos            The positionals for the BYSETPOS part\n   */\n  ICAL.Recur.fromData = function (aData) {\n    return new ICAL.Recur(aData);\n  };\n\n  /**\n   * Converts a recurrence string to a data object, suitable for the fromData\n   * method.\n   *\n   * @param {String} string     The string to parse\n   * @param {Boolean} fmtIcal   If true, the string is considered to be an\n   *                              iCalendar string\n   * @return {ICAL.Recur}       The recurrence instance\n   */\n  ICAL.Recur._stringToData = function (string, fmtIcal) {\n    var dict = Object.create(null);\n\n    // split is slower in FF but fast enough.\n    // v8 however this is faster then manual split?\n    var values = string.split(';');\n    var len = values.length;\n    for (var i = 0; i < len; i++) {\n      var parts = values[i].split('=');\n      var ucname = parts[0].toUpperCase();\n      var lcname = parts[0].toLowerCase();\n      var name = fmtIcal ? lcname : ucname;\n      var value = parts[1];\n      if (ucname in partDesign) {\n        var partArr = value.split(',');\n        var partArrIdx = 0;\n        var partArrLen = partArr.length;\n        for (; partArrIdx < partArrLen; partArrIdx++) {\n          partArr[partArrIdx] = partDesign[ucname](partArr[partArrIdx]);\n        }\n        dict[name] = partArr.length == 1 ? partArr[0] : partArr;\n      } else if (ucname in optionDesign) {\n        optionDesign[ucname](value, dict, fmtIcal);\n      } else {\n        // Don't swallow unknown values. Just set them as they are.\n        dict[lcname] = value;\n      }\n    }\n    return dict;\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.RecurIterator = function () {\n  /**\n   * @classdesc\n   * An iterator for a single recurrence rule. This class usually doesn't have\n   * to be instanciated directly, the convenience method\n   * {@link ICAL.Recur#iterator} can be used.\n   *\n   * @description\n   * The options object may contain additional members when resuming iteration from a previous run\n   *\n   * @description\n   * The options object may contain additional members when resuming iteration\n   * from a previous run.\n   *\n   * @class\n   * @alias ICAL.RecurIterator\n   * @param {Object} options                The iterator options\n   * @param {ICAL.Recur} options.rule       The rule to iterate.\n   * @param {ICAL.Time} options.dtstart     The start date of the event.\n   * @param {Boolean=} options.initialized  When true, assume that options are\n   *        from a previously constructed iterator. Initialization will not be\n   *        repeated.\n   */\n  function icalrecur_iterator(options) {\n    this.fromData(options);\n  }\n  icalrecur_iterator.prototype = {\n    /**\n     * True when iteration is finished.\n     * @type {Boolean}\n     */\n    completed: false,\n    /**\n     * The rule that is being iterated\n     * @type {ICAL.Recur}\n     */\n    rule: null,\n    /**\n     * The start date of the event being iterated.\n     * @type {ICAL.Time}\n     */\n    dtstart: null,\n    /**\n     * The last occurrence that was returned from the\n     * {@link ICAL.RecurIterator#next} method.\n     * @type {ICAL.Time}\n     */\n    last: null,\n    /**\n     * The sequence number from the occurrence\n     * @type {Number}\n     */\n    occurrence_number: 0,\n    /**\n     * The indices used for the {@link ICAL.RecurIterator#by_data} object.\n     * @type {Object}\n     * @private\n     */\n    by_indices: null,\n    /**\n     * If true, the iterator has already been initialized\n     * @type {Boolean}\n     * @private\n     */\n    initialized: false,\n    /**\n     * The initializd by-data.\n     * @type {Object}\n     * @private\n     */\n    by_data: null,\n    /**\n     * The expanded yeardays\n     * @type {Array}\n     * @private\n     */\n    days: null,\n    /**\n     * The index in the {@link ICAL.RecurIterator#days} array.\n     * @type {Number}\n     * @private\n     */\n    days_index: 0,\n    /**\n     * Initialize the recurrence iterator from the passed data object. This\n     * method is usually not called directly, you can initialize the iterator\n     * through the constructor.\n     *\n     * @param {Object} options                The iterator options\n     * @param {ICAL.Recur} options.rule       The rule to iterate.\n     * @param {ICAL.Time} options.dtstart     The start date of the event.\n     * @param {Boolean=} options.initialized  When true, assume that options are\n     *        from a previously constructed iterator. Initialization will not be\n     *        repeated.\n     */\n    fromData: function (options) {\n      this.rule = ICAL.helpers.formatClassType(options.rule, ICAL.Recur);\n      if (!this.rule) {\n        throw new Error('iterator requires a (ICAL.Recur) rule');\n      }\n      this.dtstart = ICAL.helpers.formatClassType(options.dtstart, ICAL.Time);\n      if (!this.dtstart) {\n        throw new Error('iterator requires a (ICAL.Time) dtstart');\n      }\n      if (options.by_data) {\n        this.by_data = options.by_data;\n      } else {\n        this.by_data = ICAL.helpers.clone(this.rule.parts, true);\n      }\n      if (options.occurrence_number) this.occurrence_number = options.occurrence_number;\n      this.days = options.days || [];\n      if (options.last) {\n        this.last = ICAL.helpers.formatClassType(options.last, ICAL.Time);\n      }\n      this.by_indices = options.by_indices;\n      if (!this.by_indices) {\n        this.by_indices = {\n          \"BYSECOND\": 0,\n          \"BYMINUTE\": 0,\n          \"BYHOUR\": 0,\n          \"BYDAY\": 0,\n          \"BYMONTH\": 0,\n          \"BYWEEKNO\": 0,\n          \"BYMONTHDAY\": 0\n        };\n      }\n      this.initialized = options.initialized || false;\n      if (!this.initialized) {\n        this.init();\n      }\n    },\n    /**\n     * Intialize the iterator\n     * @private\n     */\n    init: function icalrecur_iterator_init() {\n      this.initialized = true;\n      this.last = this.dtstart.clone();\n      var parts = this.by_data;\n      if (\"BYDAY\" in parts) {\n        // libical does this earlier when the rule is loaded, but we postpone to\n        // now so we can preserve the original order.\n        this.sort_byday_rules(parts.BYDAY);\n      }\n\n      // If the BYYEARDAY appares, no other date rule part may appear\n      if (\"BYYEARDAY\" in parts) {\n        if (\"BYMONTH\" in parts || \"BYWEEKNO\" in parts || \"BYMONTHDAY\" in parts || \"BYDAY\" in parts) {\n          throw new Error(\"Invalid BYYEARDAY rule\");\n        }\n      }\n\n      // BYWEEKNO and BYMONTHDAY rule parts may not both appear\n      if (\"BYWEEKNO\" in parts && \"BYMONTHDAY\" in parts) {\n        throw new Error(\"BYWEEKNO does not fit to BYMONTHDAY\");\n      }\n\n      // For MONTHLY recurrences (FREQ=MONTHLY) neither BYYEARDAY nor\n      // BYWEEKNO may appear.\n      if (this.rule.freq == \"MONTHLY\" && (\"BYYEARDAY\" in parts || \"BYWEEKNO\" in parts)) {\n        throw new Error(\"For MONTHLY recurrences neither BYYEARDAY nor BYWEEKNO may appear\");\n      }\n\n      // For WEEKLY recurrences (FREQ=WEEKLY) neither BYMONTHDAY nor\n      // BYYEARDAY may appear.\n      if (this.rule.freq == \"WEEKLY\" && (\"BYYEARDAY\" in parts || \"BYMONTHDAY\" in parts)) {\n        throw new Error(\"For WEEKLY recurrences neither BYMONTHDAY nor BYYEARDAY may appear\");\n      }\n\n      // BYYEARDAY may only appear in YEARLY rules\n      if (this.rule.freq != \"YEARLY\" && \"BYYEARDAY\" in parts) {\n        throw new Error(\"BYYEARDAY may only appear in YEARLY rules\");\n      }\n      this.last.second = this.setup_defaults(\"BYSECOND\", \"SECONDLY\", this.dtstart.second);\n      this.last.minute = this.setup_defaults(\"BYMINUTE\", \"MINUTELY\", this.dtstart.minute);\n      this.last.hour = this.setup_defaults(\"BYHOUR\", \"HOURLY\", this.dtstart.hour);\n      this.last.day = this.setup_defaults(\"BYMONTHDAY\", \"DAILY\", this.dtstart.day);\n      this.last.month = this.setup_defaults(\"BYMONTH\", \"MONTHLY\", this.dtstart.month);\n      if (this.rule.freq == \"WEEKLY\") {\n        if (\"BYDAY\" in parts) {\n          var bydayParts = this.ruleDayOfWeek(parts.BYDAY[0], this.rule.wkst);\n          var pos = bydayParts[0];\n          var dow = bydayParts[1];\n          var wkdy = dow - this.last.dayOfWeek(this.rule.wkst);\n          if (this.last.dayOfWeek(this.rule.wkst) < dow && wkdy >= 0 || wkdy < 0) {\n            // Initial time is after first day of BYDAY data\n            this.last.day += wkdy;\n          }\n        } else {\n          var dayName = ICAL.Recur.numericDayToIcalDay(this.dtstart.dayOfWeek());\n          parts.BYDAY = [dayName];\n        }\n      }\n      if (this.rule.freq == \"YEARLY\") {\n        for (;;) {\n          this.expand_year_days(this.last.year);\n          if (this.days.length > 0) {\n            break;\n          }\n          this.increment_year(this.rule.interval);\n        }\n        this._nextByYearDay();\n      }\n      if (this.rule.freq == \"MONTHLY\" && this.has_by_data(\"BYDAY\")) {\n        var tempLast = null;\n        var initLast = this.last.clone();\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n\n        // Check every weekday in BYDAY with relative dow and pos.\n        for (var i in this.by_data.BYDAY) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYDAY.hasOwnProperty(i)) {\n            continue;\n          }\n          this.last = initLast.clone();\n          var bydayParts = this.ruleDayOfWeek(this.by_data.BYDAY[i]);\n          var pos = bydayParts[0];\n          var dow = bydayParts[1];\n          var dayOfMonth = this.last.nthWeekDay(dow, pos);\n\n          // If |pos| >= 6, the byday is invalid for a monthly rule.\n          if (pos >= 6 || pos <= -6) {\n            throw new Error(\"Malformed values in BYDAY part\");\n          }\n\n          // If a Byday with pos=+/-5 is not in the current month it\n          // must be searched in the next months.\n          if (dayOfMonth > daysInMonth || dayOfMonth <= 0) {\n            // Skip if we have already found a \"last\" in this month.\n            if (tempLast && tempLast.month == initLast.month) {\n              continue;\n            }\n            while (dayOfMonth > daysInMonth || dayOfMonth <= 0) {\n              this.increment_month();\n              daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n              dayOfMonth = this.last.nthWeekDay(dow, pos);\n            }\n          }\n          this.last.day = dayOfMonth;\n          if (!tempLast || this.last.compare(tempLast) < 0) {\n            tempLast = this.last.clone();\n          }\n        }\n        this.last = tempLast.clone();\n\n        //XXX: This feels like a hack, but we need to initialize\n        //     the BYMONTHDAY case correctly and byDayAndMonthDay handles\n        //     this case. It accepts a special flag which will avoid incrementing\n        //     the initial value without the flag days that match the start time\n        //     would be missed.\n        if (this.has_by_data('BYMONTHDAY')) {\n          this._byDayAndMonthDay(true);\n        }\n        if (this.last.day > daysInMonth || this.last.day == 0) {\n          throw new Error(\"Malformed values in BYDAY part\");\n        }\n      } else if (this.has_by_data(\"BYMONTHDAY\")) {\n        if (this.last.day < 0) {\n          var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n          this.last.day = daysInMonth + this.last.day + 1;\n        }\n      }\n    },\n    /**\n     * Retrieve the next occurrence from the iterator.\n     * @return {ICAL.Time}\n     */\n    next: function icalrecur_iterator_next() {\n      var before = this.last ? this.last.clone() : null;\n      if (this.rule.count && this.occurrence_number >= this.rule.count || this.rule.until && this.last.compare(this.rule.until) > 0) {\n        //XXX: right now this is just a flag and has no impact\n        //     we can simplify the above case to check for completed later.\n        this.completed = true;\n        return null;\n      }\n      if (this.occurrence_number == 0 && this.last.compare(this.dtstart) >= 0) {\n        // First of all, give the instance that was initialized\n        this.occurrence_number++;\n        return this.last;\n      }\n      var valid;\n      do {\n        valid = 1;\n        switch (this.rule.freq) {\n          case \"SECONDLY\":\n            this.next_second();\n            break;\n          case \"MINUTELY\":\n            this.next_minute();\n            break;\n          case \"HOURLY\":\n            this.next_hour();\n            break;\n          case \"DAILY\":\n            this.next_day();\n            break;\n          case \"WEEKLY\":\n            this.next_week();\n            break;\n          case \"MONTHLY\":\n            valid = this.next_month();\n            break;\n          case \"YEARLY\":\n            this.next_year();\n            break;\n          default:\n            return null;\n        }\n      } while (!this.check_contracting_rules() || this.last.compare(this.dtstart) < 0 || !valid);\n\n      // TODO is this valid?\n      if (this.last.compare(before) == 0) {\n        throw new Error(\"Same occurrence found twice, protecting \" + \"you from death by recursion\");\n      }\n      if (this.rule.until && this.last.compare(this.rule.until) > 0) {\n        this.completed = true;\n        return null;\n      } else {\n        this.occurrence_number++;\n        return this.last;\n      }\n    },\n    next_second: function next_second() {\n      return this.next_generic(\"BYSECOND\", \"SECONDLY\", \"second\", \"minute\");\n    },\n    increment_second: function increment_second(inc) {\n      return this.increment_generic(inc, \"second\", 60, \"minute\");\n    },\n    next_minute: function next_minute() {\n      return this.next_generic(\"BYMINUTE\", \"MINUTELY\", \"minute\", \"hour\", \"next_second\");\n    },\n    increment_minute: function increment_minute(inc) {\n      return this.increment_generic(inc, \"minute\", 60, \"hour\");\n    },\n    next_hour: function next_hour() {\n      return this.next_generic(\"BYHOUR\", \"HOURLY\", \"hour\", \"monthday\", \"next_minute\");\n    },\n    increment_hour: function increment_hour(inc) {\n      this.increment_generic(inc, \"hour\", 24, \"monthday\");\n    },\n    next_day: function next_day() {\n      var has_by_day = (\"BYDAY\" in this.by_data);\n      var this_freq = this.rule.freq == \"DAILY\";\n      if (this.next_hour() == 0) {\n        return 0;\n      }\n      if (this_freq) {\n        this.increment_monthday(this.rule.interval);\n      } else {\n        this.increment_monthday(1);\n      }\n      return 0;\n    },\n    next_week: function next_week() {\n      var end_of_data = 0;\n      if (this.next_weekday_by_week() == 0) {\n        return end_of_data;\n      }\n      if (this.has_by_data(\"BYWEEKNO\")) {\n        var idx = ++this.by_indices.BYWEEKNO;\n        if (this.by_indices.BYWEEKNO == this.by_data.BYWEEKNO.length) {\n          this.by_indices.BYWEEKNO = 0;\n          end_of_data = 1;\n        }\n\n        // HACK should be first month of the year\n        this.last.month = 1;\n        this.last.day = 1;\n        var week_no = this.by_data.BYWEEKNO[this.by_indices.BYWEEKNO];\n        this.last.day += 7 * week_no;\n        if (end_of_data) {\n          this.increment_year(1);\n        }\n      } else {\n        // Jump to the next week\n        this.increment_monthday(7 * this.rule.interval);\n      }\n      return end_of_data;\n    },\n    /**\n     * Normalize each by day rule for a given year/month.\n     * Takes into account ordering and negative rules\n     *\n     * @private\n     * @param {Number} year         Current year.\n     * @param {Number} month        Current month.\n     * @param {Array}  rules        Array of rules.\n     *\n     * @return {Array} sorted and normalized rules.\n     *                 Negative rules will be expanded to their\n     *                 correct positive values for easier processing.\n     */\n    normalizeByMonthDayRules: function (year, month, rules) {\n      var daysInMonth = ICAL.Time.daysInMonth(month, year);\n\n      // XXX: This is probably bad for performance to allocate\n      //      a new array for each month we scan, if possible\n      //      we should try to optimize this...\n      var newRules = [];\n      var ruleIdx = 0;\n      var len = rules.length;\n      var rule;\n      for (; ruleIdx < len; ruleIdx++) {\n        rule = rules[ruleIdx];\n\n        // if this rule falls outside of given\n        // month discard it.\n        if (Math.abs(rule) > daysInMonth) {\n          continue;\n        }\n\n        // negative case\n        if (rule < 0) {\n          // we add (not subtract it is a negative number)\n          // one from the rule because 1 === last day of month\n          rule = daysInMonth + (rule + 1);\n        } else if (rule === 0) {\n          // skip zero: it is invalid.\n          continue;\n        }\n\n        // only add unique items...\n        if (newRules.indexOf(rule) === -1) {\n          newRules.push(rule);\n        }\n      }\n\n      // unique and sort\n      return newRules.sort(function (a, b) {\n        return a - b;\n      });\n    },\n    /**\n     * NOTES:\n     * We are given a list of dates in the month (BYMONTHDAY) (23, etc..)\n     * Also we are given a list of days (BYDAY) (MO, 2SU, etc..) when\n     * both conditions match a given date (this.last.day) iteration stops.\n     *\n     * @private\n     * @param {Boolean=} isInit     When given true will not increment the\n     *                                current day (this.last).\n     */\n    _byDayAndMonthDay: function (isInit) {\n      var byMonthDay; // setup in initMonth\n      var byDay = this.by_data.BYDAY;\n      var date;\n      var dateIdx = 0;\n      var dateLen; // setup in initMonth\n      var dayLen = byDay.length;\n\n      // we are not valid by default\n      var dataIsValid = 0;\n      var daysInMonth;\n      var self = this;\n      // we need a copy of this, because a DateTime gets normalized\n      // automatically if the day is out of range. At some points we\n      // set the last day to 0 to start counting.\n      var lastDay = this.last.day;\n      function initMonth() {\n        daysInMonth = ICAL.Time.daysInMonth(self.last.month, self.last.year);\n        byMonthDay = self.normalizeByMonthDayRules(self.last.year, self.last.month, self.by_data.BYMONTHDAY);\n        dateLen = byMonthDay.length;\n\n        // For the case of more than one occurrence in one month\n        // we have to be sure to start searching after the last\n        // found date or at the last BYMONTHDAY, unless we are\n        // initializing the iterator because in this case we have\n        // to consider the last found date too.\n        while (byMonthDay[dateIdx] <= lastDay && !(isInit && byMonthDay[dateIdx] == lastDay) && dateIdx < dateLen - 1) {\n          dateIdx++;\n        }\n      }\n      function nextMonth() {\n        // since the day is incremented at the start\n        // of the loop below, we need to start at 0\n        lastDay = 0;\n        self.increment_month();\n        dateIdx = 0;\n        initMonth();\n      }\n      initMonth();\n\n      // should come after initMonth\n      if (isInit) {\n        lastDay -= 1;\n      }\n\n      // Use a counter to avoid an infinite loop with malformed rules.\n      // Stop checking after 4 years so we consider also a leap year.\n      var monthsCounter = 48;\n      while (!dataIsValid && monthsCounter) {\n        monthsCounter--;\n        // increment the current date. This is really\n        // important otherwise we may fall into the infinite\n        // loop trap. The initial date takes care of the case\n        // where the current date is the date we are looking\n        // for.\n        date = lastDay + 1;\n        if (date > daysInMonth) {\n          nextMonth();\n          continue;\n        }\n\n        // find next date\n        var next = byMonthDay[dateIdx++];\n\n        // this logic is dependant on the BYMONTHDAYS\n        // being in order (which is done by #normalizeByMonthDayRules)\n        if (next >= date) {\n          // if the next month day is in the future jump to it.\n          lastDay = next;\n        } else {\n          // in this case the 'next' monthday has past\n          // we must move to the month.\n          nextMonth();\n          continue;\n        }\n\n        // Now we can loop through the day rules to see\n        // if one matches the current month date.\n        for (var dayIdx = 0; dayIdx < dayLen; dayIdx++) {\n          var parts = this.ruleDayOfWeek(byDay[dayIdx]);\n          var pos = parts[0];\n          var dow = parts[1];\n          this.last.day = lastDay;\n          if (this.last.isNthWeekDay(dow, pos)) {\n            // when we find the valid one we can mark\n            // the conditions as met and break the loop.\n            // (Because we have this condition above\n            //  it will also break the parent loop).\n            dataIsValid = 1;\n            break;\n          }\n        }\n\n        // It is completely possible that the combination\n        // cannot be matched in the current month.\n        // When we reach the end of possible combinations\n        // in the current month we iterate to the next one.\n        // since dateIdx is incremented right after getting\n        // \"next\", we don't need dateLen -1 here.\n        if (!dataIsValid && dateIdx === dateLen) {\n          nextMonth();\n          continue;\n        }\n      }\n      if (monthsCounter <= 0) {\n        // Checked 4 years without finding a Byday that matches\n        // a Bymonthday. Maybe the rule is not correct.\n        throw new Error(\"Malformed values in BYDAY combined with BYMONTHDAY parts\");\n      }\n      return dataIsValid;\n    },\n    next_month: function next_month() {\n      var this_freq = this.rule.freq == \"MONTHLY\";\n      var data_valid = 1;\n      if (this.next_hour() == 0) {\n        return data_valid;\n      }\n      if (this.has_by_data(\"BYDAY\") && this.has_by_data(\"BYMONTHDAY\")) {\n        data_valid = this._byDayAndMonthDay();\n      } else if (this.has_by_data(\"BYDAY\")) {\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n        var setpos = 0;\n        var setpos_total = 0;\n        if (this.has_by_data(\"BYSETPOS\")) {\n          var last_day = this.last.day;\n          for (var day = 1; day <= daysInMonth; day++) {\n            this.last.day = day;\n            if (this.is_day_in_byday(this.last)) {\n              setpos_total++;\n              if (day <= last_day) {\n                setpos++;\n              }\n            }\n          }\n          this.last.day = last_day;\n        }\n        data_valid = 0;\n        for (var day = this.last.day + 1; day <= daysInMonth; day++) {\n          this.last.day = day;\n          if (this.is_day_in_byday(this.last)) {\n            if (!this.has_by_data(\"BYSETPOS\") || this.check_set_position(++setpos) || this.check_set_position(setpos - setpos_total - 1)) {\n              data_valid = 1;\n              break;\n            }\n          }\n        }\n        if (day > daysInMonth) {\n          this.last.day = 1;\n          this.increment_month();\n          if (this.is_day_in_byday(this.last)) {\n            if (!this.has_by_data(\"BYSETPOS\") || this.check_set_position(1)) {\n              data_valid = 1;\n            }\n          } else {\n            data_valid = 0;\n          }\n        }\n      } else if (this.has_by_data(\"BYMONTHDAY\")) {\n        this.by_indices.BYMONTHDAY++;\n        if (this.by_indices.BYMONTHDAY >= this.by_data.BYMONTHDAY.length) {\n          this.by_indices.BYMONTHDAY = 0;\n          this.increment_month();\n        }\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n        var day = this.by_data.BYMONTHDAY[this.by_indices.BYMONTHDAY];\n        if (day < 0) {\n          day = daysInMonth + day + 1;\n        }\n        if (day > daysInMonth) {\n          this.last.day = 1;\n          data_valid = this.is_day_in_byday(this.last);\n        } else {\n          this.last.day = day;\n        }\n      } else {\n        this.increment_month();\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n        if (this.by_data.BYMONTHDAY[0] > daysInMonth) {\n          data_valid = 0;\n        } else {\n          this.last.day = this.by_data.BYMONTHDAY[0];\n        }\n      }\n      return data_valid;\n    },\n    next_weekday_by_week: function next_weekday_by_week() {\n      var end_of_data = 0;\n      if (this.next_hour() == 0) {\n        return end_of_data;\n      }\n      if (!this.has_by_data(\"BYDAY\")) {\n        return 1;\n      }\n      for (;;) {\n        var tt = new ICAL.Time();\n        this.by_indices.BYDAY++;\n        if (this.by_indices.BYDAY == Object.keys(this.by_data.BYDAY).length) {\n          this.by_indices.BYDAY = 0;\n          end_of_data = 1;\n        }\n        var coded_day = this.by_data.BYDAY[this.by_indices.BYDAY];\n        var parts = this.ruleDayOfWeek(coded_day);\n        var dow = parts[1];\n        dow -= this.rule.wkst;\n        if (dow < 0) {\n          dow += 7;\n        }\n        tt.year = this.last.year;\n        tt.month = this.last.month;\n        tt.day = this.last.day;\n        var startOfWeek = tt.startDoyWeek(this.rule.wkst);\n        if (dow + startOfWeek < 1) {\n          // The selected date is in the previous year\n          if (!end_of_data) {\n            continue;\n          }\n        }\n        var next = ICAL.Time.fromDayOfYear(startOfWeek + dow, this.last.year);\n\n        /**\n         * The normalization horrors below are due to\n         * the fact that when the year/month/day changes\n         * it can effect the other operations that come after.\n         */\n        this.last.year = next.year;\n        this.last.month = next.month;\n        this.last.day = next.day;\n        return end_of_data;\n      }\n    },\n    next_year: function next_year() {\n      if (this.next_hour() == 0) {\n        return 0;\n      }\n      if (++this.days_index == this.days.length) {\n        this.days_index = 0;\n        do {\n          this.increment_year(this.rule.interval);\n          this.expand_year_days(this.last.year);\n        } while (this.days.length == 0);\n      }\n      this._nextByYearDay();\n      return 1;\n    },\n    _nextByYearDay: function _nextByYearDay() {\n      var doy = this.days[this.days_index];\n      var year = this.last.year;\n      if (doy < 1) {\n        // Time.fromDayOfYear(doy, year) indexes relative to the\n        // start of the given year. That is different from the\n        // semantics of BYYEARDAY where negative indexes are an\n        // offset from the end of the given year.\n        doy += 1;\n        year += 1;\n      }\n      var next = ICAL.Time.fromDayOfYear(doy, year);\n      this.last.day = next.day;\n      this.last.month = next.month;\n    },\n    /**\n     * @param dow (eg: '1TU', '-1MO')\n     * @param {ICAL.Time.weekDay=} aWeekStart The week start weekday\n     * @return [pos, numericDow] (eg: [1, 3]) numericDow is relative to aWeekStart\n     */\n    ruleDayOfWeek: function ruleDayOfWeek(dow, aWeekStart) {\n      var matches = dow.match(/([+-]?[0-9])?(MO|TU|WE|TH|FR|SA|SU)/);\n      if (matches) {\n        var pos = parseInt(matches[1] || 0, 10);\n        dow = ICAL.Recur.icalDayToNumericDay(matches[2], aWeekStart);\n        return [pos, dow];\n      } else {\n        return [0, 0];\n      }\n    },\n    next_generic: function next_generic(aRuleType, aInterval, aDateAttr, aFollowingAttr, aPreviousIncr) {\n      var has_by_rule = (aRuleType in this.by_data);\n      var this_freq = this.rule.freq == aInterval;\n      var end_of_data = 0;\n      if (aPreviousIncr && this[aPreviousIncr]() == 0) {\n        return end_of_data;\n      }\n      if (has_by_rule) {\n        this.by_indices[aRuleType]++;\n        var idx = this.by_indices[aRuleType];\n        var dta = this.by_data[aRuleType];\n        if (this.by_indices[aRuleType] == dta.length) {\n          this.by_indices[aRuleType] = 0;\n          end_of_data = 1;\n        }\n        this.last[aDateAttr] = dta[this.by_indices[aRuleType]];\n      } else if (this_freq) {\n        this[\"increment_\" + aDateAttr](this.rule.interval);\n      }\n      if (has_by_rule && end_of_data && this_freq) {\n        this[\"increment_\" + aFollowingAttr](1);\n      }\n      return end_of_data;\n    },\n    increment_monthday: function increment_monthday(inc) {\n      for (var i = 0; i < inc; i++) {\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n        this.last.day++;\n        if (this.last.day > daysInMonth) {\n          this.last.day -= daysInMonth;\n          this.increment_month();\n        }\n      }\n    },\n    increment_month: function increment_month() {\n      this.last.day = 1;\n      if (this.has_by_data(\"BYMONTH\")) {\n        this.by_indices.BYMONTH++;\n        if (this.by_indices.BYMONTH == this.by_data.BYMONTH.length) {\n          this.by_indices.BYMONTH = 0;\n          this.increment_year(1);\n        }\n        this.last.month = this.by_data.BYMONTH[this.by_indices.BYMONTH];\n      } else {\n        if (this.rule.freq == \"MONTHLY\") {\n          this.last.month += this.rule.interval;\n        } else {\n          this.last.month++;\n        }\n        this.last.month--;\n        var years = ICAL.helpers.trunc(this.last.month / 12);\n        this.last.month %= 12;\n        this.last.month++;\n        if (years != 0) {\n          this.increment_year(years);\n        }\n      }\n    },\n    increment_year: function increment_year(inc) {\n      this.last.year += inc;\n    },\n    increment_generic: function increment_generic(inc, aDateAttr, aFactor, aNextIncrement) {\n      this.last[aDateAttr] += inc;\n      var nextunit = ICAL.helpers.trunc(this.last[aDateAttr] / aFactor);\n      this.last[aDateAttr] %= aFactor;\n      if (nextunit != 0) {\n        this[\"increment_\" + aNextIncrement](nextunit);\n      }\n    },\n    has_by_data: function has_by_data(aRuleType) {\n      return aRuleType in this.rule.parts;\n    },\n    expand_year_days: function expand_year_days(aYear) {\n      var t = new ICAL.Time();\n      this.days = [];\n\n      // We need our own copy with a few keys set\n      var parts = {};\n      var rules = [\"BYDAY\", \"BYWEEKNO\", \"BYMONTHDAY\", \"BYMONTH\", \"BYYEARDAY\"];\n      for (var p in rules) {\n        /* istanbul ignore else */\n        if (rules.hasOwnProperty(p)) {\n          var part = rules[p];\n          if (part in this.rule.parts) {\n            parts[part] = this.rule.parts[part];\n          }\n        }\n      }\n      if (\"BYMONTH\" in parts && \"BYWEEKNO\" in parts) {\n        var valid = 1;\n        var validWeeks = {};\n        t.year = aYear;\n        t.isDate = true;\n        for (var monthIdx = 0; monthIdx < this.by_data.BYMONTH.length; monthIdx++) {\n          var month = this.by_data.BYMONTH[monthIdx];\n          t.month = month;\n          t.day = 1;\n          var first_week = t.weekNumber(this.rule.wkst);\n          t.day = ICAL.Time.daysInMonth(month, aYear);\n          var last_week = t.weekNumber(this.rule.wkst);\n          for (monthIdx = first_week; monthIdx < last_week; monthIdx++) {\n            validWeeks[monthIdx] = 1;\n          }\n        }\n        for (var weekIdx = 0; weekIdx < this.by_data.BYWEEKNO.length && valid; weekIdx++) {\n          var weekno = this.by_data.BYWEEKNO[weekIdx];\n          if (weekno < 52) {\n            valid &= validWeeks[weekIdx];\n          } else {\n            valid = 0;\n          }\n        }\n        if (valid) {\n          delete parts.BYMONTH;\n        } else {\n          delete parts.BYWEEKNO;\n        }\n      }\n      var partCount = Object.keys(parts).length;\n      if (partCount == 0) {\n        var t1 = this.dtstart.clone();\n        t1.year = this.last.year;\n        this.days.push(t1.dayOfYear());\n      } else if (partCount == 1 && \"BYMONTH\" in parts) {\n        for (var monthkey in this.by_data.BYMONTH) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {\n            continue;\n          }\n          var t2 = this.dtstart.clone();\n          t2.year = aYear;\n          t2.month = this.by_data.BYMONTH[monthkey];\n          t2.isDate = true;\n          this.days.push(t2.dayOfYear());\n        }\n      } else if (partCount == 1 && \"BYMONTHDAY\" in parts) {\n        for (var monthdaykey in this.by_data.BYMONTHDAY) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {\n            continue;\n          }\n          var t3 = this.dtstart.clone();\n          var day_ = this.by_data.BYMONTHDAY[monthdaykey];\n          if (day_ < 0) {\n            var daysInMonth = ICAL.Time.daysInMonth(t3.month, aYear);\n            day_ = day_ + daysInMonth + 1;\n          }\n          t3.day = day_;\n          t3.year = aYear;\n          t3.isDate = true;\n          this.days.push(t3.dayOfYear());\n        }\n      } else if (partCount == 2 && \"BYMONTHDAY\" in parts && \"BYMONTH\" in parts) {\n        for (var monthkey in this.by_data.BYMONTH) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {\n            continue;\n          }\n          var month_ = this.by_data.BYMONTH[monthkey];\n          var daysInMonth = ICAL.Time.daysInMonth(month_, aYear);\n          for (var monthdaykey in this.by_data.BYMONTHDAY) {\n            /* istanbul ignore if */\n            if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {\n              continue;\n            }\n            var day_ = this.by_data.BYMONTHDAY[monthdaykey];\n            if (day_ < 0) {\n              day_ = day_ + daysInMonth + 1;\n            }\n            t.day = day_;\n            t.month = month_;\n            t.year = aYear;\n            t.isDate = true;\n            this.days.push(t.dayOfYear());\n          }\n        }\n      } else if (partCount == 1 && \"BYWEEKNO\" in parts) {\n        // TODO unimplemented in libical\n      } else if (partCount == 2 && \"BYWEEKNO\" in parts && \"BYMONTHDAY\" in parts) {\n        // TODO unimplemented in libical\n      } else if (partCount == 1 && \"BYDAY\" in parts) {\n        this.days = this.days.concat(this.expand_by_day(aYear));\n      } else if (partCount == 2 && \"BYDAY\" in parts && \"BYMONTH\" in parts) {\n        for (var monthkey in this.by_data.BYMONTH) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {\n            continue;\n          }\n          var month = this.by_data.BYMONTH[monthkey];\n          var daysInMonth = ICAL.Time.daysInMonth(month, aYear);\n          t.year = aYear;\n          t.month = this.by_data.BYMONTH[monthkey];\n          t.day = 1;\n          t.isDate = true;\n          var first_dow = t.dayOfWeek();\n          var doy_offset = t.dayOfYear() - 1;\n          t.day = daysInMonth;\n          var last_dow = t.dayOfWeek();\n          if (this.has_by_data(\"BYSETPOS\")) {\n            var set_pos_counter = 0;\n            var by_month_day = [];\n            for (var day = 1; day <= daysInMonth; day++) {\n              t.day = day;\n              if (this.is_day_in_byday(t)) {\n                by_month_day.push(day);\n              }\n            }\n            for (var spIndex = 0; spIndex < by_month_day.length; spIndex++) {\n              if (this.check_set_position(spIndex + 1) || this.check_set_position(spIndex - by_month_day.length)) {\n                this.days.push(doy_offset + by_month_day[spIndex]);\n              }\n            }\n          } else {\n            for (var daycodedkey in this.by_data.BYDAY) {\n              /* istanbul ignore if */\n              if (!this.by_data.BYDAY.hasOwnProperty(daycodedkey)) {\n                continue;\n              }\n              var coded_day = this.by_data.BYDAY[daycodedkey];\n              var bydayParts = this.ruleDayOfWeek(coded_day);\n              var pos = bydayParts[0];\n              var dow = bydayParts[1];\n              var month_day;\n              var first_matching_day = (dow + 7 - first_dow) % 7 + 1;\n              var last_matching_day = daysInMonth - (last_dow + 7 - dow) % 7;\n              if (pos == 0) {\n                for (var day = first_matching_day; day <= daysInMonth; day += 7) {\n                  this.days.push(doy_offset + day);\n                }\n              } else if (pos > 0) {\n                month_day = first_matching_day + (pos - 1) * 7;\n                if (month_day <= daysInMonth) {\n                  this.days.push(doy_offset + month_day);\n                }\n              } else {\n                month_day = last_matching_day + (pos + 1) * 7;\n                if (month_day > 0) {\n                  this.days.push(doy_offset + month_day);\n                }\n              }\n            }\n          }\n        }\n        // Return dates in order of occurrence (1,2,3,...) instead\n        // of by groups of weekdays (1,8,15,...,2,9,16,...).\n        this.days.sort(function (a, b) {\n          return a - b;\n        }); // Comparator function allows to sort numbers.\n      } else if (partCount == 2 && \"BYDAY\" in parts && \"BYMONTHDAY\" in parts) {\n        var expandedDays = this.expand_by_day(aYear);\n        for (var daykey in expandedDays) {\n          /* istanbul ignore if */\n          if (!expandedDays.hasOwnProperty(daykey)) {\n            continue;\n          }\n          var day = expandedDays[daykey];\n          var tt = ICAL.Time.fromDayOfYear(day, aYear);\n          if (this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {\n            this.days.push(day);\n          }\n        }\n      } else if (partCount == 3 && \"BYDAY\" in parts && \"BYMONTHDAY\" in parts && \"BYMONTH\" in parts) {\n        var expandedDays = this.expand_by_day(aYear);\n        for (var daykey in expandedDays) {\n          /* istanbul ignore if */\n          if (!expandedDays.hasOwnProperty(daykey)) {\n            continue;\n          }\n          var day = expandedDays[daykey];\n          var tt = ICAL.Time.fromDayOfYear(day, aYear);\n          if (this.by_data.BYMONTH.indexOf(tt.month) >= 0 && this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {\n            this.days.push(day);\n          }\n        }\n      } else if (partCount == 2 && \"BYDAY\" in parts && \"BYWEEKNO\" in parts) {\n        var expandedDays = this.expand_by_day(aYear);\n        for (var daykey in expandedDays) {\n          /* istanbul ignore if */\n          if (!expandedDays.hasOwnProperty(daykey)) {\n            continue;\n          }\n          var day = expandedDays[daykey];\n          var tt = ICAL.Time.fromDayOfYear(day, aYear);\n          var weekno = tt.weekNumber(this.rule.wkst);\n          if (this.by_data.BYWEEKNO.indexOf(weekno)) {\n            this.days.push(day);\n          }\n        }\n      } else if (partCount == 3 && \"BYDAY\" in parts && \"BYWEEKNO\" in parts && \"BYMONTHDAY\" in parts) {\n        // TODO unimplemted in libical\n      } else if (partCount == 1 && \"BYYEARDAY\" in parts) {\n        this.days = this.days.concat(this.by_data.BYYEARDAY);\n      } else {\n        this.days = [];\n      }\n      return 0;\n    },\n    expand_by_day: function expand_by_day(aYear) {\n      var days_list = [];\n      var tmp = this.last.clone();\n      tmp.year = aYear;\n      tmp.month = 1;\n      tmp.day = 1;\n      tmp.isDate = true;\n      var start_dow = tmp.dayOfWeek();\n      tmp.month = 12;\n      tmp.day = 31;\n      tmp.isDate = true;\n      var end_dow = tmp.dayOfWeek();\n      var end_year_day = tmp.dayOfYear();\n      for (var daykey in this.by_data.BYDAY) {\n        /* istanbul ignore if */\n        if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {\n          continue;\n        }\n        var day = this.by_data.BYDAY[daykey];\n        var parts = this.ruleDayOfWeek(day);\n        var pos = parts[0];\n        var dow = parts[1];\n        if (pos == 0) {\n          var tmp_start_doy = (dow + 7 - start_dow) % 7 + 1;\n          for (var doy = tmp_start_doy; doy <= end_year_day; doy += 7) {\n            days_list.push(doy);\n          }\n        } else if (pos > 0) {\n          var first;\n          if (dow >= start_dow) {\n            first = dow - start_dow + 1;\n          } else {\n            first = dow - start_dow + 8;\n          }\n          days_list.push(first + (pos - 1) * 7);\n        } else {\n          var last;\n          pos = -pos;\n          if (dow <= end_dow) {\n            last = end_year_day - end_dow + dow;\n          } else {\n            last = end_year_day - end_dow + dow - 7;\n          }\n          days_list.push(last - (pos - 1) * 7);\n        }\n      }\n      return days_list;\n    },\n    is_day_in_byday: function is_day_in_byday(tt) {\n      for (var daykey in this.by_data.BYDAY) {\n        /* istanbul ignore if */\n        if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {\n          continue;\n        }\n        var day = this.by_data.BYDAY[daykey];\n        var parts = this.ruleDayOfWeek(day);\n        var pos = parts[0];\n        var dow = parts[1];\n        var this_dow = tt.dayOfWeek();\n        if (pos == 0 && dow == this_dow || tt.nthWeekDay(dow, pos) == tt.day) {\n          return 1;\n        }\n      }\n      return 0;\n    },\n    /**\n     * Checks if given value is in BYSETPOS.\n     *\n     * @private\n     * @param {Numeric} aPos position to check for.\n     * @return {Boolean} false unless BYSETPOS rules exist\n     *                   and the given value is present in rules.\n     */\n    check_set_position: function check_set_position(aPos) {\n      if (this.has_by_data('BYSETPOS')) {\n        var idx = this.by_data.BYSETPOS.indexOf(aPos);\n        // negative numbers are not false-y\n        return idx !== -1;\n      }\n      return false;\n    },\n    sort_byday_rules: function icalrecur_sort_byday_rules(aRules) {\n      for (var i = 0; i < aRules.length; i++) {\n        for (var j = 0; j < i; j++) {\n          var one = this.ruleDayOfWeek(aRules[j], this.rule.wkst)[1];\n          var two = this.ruleDayOfWeek(aRules[i], this.rule.wkst)[1];\n          if (one > two) {\n            var tmp = aRules[i];\n            aRules[i] = aRules[j];\n            aRules[j] = tmp;\n          }\n        }\n      }\n    },\n    check_contract_restriction: function check_contract_restriction(aRuleType, v) {\n      var indexMapValue = icalrecur_iterator._indexMap[aRuleType];\n      var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];\n      var pass = false;\n      if (aRuleType in this.by_data && ruleMapValue == icalrecur_iterator.CONTRACT) {\n        var ruleType = this.by_data[aRuleType];\n        for (var bydatakey in ruleType) {\n          /* istanbul ignore else */\n          if (ruleType.hasOwnProperty(bydatakey)) {\n            if (ruleType[bydatakey] == v) {\n              pass = true;\n              break;\n            }\n          }\n        }\n      } else {\n        // Not a contracting byrule or has no data, test passes\n        pass = true;\n      }\n      return pass;\n    },\n    check_contracting_rules: function check_contracting_rules() {\n      var dow = this.last.dayOfWeek();\n      var weekNo = this.last.weekNumber(this.rule.wkst);\n      var doy = this.last.dayOfYear();\n      return this.check_contract_restriction(\"BYSECOND\", this.last.second) && this.check_contract_restriction(\"BYMINUTE\", this.last.minute) && this.check_contract_restriction(\"BYHOUR\", this.last.hour) && this.check_contract_restriction(\"BYDAY\", ICAL.Recur.numericDayToIcalDay(dow)) && this.check_contract_restriction(\"BYWEEKNO\", weekNo) && this.check_contract_restriction(\"BYMONTHDAY\", this.last.day) && this.check_contract_restriction(\"BYMONTH\", this.last.month) && this.check_contract_restriction(\"BYYEARDAY\", doy);\n    },\n    setup_defaults: function setup_defaults(aRuleType, req, deftime) {\n      var indexMapValue = icalrecur_iterator._indexMap[aRuleType];\n      var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];\n      if (ruleMapValue != icalrecur_iterator.CONTRACT) {\n        if (!(aRuleType in this.by_data)) {\n          this.by_data[aRuleType] = [deftime];\n        }\n        if (this.rule.freq != req) {\n          return this.by_data[aRuleType][0];\n        }\n      }\n      return deftime;\n    },\n    /**\n     * Convert iterator into a serialize-able object.  Will preserve current\n     * iteration sequence to ensure the seamless continuation of the recurrence\n     * rule.\n     * @return {Object}\n     */\n    toJSON: function () {\n      var result = Object.create(null);\n      result.initialized = this.initialized;\n      result.rule = this.rule.toJSON();\n      result.dtstart = this.dtstart.toJSON();\n      result.by_data = this.by_data;\n      result.days = this.days;\n      result.last = this.last.toJSON();\n      result.by_indices = this.by_indices;\n      result.occurrence_number = this.occurrence_number;\n      return result;\n    }\n  };\n  icalrecur_iterator._indexMap = {\n    \"BYSECOND\": 0,\n    \"BYMINUTE\": 1,\n    \"BYHOUR\": 2,\n    \"BYDAY\": 3,\n    \"BYMONTHDAY\": 4,\n    \"BYYEARDAY\": 5,\n    \"BYWEEKNO\": 6,\n    \"BYMONTH\": 7,\n    \"BYSETPOS\": 8\n  };\n  icalrecur_iterator._expandMap = {\n    \"SECONDLY\": [1, 1, 1, 1, 1, 1, 1, 1],\n    \"MINUTELY\": [2, 1, 1, 1, 1, 1, 1, 1],\n    \"HOURLY\": [2, 2, 1, 1, 1, 1, 1, 1],\n    \"DAILY\": [2, 2, 2, 1, 1, 1, 1, 1],\n    \"WEEKLY\": [2, 2, 2, 2, 3, 3, 1, 1],\n    \"MONTHLY\": [2, 2, 2, 2, 2, 3, 3, 1],\n    \"YEARLY\": [2, 2, 2, 2, 2, 2, 2, 2]\n  };\n  icalrecur_iterator.UNKNOWN = 0;\n  icalrecur_iterator.CONTRACT = 1;\n  icalrecur_iterator.EXPAND = 2;\n  icalrecur_iterator.ILLEGAL = 3;\n  return icalrecur_iterator;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.RecurExpansion = function () {\n  function formatTime(item) {\n    return ICAL.helpers.formatClassType(item, ICAL.Time);\n  }\n  function compareTime(a, b) {\n    return a.compare(b);\n  }\n  function isRecurringComponent(comp) {\n    return comp.hasProperty('rdate') || comp.hasProperty('rrule') || comp.hasProperty('recurrence-id');\n  }\n\n  /**\n   * @classdesc\n   * Primary class for expanding recurring rules.  Can take multiple rrules,\n   * rdates, exdate(s) and iterate (in order) over each next occurrence.\n   *\n   * Once initialized this class can also be serialized saved and continue\n   * iteration from the last point.\n   *\n   * NOTE: it is intended that this class is to be used\n   *       with ICAL.Event which handles recurrence exceptions.\n   *\n   * @example\n   * // assuming event is a parsed ical component\n   * var event;\n   *\n   * var expand = new ICAL.RecurExpansion({\n   *   component: event,\n   *   dtstart: event.getFirstPropertyValue('dtstart')\n   * });\n   *\n   * // remember there are infinite rules\n   * // so it is a good idea to limit the scope\n   * // of the iterations then resume later on.\n   *\n   * // next is always an ICAL.Time or null\n   * var next;\n   *\n   * while (someCondition && (next = expand.next())) {\n   *   // do something with next\n   * }\n   *\n   * // save instance for later\n   * var json = JSON.stringify(expand);\n   *\n   * //...\n   *\n   * // NOTE: if the component's properties have\n   * //       changed you will need to rebuild the\n   * //       class and start over. This only works\n   * //       when the component's recurrence info is the same.\n   * var expand = new ICAL.RecurExpansion(JSON.parse(json));\n   *\n   * @description\n   * The options object can be filled with the specified initial values. It can\n   * also contain additional members, as a result of serializing a previous\n   * expansion state, as shown in the example.\n   *\n   * @class\n   * @alias ICAL.RecurExpansion\n   * @param {Object} options\n   *        Recurrence expansion options\n   * @param {ICAL.Time} options.dtstart\n   *        Start time of the event\n   * @param {ICAL.Component=} options.component\n   *        Component for expansion, required if not resuming.\n   */\n  function RecurExpansion(options) {\n    this.ruleDates = [];\n    this.exDates = [];\n    this.fromData(options);\n  }\n  RecurExpansion.prototype = {\n    /**\n     * True when iteration is fully completed.\n     * @type {Boolean}\n     */\n    complete: false,\n    /**\n     * Array of rrule iterators.\n     *\n     * @type {ICAL.RecurIterator[]}\n     * @private\n     */\n    ruleIterators: null,\n    /**\n     * Array of rdate instances.\n     *\n     * @type {ICAL.Time[]}\n     * @private\n     */\n    ruleDates: null,\n    /**\n     * Array of exdate instances.\n     *\n     * @type {ICAL.Time[]}\n     * @private\n     */\n    exDates: null,\n    /**\n     * Current position in ruleDates array.\n     * @type {Number}\n     * @private\n     */\n    ruleDateInc: 0,\n    /**\n     * Current position in exDates array\n     * @type {Number}\n     * @private\n     */\n    exDateInc: 0,\n    /**\n     * Current negative date.\n     *\n     * @type {ICAL.Time}\n     * @private\n     */\n    exDate: null,\n    /**\n     * Current additional date.\n     *\n     * @type {ICAL.Time}\n     * @private\n     */\n    ruleDate: null,\n    /**\n     * Start date of recurring rules.\n     *\n     * @type {ICAL.Time}\n     */\n    dtstart: null,\n    /**\n     * Last expanded time\n     *\n     * @type {ICAL.Time}\n     */\n    last: null,\n    /**\n     * Initialize the recurrence expansion from the data object. The options\n     * object may also contain additional members, see the\n     * {@link ICAL.RecurExpansion constructor} for more details.\n     *\n     * @param {Object} options\n     *        Recurrence expansion options\n     * @param {ICAL.Time} options.dtstart\n     *        Start time of the event\n     * @param {ICAL.Component=} options.component\n     *        Component for expansion, required if not resuming.\n     */\n    fromData: function (options) {\n      var start = ICAL.helpers.formatClassType(options.dtstart, ICAL.Time);\n      if (!start) {\n        throw new Error('.dtstart (ICAL.Time) must be given');\n      } else {\n        this.dtstart = start;\n      }\n      if (options.component) {\n        this._init(options.component);\n      } else {\n        this.last = formatTime(options.last) || start.clone();\n        if (!options.ruleIterators) {\n          throw new Error('.ruleIterators or .component must be given');\n        }\n        this.ruleIterators = options.ruleIterators.map(function (item) {\n          return ICAL.helpers.formatClassType(item, ICAL.RecurIterator);\n        });\n        this.ruleDateInc = options.ruleDateInc;\n        this.exDateInc = options.exDateInc;\n        if (options.ruleDates) {\n          this.ruleDates = options.ruleDates.map(formatTime);\n          this.ruleDate = this.ruleDates[this.ruleDateInc];\n        }\n        if (options.exDates) {\n          this.exDates = options.exDates.map(formatTime);\n          this.exDate = this.exDates[this.exDateInc];\n        }\n        if (typeof options.complete !== 'undefined') {\n          this.complete = options.complete;\n        }\n      }\n    },\n    /**\n     * Retrieve the next occurrence in the series.\n     * @return {ICAL.Time}\n     */\n    next: function () {\n      var iter;\n      var ruleOfDay;\n      var next;\n      var compare;\n      var maxTries = 500;\n      var currentTry = 0;\n      while (true) {\n        if (currentTry++ > maxTries) {\n          throw new Error('max tries have occured, rule may be impossible to forfill.');\n        }\n        next = this.ruleDate;\n        iter = this._nextRecurrenceIter(this.last);\n\n        // no more matches\n        // because we increment the rule day or rule\n        // _after_ we choose a value this should be\n        // the only spot where we need to worry about the\n        // end of events.\n        if (!next && !iter) {\n          // there are no more iterators or rdates\n          this.complete = true;\n          break;\n        }\n\n        // no next rule day or recurrence rule is first.\n        if (!next || iter && next.compare(iter.last) > 0) {\n          // must be cloned, recur will reuse the time element.\n          next = iter.last.clone();\n          // move to next so we can continue\n          iter.next();\n        }\n\n        // if the ruleDate is still next increment it.\n        if (this.ruleDate === next) {\n          this._nextRuleDay();\n        }\n        this.last = next;\n\n        // check the negative rules\n        if (this.exDate) {\n          compare = this.exDate.compare(this.last);\n          if (compare < 0) {\n            this._nextExDay();\n          }\n\n          // if the current rule is excluded skip it.\n          if (compare === 0) {\n            this._nextExDay();\n            continue;\n          }\n        }\n\n        //XXX: The spec states that after we resolve the final\n        //     list of dates we execute exdate this seems somewhat counter\n        //     intuitive to what I have seen most servers do so for now\n        //     I exclude based on the original date not the one that may\n        //     have been modified by the exception.\n        return this.last;\n      }\n    },\n    /**\n     * Converts object into a serialize-able format. This format can be passed\n     * back into the expansion to resume iteration.\n     * @return {Object}\n     */\n    toJSON: function () {\n      function toJSON(item) {\n        return item.toJSON();\n      }\n      var result = Object.create(null);\n      result.ruleIterators = this.ruleIterators.map(toJSON);\n      if (this.ruleDates) {\n        result.ruleDates = this.ruleDates.map(toJSON);\n      }\n      if (this.exDates) {\n        result.exDates = this.exDates.map(toJSON);\n      }\n      result.ruleDateInc = this.ruleDateInc;\n      result.exDateInc = this.exDateInc;\n      result.last = this.last.toJSON();\n      result.dtstart = this.dtstart.toJSON();\n      result.complete = this.complete;\n      return result;\n    },\n    /**\n     * Extract all dates from the properties in the given component. The\n     * properties will be filtered by the property name.\n     *\n     * @private\n     * @param {ICAL.Component} component        The component to search in\n     * @param {String} propertyName             The property name to search for\n     * @return {ICAL.Time[]}                    The extracted dates.\n     */\n    _extractDates: function (component, propertyName) {\n      function handleProp(prop) {\n        idx = ICAL.helpers.binsearchInsert(result, prop, compareTime);\n\n        // ordered insert\n        result.splice(idx, 0, prop);\n      }\n      var result = [];\n      var props = component.getAllProperties(propertyName);\n      var len = props.length;\n      var i = 0;\n      var prop;\n      var idx;\n      for (; i < len; i++) {\n        props[i].getValues().forEach(handleProp);\n      }\n      return result;\n    },\n    /**\n     * Initialize the recurrence expansion.\n     *\n     * @private\n     * @param {ICAL.Component} component    The component to initialize from.\n     */\n    _init: function (component) {\n      this.ruleIterators = [];\n      this.last = this.dtstart.clone();\n\n      // to provide api consistency non-recurring\n      // events can also use the iterator though it will\n      // only return a single time.\n      if (!isRecurringComponent(component)) {\n        this.ruleDate = this.last.clone();\n        this.complete = true;\n        return;\n      }\n      if (component.hasProperty('rdate')) {\n        this.ruleDates = this._extractDates(component, 'rdate');\n\n        // special hack for cases where first rdate is prior\n        // to the start date. We only check for the first rdate.\n        // This is mostly for google's crazy recurring date logic\n        // (contacts birthdays).\n        if (this.ruleDates[0] && this.ruleDates[0].compare(this.dtstart) < 0) {\n          this.ruleDateInc = 0;\n          this.last = this.ruleDates[0].clone();\n        } else {\n          this.ruleDateInc = ICAL.helpers.binsearchInsert(this.ruleDates, this.last, compareTime);\n        }\n        this.ruleDate = this.ruleDates[this.ruleDateInc];\n      }\n      if (component.hasProperty('rrule')) {\n        var rules = component.getAllProperties('rrule');\n        var i = 0;\n        var len = rules.length;\n        var rule;\n        var iter;\n        for (; i < len; i++) {\n          rule = rules[i].getFirstValue();\n          iter = rule.iterator(this.dtstart);\n          this.ruleIterators.push(iter);\n\n          // increment to the next occurrence so future\n          // calls to next return times beyond the initial iteration.\n          // XXX: I find this suspicious might be a bug?\n          iter.next();\n        }\n      }\n      if (component.hasProperty('exdate')) {\n        this.exDates = this._extractDates(component, 'exdate');\n        // if we have a .last day we increment the index to beyond it.\n        this.exDateInc = ICAL.helpers.binsearchInsert(this.exDates, this.last, compareTime);\n        this.exDate = this.exDates[this.exDateInc];\n      }\n    },\n    /**\n     * Advance to the next exdate\n     * @private\n     */\n    _nextExDay: function () {\n      this.exDate = this.exDates[++this.exDateInc];\n    },\n    /**\n     * Advance to the next rule date\n     * @private\n     */\n    _nextRuleDay: function () {\n      this.ruleDate = this.ruleDates[++this.ruleDateInc];\n    },\n    /**\n     * Find and return the recurrence rule with the most recent event and\n     * return it.\n     *\n     * @private\n     * @return {?ICAL.RecurIterator}    Found iterator.\n     */\n    _nextRecurrenceIter: function () {\n      var iters = this.ruleIterators;\n      if (iters.length === 0) {\n        return null;\n      }\n      var len = iters.length;\n      var iter;\n      var iterTime;\n      var iterIdx = 0;\n      var chosenIter;\n\n      // loop through each iterator\n      for (; iterIdx < len; iterIdx++) {\n        iter = iters[iterIdx];\n        iterTime = iter.last;\n\n        // if iteration is complete\n        // then we must exclude it from\n        // the search and remove it.\n        if (iter.completed) {\n          len--;\n          if (iterIdx !== 0) {\n            iterIdx--;\n          }\n          iters.splice(iterIdx, 1);\n          continue;\n        }\n\n        // find the most recent possible choice\n        if (!chosenIter || chosenIter.last.compare(iterTime) > 0) {\n          // that iterator is saved\n          chosenIter = iter;\n        }\n      }\n\n      // the chosen iterator is returned but not mutated\n      // this iterator contains the most recent event.\n      return chosenIter;\n    }\n  };\n  return RecurExpansion;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.Event = function () {\n  /**\n   * @classdesc\n   * ICAL.js is organized into multiple layers. The bottom layer is a raw jCal\n   * object, followed by the component/property layer. The highest level is the\n   * event representation, which this class is part of. See the\n   * {@tutorial layers} guide for more details.\n   *\n   * @class\n   * @alias ICAL.Event\n   * @param {ICAL.Component=} component         The ICAL.Component to base this event on\n   * @param {Object} options                    Options for this event\n   * @param {Boolean} options.strictExceptions\n   *          When true, will verify exceptions are related by their UUID\n   * @param {Array<ICAL.Component|ICAL.Event>} options.exceptions\n   *          Exceptions to this event, either as components or events. If not\n   *            specified exceptions will automatically be set in relation of\n   *            component's parent\n   */\n  function Event(component, options) {\n    if (!(component instanceof ICAL.Component)) {\n      options = component;\n      component = null;\n    }\n    if (component) {\n      this.component = component;\n    } else {\n      this.component = new ICAL.Component('vevent');\n    }\n    this._rangeExceptionCache = Object.create(null);\n    this.exceptions = Object.create(null);\n    this.rangeExceptions = [];\n    if (options && options.strictExceptions) {\n      this.strictExceptions = options.strictExceptions;\n    }\n    if (options && options.exceptions) {\n      options.exceptions.forEach(this.relateException, this);\n    } else if (this.component.parent && !this.isRecurrenceException()) {\n      this.component.parent.getAllSubcomponents('vevent').forEach(function (event) {\n        if (event.hasProperty('recurrence-id')) {\n          this.relateException(event);\n        }\n      }, this);\n    }\n  }\n  Event.prototype = {\n    THISANDFUTURE: 'THISANDFUTURE',\n    /**\n     * List of related event exceptions.\n     *\n     * @type {ICAL.Event[]}\n     */\n    exceptions: null,\n    /**\n     * When true, will verify exceptions are related by their UUID.\n     *\n     * @type {Boolean}\n     */\n    strictExceptions: false,\n    /**\n     * Relates a given event exception to this object.  If the given component\n     * does not share the UID of this event it cannot be related and will throw\n     * an exception.\n     *\n     * If this component is an exception it cannot have other exceptions\n     * related to it.\n     *\n     * @param {ICAL.Component|ICAL.Event} obj       Component or event\n     */\n    relateException: function (obj) {\n      if (this.isRecurrenceException()) {\n        throw new Error('cannot relate exception to exceptions');\n      }\n      if (obj instanceof ICAL.Component) {\n        obj = new ICAL.Event(obj);\n      }\n      if (this.strictExceptions && obj.uid !== this.uid) {\n        throw new Error('attempted to relate unrelated exception');\n      }\n      var id = obj.recurrenceId.toString();\n\n      // we don't sort or manage exceptions directly\n      // here the recurrence expander handles that.\n      this.exceptions[id] = obj;\n\n      // index RANGE=THISANDFUTURE exceptions so we can\n      // look them up later in getOccurrenceDetails.\n      if (obj.modifiesFuture()) {\n        var item = [obj.recurrenceId.toUnixTime(), id];\n\n        // we keep them sorted so we can find the nearest\n        // value later on...\n        var idx = ICAL.helpers.binsearchInsert(this.rangeExceptions, item, compareRangeException);\n        this.rangeExceptions.splice(idx, 0, item);\n      }\n    },\n    /**\n     * Checks if this record is an exception and has the RANGE=THISANDFUTURE\n     * value.\n     *\n     * @return {Boolean}        True, when exception is within range\n     */\n    modifiesFuture: function () {\n      if (!this.component.hasProperty('recurrence-id')) {\n        return false;\n      }\n      var range = this.component.getFirstProperty('recurrence-id').getParameter('range');\n      return range === this.THISANDFUTURE;\n    },\n    /**\n     * Finds the range exception nearest to the given date.\n     *\n     * @param {ICAL.Time} time usually an occurrence time of an event\n     * @return {?ICAL.Event} the related event/exception or null\n     */\n    findRangeException: function (time) {\n      if (!this.rangeExceptions.length) {\n        return null;\n      }\n      var utc = time.toUnixTime();\n      var idx = ICAL.helpers.binsearchInsert(this.rangeExceptions, [utc], compareRangeException);\n      idx -= 1;\n\n      // occurs before\n      if (idx < 0) {\n        return null;\n      }\n      var rangeItem = this.rangeExceptions[idx];\n\n      /* istanbul ignore next: sanity check only */\n      if (utc < rangeItem[0]) {\n        return null;\n      }\n      return rangeItem[1];\n    },\n    /**\n     * This object is returned by {@link ICAL.Event#getOccurrenceDetails getOccurrenceDetails}\n     *\n     * @typedef {Object} occurrenceDetails\n     * @memberof ICAL.Event\n     * @property {ICAL.Time} recurrenceId       The passed in recurrence id\n     * @property {ICAL.Event} item              The occurrence\n     * @property {ICAL.Time} startDate          The start of the occurrence\n     * @property {ICAL.Time} endDate            The end of the occurrence\n     */\n\n    /**\n     * Returns the occurrence details based on its start time.  If the\n     * occurrence has an exception will return the details for that exception.\n     *\n     * NOTE: this method is intend to be used in conjunction\n     *       with the {@link ICAL.Event#iterator iterator} method.\n     *\n     * @param {ICAL.Time} occurrence time occurrence\n     * @return {ICAL.Event.occurrenceDetails} Information about the occurrence\n     */\n    getOccurrenceDetails: function (occurrence) {\n      var id = occurrence.toString();\n      var utcId = occurrence.convertToZone(ICAL.Timezone.utcTimezone).toString();\n      var item;\n      var result = {\n        //XXX: Clone?\n        recurrenceId: occurrence\n      };\n      if (id in this.exceptions) {\n        item = result.item = this.exceptions[id];\n        result.startDate = item.startDate;\n        result.endDate = item.endDate;\n        result.item = item;\n      } else if (utcId in this.exceptions) {\n        item = this.exceptions[utcId];\n        result.startDate = item.startDate;\n        result.endDate = item.endDate;\n        result.item = item;\n      } else {\n        // range exceptions (RANGE=THISANDFUTURE) have a\n        // lower priority then direct exceptions but\n        // must be accounted for first. Their item is\n        // always the first exception with the range prop.\n        var rangeExceptionId = this.findRangeException(occurrence);\n        var end;\n        if (rangeExceptionId) {\n          var exception = this.exceptions[rangeExceptionId];\n\n          // range exception must modify standard time\n          // by the difference (if any) in start/end times.\n          result.item = exception;\n          var startDiff = this._rangeExceptionCache[rangeExceptionId];\n          if (!startDiff) {\n            var original = exception.recurrenceId.clone();\n            var newStart = exception.startDate.clone();\n\n            // zones must be same otherwise subtract may be incorrect.\n            original.zone = newStart.zone;\n            startDiff = newStart.subtractDate(original);\n            this._rangeExceptionCache[rangeExceptionId] = startDiff;\n          }\n          var start = occurrence.clone();\n          start.zone = exception.startDate.zone;\n          start.addDuration(startDiff);\n          end = start.clone();\n          end.addDuration(exception.duration);\n          result.startDate = start;\n          result.endDate = end;\n        } else {\n          // no range exception standard expansion\n          end = occurrence.clone();\n          end.addDuration(this.duration);\n          result.endDate = end;\n          result.startDate = occurrence;\n          result.item = this;\n        }\n      }\n      return result;\n    },\n    /**\n     * Builds a recur expansion instance for a specific point in time (defaults\n     * to startDate).\n     *\n     * @param {ICAL.Time} startTime     Starting point for expansion\n     * @return {ICAL.RecurExpansion}    Expansion object\n     */\n    iterator: function (startTime) {\n      return new ICAL.RecurExpansion({\n        component: this.component,\n        dtstart: startTime || this.startDate\n      });\n    },\n    /**\n     * Checks if the event is recurring\n     *\n     * @return {Boolean}        True, if event is recurring\n     */\n    isRecurring: function () {\n      var comp = this.component;\n      return comp.hasProperty('rrule') || comp.hasProperty('rdate');\n    },\n    /**\n     * Checks if the event describes a recurrence exception. See\n     * {@tutorial terminology} for details.\n     *\n     * @return {Boolean}    True, if the event describes a recurrence exception\n     */\n    isRecurrenceException: function () {\n      return this.component.hasProperty('recurrence-id');\n    },\n    /**\n     * Returns the types of recurrences this event may have.\n     *\n     * Returned as an object with the following possible keys:\n     *\n     *    - YEARLY\n     *    - MONTHLY\n     *    - WEEKLY\n     *    - DAILY\n     *    - MINUTELY\n     *    - SECONDLY\n     *\n     * @return {Object.<ICAL.Recur.frequencyValues, Boolean>}\n     *          Object of recurrence flags\n     */\n    getRecurrenceTypes: function () {\n      var rules = this.component.getAllProperties('rrule');\n      var i = 0;\n      var len = rules.length;\n      var result = Object.create(null);\n      for (; i < len; i++) {\n        var value = rules[i].getFirstValue();\n        result[value.freq] = true;\n      }\n      return result;\n    },\n    /**\n     * The uid of this event\n     * @type {String}\n     */\n    get uid() {\n      return this._firstProp('uid');\n    },\n    set uid(value) {\n      this._setProp('uid', value);\n    },\n    /**\n     * The start date\n     * @type {ICAL.Time}\n     */\n    get startDate() {\n      return this._firstProp('dtstart');\n    },\n    set startDate(value) {\n      this._setTime('dtstart', value);\n    },\n    /**\n     * The end date. This can be the result directly from the property, or the\n     * end date calculated from start date and duration. Setting the property\n     * will remove any duration properties.\n     * @type {ICAL.Time}\n     */\n    get endDate() {\n      var endDate = this._firstProp('dtend');\n      if (!endDate) {\n        var duration = this._firstProp('duration');\n        endDate = this.startDate.clone();\n        if (duration) {\n          endDate.addDuration(duration);\n        } else if (endDate.isDate) {\n          endDate.day += 1;\n        }\n      }\n      return endDate;\n    },\n    set endDate(value) {\n      if (this.component.hasProperty('duration')) {\n        this.component.removeProperty('duration');\n      }\n      this._setTime('dtend', value);\n    },\n    /**\n     * The duration. This can be the result directly from the property, or the\n     * duration calculated from start date and end date. Setting the property\n     * will remove any `dtend` properties.\n     * @type {ICAL.Duration}\n     */\n    get duration() {\n      var duration = this._firstProp('duration');\n      if (!duration) {\n        return this.endDate.subtractDateTz(this.startDate);\n      }\n      return duration;\n    },\n    set duration(value) {\n      if (this.component.hasProperty('dtend')) {\n        this.component.removeProperty('dtend');\n      }\n      this._setProp('duration', value);\n    },\n    /**\n     * The location of the event.\n     * @type {String}\n     */\n    get location() {\n      return this._firstProp('location');\n    },\n    set location(value) {\n      return this._setProp('location', value);\n    },\n    /**\n     * The attendees in the event\n     * @type {ICAL.Property[]}\n     * @readonly\n     */\n    get attendees() {\n      //XXX: This is way lame we should have a better\n      //     data structure for this later.\n      return this.component.getAllProperties('attendee');\n    },\n    /**\n     * The event summary\n     * @type {String}\n     */\n    get summary() {\n      return this._firstProp('summary');\n    },\n    set summary(value) {\n      this._setProp('summary', value);\n    },\n    /**\n     * The event description.\n     * @type {String}\n     */\n    get description() {\n      return this._firstProp('description');\n    },\n    set description(value) {\n      this._setProp('description', value);\n    },\n    /**\n     * The event color from [rfc7986](https://datatracker.ietf.org/doc/html/rfc7986)\n     * @type {String}\n     */\n    get color() {\n      return this._firstProp('color');\n    },\n    set color(value) {\n      this._setProp('color', value);\n    },\n    /**\n     * The organizer value as an uri. In most cases this is a mailto: uri, but\n     * it can also be something else, like urn:uuid:...\n     * @type {String}\n     */\n    get organizer() {\n      return this._firstProp('organizer');\n    },\n    set organizer(value) {\n      this._setProp('organizer', value);\n    },\n    /**\n     * The sequence value for this event. Used for scheduling\n     * see {@tutorial terminology}.\n     * @type {Number}\n     */\n    get sequence() {\n      return this._firstProp('sequence');\n    },\n    set sequence(value) {\n      this._setProp('sequence', value);\n    },\n    /**\n     * The recurrence id for this event. See {@tutorial terminology} for details.\n     * @type {ICAL.Time}\n     */\n    get recurrenceId() {\n      return this._firstProp('recurrence-id');\n    },\n    set recurrenceId(value) {\n      this._setTime('recurrence-id', value);\n    },\n    /**\n     * Set/update a time property's value.\n     * This will also update the TZID of the property.\n     *\n     * TODO: this method handles the case where we are switching\n     * from a known timezone to an implied timezone (one without TZID).\n     * This does _not_ handle the case of moving between a known\n     *  (by TimezoneService) timezone to an unknown timezone...\n     *\n     * We will not add/remove/update the VTIMEZONE subcomponents\n     *  leading to invalid ICAL data...\n     * @private\n     * @param {String} propName     The property name\n     * @param {ICAL.Time} time      The time to set\n     */\n    _setTime: function (propName, time) {\n      var prop = this.component.getFirstProperty(propName);\n      if (!prop) {\n        prop = new ICAL.Property(propName);\n        this.component.addProperty(prop);\n      }\n\n      // utc and local don't get a tzid\n      if (time.zone === ICAL.Timezone.localTimezone || time.zone === ICAL.Timezone.utcTimezone) {\n        // remove the tzid\n        prop.removeParameter('tzid');\n      } else {\n        prop.setParameter('tzid', time.zone.tzid);\n      }\n      prop.setValue(time);\n    },\n    _setProp: function (name, value) {\n      this.component.updatePropertyWithValue(name, value);\n    },\n    _firstProp: function (name) {\n      return this.component.getFirstPropertyValue(name);\n    },\n    /**\n     * The string representation of this event.\n     * @return {String}\n     */\n    toString: function () {\n      return this.component.toString();\n    }\n  };\n  function compareRangeException(a, b) {\n    if (a[0] > b[0]) return 1;\n    if (b[0] > a[0]) return -1;\n    return 0;\n  }\n  return Event;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.ComponentParser = function () {\n  /**\n   * @classdesc\n   * The ComponentParser is used to process a String or jCal Object,\n   * firing callbacks for various found components, as well as completion.\n   *\n   * @example\n   * var options = {\n   *   // when false no events will be emitted for type\n   *   parseEvent: true,\n   *   parseTimezone: true\n   * };\n   *\n   * var parser = new ICAL.ComponentParser(options);\n   *\n   * parser.onevent(eventComponent) {\n   *   //...\n   * }\n   *\n   * // ontimezone, etc...\n   *\n   * parser.oncomplete = function() {\n   *\n   * };\n   *\n   * parser.process(stringOrComponent);\n   *\n   * @class\n   * @alias ICAL.ComponentParser\n   * @param {Object=} options        Component parser options\n   * @param {Boolean} options.parseEvent        Whether events should be parsed\n   * @param {Boolean} options.parseTimezeone    Whether timezones should be parsed\n   */\n  function ComponentParser(options) {\n    if (typeof options === 'undefined') {\n      options = {};\n    }\n    var key;\n    for (key in options) {\n      /* istanbul ignore else */\n      if (options.hasOwnProperty(key)) {\n        this[key] = options[key];\n      }\n    }\n  }\n  ComponentParser.prototype = {\n    /**\n     * When true, parse events\n     *\n     * @type {Boolean}\n     */\n    parseEvent: true,\n    /**\n     * When true, parse timezones\n     *\n     * @type {Boolean}\n     */\n    parseTimezone: true,\n    /* SAX like events here for reference */\n\n    /**\n     * Fired when parsing is complete\n     * @callback\n     */\n    oncomplete: /* istanbul ignore next */function () {},\n    /**\n     * Fired if an error occurs during parsing.\n     *\n     * @callback\n     * @param {Error} err details of error\n     */\n    onerror: /* istanbul ignore next */function (err) {},\n    /**\n     * Fired when a top level component (VTIMEZONE) is found\n     *\n     * @callback\n     * @param {ICAL.Timezone} component     Timezone object\n     */\n    ontimezone: /* istanbul ignore next */function (component) {},\n    /**\n     * Fired when a top level component (VEVENT) is found.\n     *\n     * @callback\n     * @param {ICAL.Event} component    Top level component\n     */\n    onevent: /* istanbul ignore next */function (component) {},\n    /**\n     * Process a string or parse ical object.  This function itself will return\n     * nothing but will start the parsing process.\n     *\n     * Events must be registered prior to calling this method.\n     *\n     * @param {ICAL.Component|String|Object} ical      The component to process,\n     *        either in its final form, as a jCal Object, or string representation\n     */\n    process: function (ical) {\n      //TODO: this is sync now in the future we will have a incremental parser.\n      if (typeof ical === 'string') {\n        ical = ICAL.parse(ical);\n      }\n      if (!(ical instanceof ICAL.Component)) {\n        ical = new ICAL.Component(ical);\n      }\n      var components = ical.getAllSubcomponents();\n      var i = 0;\n      var len = components.length;\n      var component;\n      for (; i < len; i++) {\n        component = components[i];\n        switch (component.name) {\n          case 'vtimezone':\n            if (this.parseTimezone) {\n              var tzid = component.getFirstPropertyValue('tzid');\n              if (tzid) {\n                this.ontimezone(new ICAL.Timezone({\n                  tzid: tzid,\n                  component: component\n                }));\n              }\n            }\n            break;\n          case 'vevent':\n            if (this.parseEvent) {\n              this.onevent(new ICAL.Event(component));\n            }\n            break;\n          default:\n            continue;\n        }\n      }\n\n      //XXX: ideally we should do a \"nextTick\" here\n      //     so in all cases this is actually async.\n      this.oncomplete();\n    }\n  };\n  return ComponentParser;\n}();","map":{"version":3,"names":["ICAL","module","exports","HTMLScriptElement","prototype","window","foldLength","newLineChar","helpers","updateTimezones","vcal","allsubs","properties","vtimezones","reqTzid","i","tzid","name","getAllSubcomponents","length","getFirstProperty","getFirstValue","concat","getAllProperties","getParameter","hasOwnProperty","removeSubcomponent","TimezoneService","has","addSubcomponent","get","component","isStrictlyNaN","number","isNaN","strictParseInt","string","result","parseInt","Error","formatClassType","data","type","undefined","unescapedIndexOf","buffer","search","pos","indexOf","binsearchInsert","list","seekVal","cmpfunc","low","high","mid","cmpval","Math","floor","dumpn","debug","console","consoleDumpn","input","log","geckoDumpn","dump","arguments","clone","aSrc","aDeep","Date","getTime","Array","isArray","arr","push","obj","Object","call","foldline","aLine","line","line_length","cp","codePointAt","substring","substr","pad2","pad","String","len","trunc","ceil","inherits","base","child","extra","F","extend","source","target","key","descr","getOwnPropertyDescriptor","defineProperty","design","FROM_ICAL_NEWLINE","TO_ICAL_NEWLINE","FROM_VCARD_NEWLINE","TO_VCARD_NEWLINE","createTextType","fromNewline","toNewline","matches","fromICAL","aValue","structuredEscape","replaceNewline","toICAL","regEx","RegExp","replace","str","DEFAULT_TYPE_TEXT","defaultType","DEFAULT_TYPE_TEXT_MULTI","multiValue","DEFAULT_TYPE_TEXT_STRUCTURED","structuredValue","DEFAULT_TYPE_INTEGER","DEFAULT_TYPE_DATETIME_DATE","allowedTypes","DEFAULT_TYPE_DATETIME","DEFAULT_TYPE_URI","DEFAULT_TYPE_UTCOFFSET","DEFAULT_TYPE_RECUR","DEFAULT_TYPE_DATE_ANDOR_TIME","replaceNewlineReplace","value","newline","commonProperties","commonValues","values","float","parsed","parseFloat","integer","decorate","UtcOffset","fromString","undecorate","toString","icalParams","allowXName","allowIanaToken","valueType","multiValueSeparateDQuote","icalValues","text","uri","aString","Binary","aBinary","aProp","strict","Time","fromDateString","date","fromDateTimeString","duration","Duration","period","parts","split","isValueString","join","Period","fromJSON","toJSON","recur","Recur","_stringToData","k","val","numericDayToIcalDay","toUpperCase","fromData","aRecur","time","icalProperties","detectType","vcardValues","VCardTime","fromDateAndOrTimeString","splitzone","_splitZone","zone","isFromIcal","lastChar","signChar","sign","timestamp","vcardParams","vcardProperties","vcard3Values","binary","vcard","vcard3Params","vcard3Properties","fn","n","nickname","photo","bday","adr","label","tel","email","mailer","tz","geo","title","role","logo","agent","org","note","prodid","rev","sound","class","icalSet","param","property","vcardSet","vcard3Set","defaultSet","components","vcard3","vevent","vtodo","vjournal","valarm","vtimezone","daylight","standard","icalendar","getDesignSet","componentName","isInDesign","stringify","LINE_ENDING","DEFAULT_VALUE_TYPE","jCal","designSet","props","propIdx","propLen","designSetName","comps","compIdx","compLen","noFold","jsName","params","paramName","map","_rfc6868Unescape","propertyValue","propDetails","isDefault","slice","delim","innerMulti","x","RFC6868_REPLACE_MAP","parse","CHAR","MULTIVALUE_DELIMITER","VALUE_DELIMITER","PARAM_DELIMITER","PARAM_NAME_DELIMITER","DEFAULT_PARAM_TYPE","ParserError","message","e","stack","shift","parser","state","root","_eachLine","err","_handleContentLine","valuePos","paramPos","lastParamIndex","lastValuePos","parsedParams","toLowerCase","_parseParameters","newComponent","pop","propertyDetails","_parseMultiValue","_parseValue","start","lastParam","lcname","mvdelim","_rfc6868Escape","nextChar","extendedValue","nextPos","propValuePos","delimiter","lastPos","callback","firstChar","newlineOffset","trim","Component","PROPERTY_INDEX","COMPONENT_INDEX","NAME_INDEX","parent","_hydratedPropertyCount","_hydratedComponentCount","_designSet","parentDesign","_hydrateComponent","index","_components","comp","_hydrateProperty","_properties","prop","Property","getFirstSubcomponent","jCalLen","hasProperty","getFirstPropertyValue","_removeObjectByIndex","jCalIndex","cache","splice","_removeObject","nameOrObject","objects","cached","_removeAllObjects","idx","nameOrComp","removed","removeAllSubcomponents","addProperty","TypeError","removeProperty","addPropertyWithValue","setValue","updatePropertyWithValue","nameOrProp","removeAllProperties","PROP_INDEX","TYPE_INDEX","VALUE_INDEX","_parent","getDefaultType","_updateType","p","designSetChanged","designType","isDecorated","isMultiValue","isStructuredValue","_hydrateValue","_values","_decorate","_undecorate","_setDecoratedValue","getFirstParameter","parameters","setParameter","removeParameter","details","resetType","removeAllValues","getValues","setValues","icaltype","toICALString","aData","hours","minutes","factor","fromSeconds","toSeconds","_normalize","aSeconds","secs","abs","compare","icaltime_compare","other","a","b","options","instance","decodeValue","_b64_decode","setEncodedValue","_b64_encode","base64_encode","b64","o1","o2","o3","h1","h2","h3","h4","bits","ac","enc","tmp_arr","charCodeAt","charAt","r","base64_decode","dec","fromCharCode","icalperiod","wrappedJSObject","end","icalclass","getDuration","subtractDate","getEnd","addDuration","aLenient","fromDateOrDateTimeString","DURATION_LETTERS","icalduration","weeks","days","seconds","isNegative","propsToCopy","reset","aOther","thisSeconds","otherSeconds","normalize","icalduration_from_seconds","parseDurationChunk","letter","object","num","icalduration_from_string","aStr","dict","create","chunks","numeric","icalduration_from_data","OPTIONS","Timezone","icaltimezone","location","tznames","latitude","longitude","expandedUntilYear","changes","utcOffset","tt","utcTimezone","localTimezone","_ensureCoverage","year","tt_change","month","day","hour","minute","second","change_num","_findNearbyChange","change_num_to_use","step","change","prevUtcOffset","adjust_change","cmp","_compare_change_fn","zone_change","utcOffset_change","tmp_change","prev_zone_change","want_daylight","is_daylight","icaltimezone_find_nearby_change","aYear","_minimumExpansionYear","today","now","changesEndYear","EXTRA_COVERAGE","MAX_YEAR","subcomps","_expandComponent","sort","aComponent","dtstart","convert_tzoffset","offset","init_changes","changebase","rdatekey","rdate","isDate","rrule","until","adjust","iterator","occ","next","icaltimezone_compare_change_fn","convert_time","icaltimezone_convert_time","from_zone","to_zone","icaltimezone_fromData","icaltimezone_adjust_change","zones","count","keys","utc","Z","UTC","GMT","register","timezone","remove","icaltime","_time","_dowCache","_wnCache","_cachedUnixTime","_pendingNormalization","icaltime_reset","epochTime","resetTo","icaltime_resetTo","fromJSDate","icaltime_fromJSDate","aDate","useUTC","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","aZone","dayOfWeek","icaltime_dayOfWeek","aWeekStart","firstDow","SUNDAY","dowCacheKey","q","m","Y","h","dayOfYear","is_leap","isLeapYear","diypm","daysInYearPassedMonth","startOfWeek","endOfWeek","startOfMonth","endOfMonth","daysInMonth","startOfYear","endOfYear","startDoyWeek","aFirstDayOfWeek","delta","getDominicalLetter","nthWeekDay","icaltime_nthWeekDay","aDayOfWeek","aPos","weekday","otherDay","startDow","endDow","isNthWeekDay","dow","weekNumber","wnCacheKey","week1","dt","isoyear","weekOneStarts","daysBetween","answer","icaltime_add","aDuration","mult","icaltime_subtract","unixTime","toUnixTime","subtractDateTz","icaltime_subtract_abs","compareDateOnlyTz","icaltime_compareDateOnlyTz","attr","_cmp_attr","convertToZone","rc","copy","zone_equals","utc_offset","toJSDate","icaltime_normalize","icaltime_adjust","aExtraDays","aExtraHours","aExtraMinutes","aExtraSeconds","aTime","minutesOverflow","hoursOverflow","daysOverflow","yearsOverflow","fromUnixTime","epoch","ms","setupNormalizeAttributes","defineAttr","getTimeAttr","set","setTimeAttr","icaltime_daysInMonth","_daysInMonth","fromDayOfYear","icaltime_fromDayOfYear","aDayOfYear","doy","auto_normalize","fromStringv2","aProperty","t","icaltime_now","wkst","DEFAULT_WEEK_START","THURSDAY","yr","LTRS","dom","isLeap","MONDAY","TUESDAY","WEDNESDAY","FRIDAY","SATURDAY","apply","p2","y","d","mm","s","hasYear","hasMonth","hasDay","hasHour","hasMinute","hasSecond","datepart","timepart","aIcalType","part","v","tmz","tm","stoi","dtlen","tmlen","hasDashDate","hasDashTime","o","DOW_MAP","SU","MO","TU","WE","TH","FR","SA","REVERSE_DOW_MAP","COPY_PARTS","icalrecur","interval","freq","aStart","RecurIterator","rule","isFinite","isfinite","isByCount","isbycount","addComponent","addPart","aType","ucname","setComponent","aValues","getComponent","getNextOccurrence","aStartTime","aRecurrenceId","iter","cdt","uckey","partDesign","optionDesign","INTERVAL","icalDayToNumericDay","res","kparts","icalrecur_toString","parseNumericValue","min","max","toNumericDay","toIcalDay","VALID_DAY_NAMES","VALID_BYDAY_PART","ALLOWED_FREQ","FREQ","fmtIcal","COUNT","UNTIL","WKST","test","BYSECOND","bind","BYMINUTE","BYHOUR","BYDAY","BYMONTHDAY","BYYEARDAY","BYWEEKNO","BYMONTH","BYSETPOS","partArr","partArrIdx","partArrLen","icalrecur_iterator","completed","last","occurrence_number","by_indices","initialized","by_data","days_index","init","icalrecur_iterator_init","sort_byday_rules","setup_defaults","bydayParts","ruleDayOfWeek","wkdy","dayName","expand_year_days","increment_year","_nextByYearDay","has_by_data","tempLast","initLast","dayOfMonth","increment_month","_byDayAndMonthDay","icalrecur_iterator_next","before","valid","next_second","next_minute","next_hour","next_day","next_week","next_month","next_year","check_contracting_rules","next_generic","increment_second","inc","increment_generic","increment_minute","increment_hour","has_by_day","this_freq","increment_monthday","end_of_data","next_weekday_by_week","week_no","normalizeByMonthDayRules","rules","newRules","ruleIdx","isInit","byMonthDay","byDay","dateIdx","dateLen","dayLen","dataIsValid","self","lastDay","initMonth","nextMonth","monthsCounter","dayIdx","data_valid","setpos","setpos_total","last_day","is_day_in_byday","check_set_position","coded_day","match","aRuleType","aInterval","aDateAttr","aFollowingAttr","aPreviousIncr","has_by_rule","dta","years","aFactor","aNextIncrement","nextunit","validWeeks","monthIdx","first_week","last_week","weekIdx","weekno","partCount","t1","monthkey","t2","monthdaykey","t3","day_","month_","expand_by_day","first_dow","doy_offset","last_dow","set_pos_counter","by_month_day","spIndex","daycodedkey","month_day","first_matching_day","last_matching_day","expandedDays","daykey","days_list","tmp","start_dow","end_dow","end_year_day","tmp_start_doy","first","this_dow","icalrecur_sort_byday_rules","aRules","j","one","two","check_contract_restriction","indexMapValue","_indexMap","ruleMapValue","_expandMap","pass","CONTRACT","ruleType","bydatakey","weekNo","req","deftime","UNKNOWN","EXPAND","ILLEGAL","RecurExpansion","formatTime","item","compareTime","isRecurringComponent","ruleDates","exDates","complete","ruleIterators","ruleDateInc","exDateInc","exDate","ruleDate","_init","ruleOfDay","maxTries","currentTry","_nextRecurrenceIter","_nextRuleDay","_nextExDay","_extractDates","propertyName","handleProp","forEach","iters","iterTime","iterIdx","chosenIter","Event","_rangeExceptionCache","exceptions","rangeExceptions","strictExceptions","relateException","isRecurrenceException","event","THISANDFUTURE","uid","id","recurrenceId","modifiesFuture","compareRangeException","range","findRangeException","rangeItem","getOccurrenceDetails","occurrence","utcId","startDate","endDate","rangeExceptionId","exception","startDiff","original","newStart","startTime","isRecurring","getRecurrenceTypes","_firstProp","_setProp","_setTime","attendees","summary","description","color","organizer","sequence","propName","ComponentParser","parseEvent","parseTimezone","oncomplete","onerror","ontimezone","onevent","process","ical"],"sources":["C:/Users/Amlanjyoti Pegu/Desktop/chat_Web/client/node_modules/ical.js/build/ical.js"],"sourcesContent":["/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2021 */\n\n/* jshint ignore:start */\nvar ICAL;\n(function() {\n  /* istanbul ignore next */\n  if (typeof module === 'object') {\n    // CommonJS, where exports may be different each time.\n    ICAL = module.exports;\n  } else if (typeof HTMLScriptElement !== 'undefined' && 'noModule' in HTMLScriptElement.prototype) {\n    // Until we use ES6 exports, using <script type=\"module\"> we define ICAL on the window global.\n    window.ICAL = ICAL = {};\n  } else if (typeof ICAL !== 'object') {\n    ICAL = {};\n  }\n})();\n/* jshint ignore:end */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * The number of characters before iCalendar line folding should occur\n * @type {Number}\n * @default 75\n */\nICAL.foldLength = 75;\n\n\n/**\n * The character(s) to be used for a newline. The default value is provided by\n * rfc5545.\n * @type {String}\n * @default \"\\r\\n\"\n */\nICAL.newLineChar = '\\r\\n';\n\n\n/**\n * Helper functions used in various places within ical.js\n * @namespace\n */\nICAL.helpers = {\n  /**\n   * Compiles a list of all referenced TZIDs in all subcomponents and\n   * removes any extra VTIMEZONE subcomponents. In addition, if any TZIDs\n   * are referenced by a component, but a VTIMEZONE does not exist,\n   * an attempt will be made to generate a VTIMEZONE using ICAL.TimezoneService.\n   *\n   * @param {ICAL.Component} vcal     The top-level VCALENDAR component.\n   * @return {ICAL.Component}         The ICAL.Component that was passed in.\n   */\n  updateTimezones: function(vcal) {\n    var allsubs, properties, vtimezones, reqTzid, i, tzid;\n\n    if (!vcal || vcal.name !== \"vcalendar\") {\n      //not a top-level vcalendar component\n      return vcal;\n    }\n\n    //Store vtimezone subcomponents in an object reference by tzid.\n    //Store properties from everything else in another array\n    allsubs = vcal.getAllSubcomponents();\n    properties = [];\n    vtimezones = {};\n    for (i = 0; i < allsubs.length; i++) {\n      if (allsubs[i].name === \"vtimezone\") {\n        tzid = allsubs[i].getFirstProperty(\"tzid\").getFirstValue();\n        vtimezones[tzid] = allsubs[i];\n      } else {\n        properties = properties.concat(allsubs[i].getAllProperties());\n      }\n    }\n\n    //create an object with one entry for each required tz\n    reqTzid = {};\n    for (i = 0; i < properties.length; i++) {\n      if ((tzid = properties[i].getParameter(\"tzid\"))) {\n        reqTzid[tzid] = true;\n      }\n    }\n\n    //delete any vtimezones that are not on the reqTzid list.\n    for (i in vtimezones) {\n      if (vtimezones.hasOwnProperty(i) && !reqTzid[i]) {\n        vcal.removeSubcomponent(vtimezones[i]);\n      }\n    }\n\n    //create any missing, but registered timezones\n    for (i in reqTzid) {\n      if (\n        reqTzid.hasOwnProperty(i) &&\n        !vtimezones[i] &&\n        ICAL.TimezoneService.has(i)\n      ) {\n        vcal.addSubcomponent(ICAL.TimezoneService.get(i).component);\n      }\n    }\n\n    return vcal;\n  },\n\n  /**\n   * Checks if the given type is of the number type and also NaN.\n   *\n   * @param {Number} number     The number to check\n   * @return {Boolean}          True, if the number is strictly NaN\n   */\n  isStrictlyNaN: function(number) {\n    return typeof(number) === 'number' && isNaN(number);\n  },\n\n  /**\n   * Parses a string value that is expected to be an integer, when the valid is\n   * not an integer throws a decoration error.\n   *\n   * @param {String} string     Raw string input\n   * @return {Number}           Parsed integer\n   */\n  strictParseInt: function(string) {\n    var result = parseInt(string, 10);\n\n    if (ICAL.helpers.isStrictlyNaN(result)) {\n      throw new Error(\n        'Could not extract integer from \"' + string + '\"'\n      );\n    }\n\n    return result;\n  },\n\n  /**\n   * Creates or returns a class instance of a given type with the initialization\n   * data if the data is not already an instance of the given type.\n   *\n   * @example\n   * var time = new ICAL.Time(...);\n   * var result = ICAL.helpers.formatClassType(time, ICAL.Time);\n   *\n   * (result instanceof ICAL.Time)\n   * // => true\n   *\n   * result = ICAL.helpers.formatClassType({}, ICAL.Time);\n   * (result isntanceof ICAL.Time)\n   * // => true\n   *\n   *\n   * @param {Object} data       object initialization data\n   * @param {Object} type       object type (like ICAL.Time)\n   * @return {?}                An instance of the found type.\n   */\n  formatClassType: function formatClassType(data, type) {\n    if (typeof(data) === 'undefined') {\n      return undefined;\n    }\n\n    if (data instanceof type) {\n      return data;\n    }\n    return new type(data);\n  },\n\n  /**\n   * Identical to indexOf but will only match values when they are not preceded\n   * by a backslash character.\n   *\n   * @param {String} buffer         String to search\n   * @param {String} search         Value to look for\n   * @param {Number} pos            Start position\n   * @return {Number}               The position, or -1 if not found\n   */\n  unescapedIndexOf: function(buffer, search, pos) {\n    while ((pos = buffer.indexOf(search, pos)) !== -1) {\n      if (pos > 0 && buffer[pos - 1] === '\\\\') {\n        pos += 1;\n      } else {\n        return pos;\n      }\n    }\n    return -1;\n  },\n\n  /**\n   * Find the index for insertion using binary search.\n   *\n   * @param {Array} list            The list to search\n   * @param {?} seekVal             The value to insert\n   * @param {function(?,?)} cmpfunc The comparison func, that can\n   *                                  compare two seekVals\n   * @return {Number}               The insert position\n   */\n  binsearchInsert: function(list, seekVal, cmpfunc) {\n    if (!list.length)\n      return 0;\n\n    var low = 0, high = list.length - 1,\n        mid, cmpval;\n\n    while (low <= high) {\n      mid = low + Math.floor((high - low) / 2);\n      cmpval = cmpfunc(seekVal, list[mid]);\n\n      if (cmpval < 0)\n        high = mid - 1;\n      else if (cmpval > 0)\n        low = mid + 1;\n      else\n        break;\n    }\n\n    if (cmpval < 0)\n      return mid; // insertion is displacing, so use mid outright.\n    else if (cmpval > 0)\n      return mid + 1;\n    else\n      return mid;\n  },\n\n  /**\n   * Convenience function for debug output\n   * @private\n   */\n  dumpn: /* istanbul ignore next */ function() {\n    if (!ICAL.debug) {\n      return;\n    }\n\n    if (typeof (console) !== 'undefined' && 'log' in console) {\n      ICAL.helpers.dumpn = function consoleDumpn(input) {\n        console.log(input);\n      };\n    } else {\n      ICAL.helpers.dumpn = function geckoDumpn(input) {\n        dump(input + '\\n');\n      };\n    }\n\n    ICAL.helpers.dumpn(arguments[0]);\n  },\n\n  /**\n   * Clone the passed object or primitive. By default a shallow clone will be\n   * executed.\n   *\n   * @param {*} aSrc            The thing to clone\n   * @param {Boolean=} aDeep    If true, a deep clone will be performed\n   * @return {*}                The copy of the thing\n   */\n  clone: function(aSrc, aDeep) {\n    if (!aSrc || typeof aSrc != \"object\") {\n      return aSrc;\n    } else if (aSrc instanceof Date) {\n      return new Date(aSrc.getTime());\n    } else if (\"clone\" in aSrc) {\n      return aSrc.clone();\n    } else if (Array.isArray(aSrc)) {\n      var arr = [];\n      for (var i = 0; i < aSrc.length; i++) {\n        arr.push(aDeep ? ICAL.helpers.clone(aSrc[i], true) : aSrc[i]);\n      }\n      return arr;\n    } else {\n      var obj = {};\n      for (var name in aSrc) {\n        // uses prototype method to allow use of Object.create(null);\n        /* istanbul ignore else */\n        if (Object.prototype.hasOwnProperty.call(aSrc, name)) {\n          if (aDeep) {\n            obj[name] = ICAL.helpers.clone(aSrc[name], true);\n          } else {\n            obj[name] = aSrc[name];\n          }\n        }\n      }\n      return obj;\n    }\n  },\n\n  /**\n   * Performs iCalendar line folding. A line ending character is inserted and\n   * the next line begins with a whitespace.\n   *\n   * @example\n   * SUMMARY:This line will be fold\n   *  ed right in the middle of a word.\n   *\n   * @param {String} aLine      The line to fold\n   * @return {String}           The folded line\n   */\n  foldline: function foldline(aLine) {\n    var result = \"\";\n    var line = aLine || \"\", pos = 0, line_length = 0;\n    //pos counts position in line for the UTF-16 presentation\n    //line_length counts the bytes for the UTF-8 presentation\n    while (line.length) {\n      var cp = line.codePointAt(pos);\n      if (cp < 128) ++line_length;\n      else if (cp < 2048) line_length += 2;//needs 2 UTF-8 bytes\n      else if (cp < 65536) line_length += 3;\n      else line_length += 4; //cp is less than 1114112\n      if (line_length < ICAL.foldLength + 1)\n        pos += cp > 65535 ? 2 : 1;\n      else {\n        result += ICAL.newLineChar + \" \" + line.substring(0, pos);\n        line = line.substring(pos);\n        pos = line_length = 0;\n      }\n    }\n    return result.substr(ICAL.newLineChar.length + 1);\n  },\n\n  /**\n   * Pads the given string or number with zeros so it will have at least two\n   * characters.\n   *\n   * @param {String|Number} data    The string or number to pad\n   * @return {String}               The number padded as a string\n   */\n  pad2: function pad(data) {\n    if (typeof(data) !== 'string') {\n      // handle fractions.\n      if (typeof(data) === 'number') {\n        data = parseInt(data);\n      }\n      data = String(data);\n    }\n\n    var len = data.length;\n\n    switch (len) {\n      case 0:\n        return '00';\n      case 1:\n        return '0' + data;\n      default:\n        return data;\n    }\n  },\n\n  /**\n   * Truncates the given number, correctly handling negative numbers.\n   *\n   * @param {Number} number     The number to truncate\n   * @return {Number}           The truncated number\n   */\n  trunc: function trunc(number) {\n    return (number < 0 ? Math.ceil(number) : Math.floor(number));\n  },\n\n  /**\n   * Poor-man's cross-browser inheritance for JavaScript. Doesn't support all\n   * the features, but enough for our usage.\n   *\n   * @param {Function} base     The base class constructor function.\n   * @param {Function} child    The child class constructor function.\n   * @param {Object} extra      Extends the prototype with extra properties\n   *                              and methods\n   */\n  inherits: function(base, child, extra) {\n    function F() {}\n    F.prototype = base.prototype;\n    child.prototype = new F();\n\n    if (extra) {\n      ICAL.helpers.extend(extra, child.prototype);\n    }\n  },\n\n  /**\n   * Poor-man's cross-browser object extension. Doesn't support all the\n   * features, but enough for our usage. Note that the target's properties are\n   * not overwritten with the source properties.\n   *\n   * @example\n   * var child = ICAL.helpers.extend(parent, {\n   *   \"bar\": 123\n   * });\n   *\n   * @param {Object} source     The object to extend\n   * @param {Object} target     The object to extend with\n   * @return {Object}           Returns the target.\n   */\n  extend: function(source, target) {\n    for (var key in source) {\n      var descr = Object.getOwnPropertyDescriptor(source, key);\n      if (descr && !Object.getOwnPropertyDescriptor(target, key)) {\n        Object.defineProperty(target, key, descr);\n      }\n    }\n    return target;\n  }\n};\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/** @namespace ICAL */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.design = (function() {\n  'use strict';\n\n  var FROM_ICAL_NEWLINE = /\\\\\\\\|\\\\;|\\\\,|\\\\[Nn]/g;\n  var TO_ICAL_NEWLINE = /\\\\|;|,|\\n/g;\n  var FROM_VCARD_NEWLINE = /\\\\\\\\|\\\\,|\\\\[Nn]/g;\n  var TO_VCARD_NEWLINE = /\\\\|,|\\n/g;\n\n  function createTextType(fromNewline, toNewline) {\n    var result = {\n      matches: /.*/,\n\n      fromICAL: function(aValue, structuredEscape) {\n        return replaceNewline(aValue, fromNewline, structuredEscape);\n      },\n\n      toICAL: function(aValue, structuredEscape) {\n        var regEx = toNewline;\n        if (structuredEscape)\n          regEx = new RegExp(regEx.source + '|' + structuredEscape);\n        return aValue.replace(regEx, function(str) {\n          switch (str) {\n          case \"\\\\\":\n            return \"\\\\\\\\\";\n          case \";\":\n            return \"\\\\;\";\n          case \",\":\n            return \"\\\\,\";\n          case \"\\n\":\n            return \"\\\\n\";\n          /* istanbul ignore next */\n          default:\n            return str;\n          }\n        });\n      }\n    };\n    return result;\n  }\n\n  // default types used multiple times\n  var DEFAULT_TYPE_TEXT = { defaultType: \"text\" };\n  var DEFAULT_TYPE_TEXT_MULTI = { defaultType: \"text\", multiValue: \",\" };\n  var DEFAULT_TYPE_TEXT_STRUCTURED = { defaultType: \"text\", structuredValue: \";\" };\n  var DEFAULT_TYPE_INTEGER = { defaultType: \"integer\" };\n  var DEFAULT_TYPE_DATETIME_DATE = { defaultType: \"date-time\", allowedTypes: [\"date-time\", \"date\"] };\n  var DEFAULT_TYPE_DATETIME = { defaultType: \"date-time\" };\n  var DEFAULT_TYPE_URI = { defaultType: \"uri\" };\n  var DEFAULT_TYPE_UTCOFFSET = { defaultType: \"utc-offset\" };\n  var DEFAULT_TYPE_RECUR = { defaultType: \"recur\" };\n  var DEFAULT_TYPE_DATE_ANDOR_TIME = { defaultType: \"date-and-or-time\", allowedTypes: [\"date-time\", \"date\", \"text\"] };\n\n  function replaceNewlineReplace(string) {\n    switch (string) {\n      case \"\\\\\\\\\":\n        return \"\\\\\";\n      case \"\\\\;\":\n        return \";\";\n      case \"\\\\,\":\n        return \",\";\n      case \"\\\\n\":\n      case \"\\\\N\":\n        return \"\\n\";\n      /* istanbul ignore next */\n      default:\n        return string;\n    }\n  }\n\n  function replaceNewline(value, newline, structuredEscape) {\n    // avoid regex when possible.\n    if (value.indexOf('\\\\') === -1) {\n      return value;\n    }\n    if (structuredEscape)\n      newline = new RegExp(newline.source + '|\\\\\\\\' + structuredEscape);\n    return value.replace(newline, replaceNewlineReplace);\n  }\n\n  var commonProperties = {\n    \"categories\": DEFAULT_TYPE_TEXT_MULTI,\n    \"url\": DEFAULT_TYPE_URI,\n    \"version\": DEFAULT_TYPE_TEXT,\n    \"uid\": DEFAULT_TYPE_TEXT\n  };\n\n  var commonValues = {\n    \"boolean\": {\n      values: [\"TRUE\", \"FALSE\"],\n\n      fromICAL: function(aValue) {\n        switch (aValue) {\n          case 'TRUE':\n            return true;\n          case 'FALSE':\n            return false;\n          default:\n            //TODO: parser warning\n            return false;\n        }\n      },\n\n      toICAL: function(aValue) {\n        if (aValue) {\n          return 'TRUE';\n        }\n        return 'FALSE';\n      }\n\n    },\n    float: {\n      matches: /^[+-]?\\d+\\.\\d+$/,\n\n      fromICAL: function(aValue) {\n        var parsed = parseFloat(aValue);\n        if (ICAL.helpers.isStrictlyNaN(parsed)) {\n          // TODO: parser warning\n          return 0.0;\n        }\n        return parsed;\n      },\n\n      toICAL: function(aValue) {\n        return String(aValue);\n      }\n    },\n    integer: {\n      fromICAL: function(aValue) {\n        var parsed = parseInt(aValue);\n        if (ICAL.helpers.isStrictlyNaN(parsed)) {\n          return 0;\n        }\n        return parsed;\n      },\n\n      toICAL: function(aValue) {\n        return String(aValue);\n      }\n    },\n    \"utc-offset\": {\n      toICAL: function(aValue) {\n        if (aValue.length < 7) {\n          // no seconds\n          // -0500\n          return aValue.substr(0, 3) +\n                 aValue.substr(4, 2);\n        } else {\n          // seconds\n          // -050000\n          return aValue.substr(0, 3) +\n                 aValue.substr(4, 2) +\n                 aValue.substr(7, 2);\n        }\n      },\n\n      fromICAL: function(aValue) {\n        if (aValue.length < 6) {\n          // no seconds\n          // -05:00\n          return aValue.substr(0, 3) + ':' +\n                 aValue.substr(3, 2);\n        } else {\n          // seconds\n          // -05:00:00\n          return aValue.substr(0, 3) + ':' +\n                 aValue.substr(3, 2) + ':' +\n                 aValue.substr(5, 2);\n        }\n      },\n\n      decorate: function(aValue) {\n        return ICAL.UtcOffset.fromString(aValue);\n      },\n\n      undecorate: function(aValue) {\n        return aValue.toString();\n      }\n    }\n  };\n\n  var icalParams = {\n    // Although the syntax is DQUOTE uri DQUOTE, I don't think we should\n    // enfoce anything aside from it being a valid content line.\n    //\n    // At least some params require - if multi values are used - DQUOTEs\n    // for each of its values - e.g. delegated-from=\"uri1\",\"uri2\"\n    // To indicate this, I introduced the new k/v pair\n    // multiValueSeparateDQuote: true\n    //\n    // \"ALTREP\": { ... },\n\n    // CN just wants a param-value\n    // \"CN\": { ... }\n\n    \"cutype\": {\n      values: [\"INDIVIDUAL\", \"GROUP\", \"RESOURCE\", \"ROOM\", \"UNKNOWN\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n\n    \"delegated-from\": {\n      valueType: \"cal-address\",\n      multiValue: \",\",\n      multiValueSeparateDQuote: true\n    },\n    \"delegated-to\": {\n      valueType: \"cal-address\",\n      multiValue: \",\",\n      multiValueSeparateDQuote: true\n    },\n    // \"DIR\": { ... }, // See ALTREP\n    \"encoding\": {\n      values: [\"8BIT\", \"BASE64\"]\n    },\n    // \"FMTTYPE\": { ... }, // See ALTREP\n    \"fbtype\": {\n      values: [\"FREE\", \"BUSY\", \"BUSY-UNAVAILABLE\", \"BUSY-TENTATIVE\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    // \"LANGUAGE\": { ... }, // See ALTREP\n    \"member\": {\n      valueType: \"cal-address\",\n      multiValue: \",\",\n      multiValueSeparateDQuote: true\n    },\n    \"partstat\": {\n      // TODO These values are actually different per-component\n      values: [\"NEEDS-ACTION\", \"ACCEPTED\", \"DECLINED\", \"TENTATIVE\",\n               \"DELEGATED\", \"COMPLETED\", \"IN-PROCESS\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    \"range\": {\n      values: [\"THISANDFUTURE\"]\n    },\n    \"related\": {\n      values: [\"START\", \"END\"]\n    },\n    \"reltype\": {\n      values: [\"PARENT\", \"CHILD\", \"SIBLING\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    \"role\": {\n      values: [\"REQ-PARTICIPANT\", \"CHAIR\",\n               \"OPT-PARTICIPANT\", \"NON-PARTICIPANT\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    \"rsvp\": {\n      values: [\"TRUE\", \"FALSE\"]\n    },\n    \"sent-by\": {\n      valueType: \"cal-address\"\n    },\n    \"tzid\": {\n      matches: /^\\//\n    },\n    \"value\": {\n      // since the value here is a 'type' lowercase is used.\n      values: [\"binary\", \"boolean\", \"cal-address\", \"date\", \"date-time\",\n               \"duration\", \"float\", \"integer\", \"period\", \"recur\", \"text\",\n               \"time\", \"uri\", \"utc-offset\"],\n      allowXName: true,\n      allowIanaToken: true\n    }\n  };\n\n  // When adding a value here, be sure to add it to the parameter types!\n  var icalValues = ICAL.helpers.extend(commonValues, {\n    text: createTextType(FROM_ICAL_NEWLINE, TO_ICAL_NEWLINE),\n\n    uri: {\n      // TODO\n      /* ... */\n    },\n\n    \"binary\": {\n      decorate: function(aString) {\n        return ICAL.Binary.fromString(aString);\n      },\n\n      undecorate: function(aBinary) {\n        return aBinary.toString();\n      }\n    },\n    \"cal-address\": {\n      // needs to be an uri\n    },\n    \"date\": {\n      decorate: function(aValue, aProp) {\n        if (design.strict) {\n          return ICAL.Time.fromDateString(aValue, aProp);\n        } else {\n          return ICAL.Time.fromString(aValue, aProp);\n        }\n      },\n\n      /**\n       * undecorates a time object.\n       */\n      undecorate: function(aValue) {\n        return aValue.toString();\n      },\n\n      fromICAL: function(aValue) {\n        // from: 20120901\n        // to: 2012-09-01\n        if (!design.strict && aValue.length >= 15) {\n          // This is probably a date-time, e.g. 20120901T130000Z\n          return icalValues[\"date-time\"].fromICAL(aValue);\n        } else {\n          return aValue.substr(0, 4) + '-' +\n                 aValue.substr(4, 2) + '-' +\n                 aValue.substr(6, 2);\n        }\n      },\n\n      toICAL: function(aValue) {\n        // from: 2012-09-01\n        // to: 20120901\n        var len = aValue.length;\n\n        if (len == 10) {\n          return aValue.substr(0, 4) +\n                 aValue.substr(5, 2) +\n                 aValue.substr(8, 2);\n        } else if (len >= 19) {\n          return icalValues[\"date-time\"].toICAL(aValue);\n        } else {\n          //TODO: serialize warning?\n          return aValue;\n        }\n\n      }\n    },\n    \"date-time\": {\n      fromICAL: function(aValue) {\n        // from: 20120901T130000\n        // to: 2012-09-01T13:00:00\n        if (!design.strict && aValue.length == 8) {\n          // This is probably a date, e.g. 20120901\n          return icalValues.date.fromICAL(aValue);\n        } else {\n          var result = aValue.substr(0, 4) + '-' +\n                       aValue.substr(4, 2) + '-' +\n                       aValue.substr(6, 2) + 'T' +\n                       aValue.substr(9, 2) + ':' +\n                       aValue.substr(11, 2) + ':' +\n                       aValue.substr(13, 2);\n\n          if (aValue[15] && aValue[15] === 'Z') {\n            result += 'Z';\n          }\n\n          return result;\n        }\n      },\n\n      toICAL: function(aValue) {\n        // from: 2012-09-01T13:00:00\n        // to: 20120901T130000\n        var len = aValue.length;\n\n        if (len == 10 && !design.strict) {\n          return icalValues.date.toICAL(aValue);\n        } else if (len >= 19) {\n          var result = aValue.substr(0, 4) +\n                       aValue.substr(5, 2) +\n                       // grab the (DDTHH) segment\n                       aValue.substr(8, 5) +\n                       // MM\n                       aValue.substr(14, 2) +\n                       // SS\n                       aValue.substr(17, 2);\n\n          if (aValue[19] && aValue[19] === 'Z') {\n            result += 'Z';\n          }\n          return result;\n        } else {\n          // TODO: error\n          return aValue;\n        }\n      },\n\n      decorate: function(aValue, aProp) {\n        if (design.strict) {\n          return ICAL.Time.fromDateTimeString(aValue, aProp);\n        } else {\n          return ICAL.Time.fromString(aValue, aProp);\n        }\n      },\n\n      undecorate: function(aValue) {\n        return aValue.toString();\n      }\n    },\n    duration: {\n      decorate: function(aValue) {\n        return ICAL.Duration.fromString(aValue);\n      },\n      undecorate: function(aValue) {\n        return aValue.toString();\n      }\n    },\n    period: {\n\n      fromICAL: function(string) {\n        var parts = string.split('/');\n        parts[0] = icalValues['date-time'].fromICAL(parts[0]);\n\n        if (!ICAL.Duration.isValueString(parts[1])) {\n          parts[1] = icalValues['date-time'].fromICAL(parts[1]);\n        }\n\n        return parts;\n      },\n\n      toICAL: function(parts) {\n        if (!design.strict && parts[0].length == 10) {\n          parts[0] = icalValues.date.toICAL(parts[0]);\n        } else {\n          parts[0] = icalValues['date-time'].toICAL(parts[0]);\n        }\n\n        if (!ICAL.Duration.isValueString(parts[1])) {\n          if (!design.strict && parts[1].length == 10) {\n            parts[1] = icalValues.date.toICAL(parts[1]);\n          } else {\n            parts[1] = icalValues['date-time'].toICAL(parts[1]);\n          }\n        }\n\n        return parts.join(\"/\");\n      },\n\n      decorate: function(aValue, aProp) {\n        return ICAL.Period.fromJSON(aValue, aProp, !design.strict);\n      },\n\n      undecorate: function(aValue) {\n        return aValue.toJSON();\n      }\n    },\n    recur: {\n      fromICAL: function(string) {\n        return ICAL.Recur._stringToData(string, true);\n      },\n\n      toICAL: function(data) {\n        var str = \"\";\n        for (var k in data) {\n          /* istanbul ignore if */\n          if (!Object.prototype.hasOwnProperty.call(data, k)) {\n            continue;\n          }\n          var val = data[k];\n          if (k == \"until\") {\n            if (val.length > 10) {\n              val = icalValues['date-time'].toICAL(val);\n            } else {\n              val = icalValues.date.toICAL(val);\n            }\n          } else if (k == \"wkst\") {\n            if (typeof val === 'number') {\n              val = ICAL.Recur.numericDayToIcalDay(val);\n            }\n          } else if (Array.isArray(val)) {\n            val = val.join(\",\");\n          }\n          str += k.toUpperCase() + \"=\" + val + \";\";\n        }\n        return str.substr(0, str.length - 1);\n      },\n\n      decorate: function decorate(aValue) {\n        return ICAL.Recur.fromData(aValue);\n      },\n\n      undecorate: function(aRecur) {\n        return aRecur.toJSON();\n      }\n    },\n\n    time: {\n      fromICAL: function(aValue) {\n        // from: MMHHSS(Z)?\n        // to: HH:MM:SS(Z)?\n        if (aValue.length < 6) {\n          // TODO: parser exception?\n          return aValue;\n        }\n\n        // HH::MM::SSZ?\n        var result = aValue.substr(0, 2) + ':' +\n                     aValue.substr(2, 2) + ':' +\n                     aValue.substr(4, 2);\n\n        if (aValue[6] === 'Z') {\n          result += 'Z';\n        }\n\n        return result;\n      },\n\n      toICAL: function(aValue) {\n        // from: HH:MM:SS(Z)?\n        // to: MMHHSS(Z)?\n        if (aValue.length < 8) {\n          //TODO: error\n          return aValue;\n        }\n\n        var result = aValue.substr(0, 2) +\n                     aValue.substr(3, 2) +\n                     aValue.substr(6, 2);\n\n        if (aValue[8] === 'Z') {\n          result += 'Z';\n        }\n\n        return result;\n      }\n    }\n  });\n\n  var icalProperties = ICAL.helpers.extend(commonProperties, {\n\n    \"action\": DEFAULT_TYPE_TEXT,\n    \"attach\": { defaultType: \"uri\" },\n    \"attendee\": { defaultType: \"cal-address\" },\n    \"calscale\": DEFAULT_TYPE_TEXT,\n    \"class\": DEFAULT_TYPE_TEXT,\n    \"comment\": DEFAULT_TYPE_TEXT,\n    \"completed\": DEFAULT_TYPE_DATETIME,\n    \"contact\": DEFAULT_TYPE_TEXT,\n    \"created\": DEFAULT_TYPE_DATETIME,\n    \"description\": DEFAULT_TYPE_TEXT,\n    \"dtend\": DEFAULT_TYPE_DATETIME_DATE,\n    \"dtstamp\": DEFAULT_TYPE_DATETIME,\n    \"dtstart\": DEFAULT_TYPE_DATETIME_DATE,\n    \"due\": DEFAULT_TYPE_DATETIME_DATE,\n    \"duration\": { defaultType: \"duration\" },\n    \"exdate\": {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\"],\n      multiValue: ','\n    },\n    \"exrule\": DEFAULT_TYPE_RECUR,\n    \"freebusy\": { defaultType: \"period\", multiValue: \",\" },\n    \"geo\": { defaultType: \"float\", structuredValue: \";\" },\n    \"last-modified\": DEFAULT_TYPE_DATETIME,\n    \"location\": DEFAULT_TYPE_TEXT,\n    \"method\": DEFAULT_TYPE_TEXT,\n    \"organizer\": { defaultType: \"cal-address\" },\n    \"percent-complete\": DEFAULT_TYPE_INTEGER,\n    \"priority\": DEFAULT_TYPE_INTEGER,\n    \"prodid\": DEFAULT_TYPE_TEXT,\n    \"related-to\": DEFAULT_TYPE_TEXT,\n    \"repeat\": DEFAULT_TYPE_INTEGER,\n    \"rdate\": {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\", \"period\"],\n      multiValue: ',',\n      detectType: function(string) {\n        if (string.indexOf('/') !== -1) {\n          return 'period';\n        }\n        return (string.indexOf('T') === -1) ? 'date' : 'date-time';\n      }\n    },\n    \"recurrence-id\": DEFAULT_TYPE_DATETIME_DATE,\n    \"resources\": DEFAULT_TYPE_TEXT_MULTI,\n    \"request-status\": DEFAULT_TYPE_TEXT_STRUCTURED,\n    \"rrule\": DEFAULT_TYPE_RECUR,\n    \"sequence\": DEFAULT_TYPE_INTEGER,\n    \"status\": DEFAULT_TYPE_TEXT,\n    \"summary\": DEFAULT_TYPE_TEXT,\n    \"transp\": DEFAULT_TYPE_TEXT,\n    \"trigger\": { defaultType: \"duration\", allowedTypes: [\"duration\", \"date-time\"] },\n    \"tzoffsetfrom\": DEFAULT_TYPE_UTCOFFSET,\n    \"tzoffsetto\": DEFAULT_TYPE_UTCOFFSET,\n    \"tzurl\": DEFAULT_TYPE_URI,\n    \"tzid\": DEFAULT_TYPE_TEXT,\n    \"tzname\": DEFAULT_TYPE_TEXT\n  });\n\n  // When adding a value here, be sure to add it to the parameter types!\n  var vcardValues = ICAL.helpers.extend(commonValues, {\n    text: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),\n    uri: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),\n\n    date: {\n      decorate: function(aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(aValue, \"date\");\n      },\n      undecorate: function(aValue) {\n        return aValue.toString();\n      },\n      fromICAL: function(aValue) {\n        if (aValue.length == 8) {\n          return icalValues.date.fromICAL(aValue);\n        } else if (aValue[0] == '-' && aValue.length == 6) {\n          return aValue.substr(0, 4) + '-' + aValue.substr(4);\n        } else {\n          return aValue;\n        }\n      },\n      toICAL: function(aValue) {\n        if (aValue.length == 10) {\n          return icalValues.date.toICAL(aValue);\n        } else if (aValue[0] == '-' && aValue.length == 7) {\n          return aValue.substr(0, 4) + aValue.substr(5);\n        } else {\n          return aValue;\n        }\n      }\n    },\n\n    time: {\n      decorate: function(aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(\"T\" + aValue, \"time\");\n      },\n      undecorate: function(aValue) {\n        return aValue.toString();\n      },\n      fromICAL: function(aValue) {\n        var splitzone = vcardValues.time._splitZone(aValue, true);\n        var zone = splitzone[0], value = splitzone[1];\n\n        //console.log(\"SPLIT: \",splitzone);\n\n        if (value.length == 6) {\n          value = value.substr(0, 2) + ':' +\n                  value.substr(2, 2) + ':' +\n                  value.substr(4, 2);\n        } else if (value.length == 4 && value[0] != '-') {\n          value = value.substr(0, 2) + ':' + value.substr(2, 2);\n        } else if (value.length == 5) {\n          value = value.substr(0, 3) + ':' + value.substr(3, 2);\n        }\n\n        if (zone.length == 5 && (zone[0] == '-' || zone[0] == '+')) {\n          zone = zone.substr(0, 3) + ':' + zone.substr(3);\n        }\n\n        return value + zone;\n      },\n\n      toICAL: function(aValue) {\n        var splitzone = vcardValues.time._splitZone(aValue);\n        var zone = splitzone[0], value = splitzone[1];\n\n        if (value.length == 8) {\n          value = value.substr(0, 2) +\n                  value.substr(3, 2) +\n                  value.substr(6, 2);\n        } else if (value.length == 5 && value[0] != '-') {\n          value = value.substr(0, 2) + value.substr(3, 2);\n        } else if (value.length == 6) {\n          value = value.substr(0, 3) + value.substr(4, 2);\n        }\n\n        if (zone.length == 6 && (zone[0] == '-' || zone[0] == '+')) {\n          zone = zone.substr(0, 3) + zone.substr(4);\n        }\n\n        return value + zone;\n      },\n\n      _splitZone: function(aValue, isFromIcal) {\n        var lastChar = aValue.length - 1;\n        var signChar = aValue.length - (isFromIcal ? 5 : 6);\n        var sign = aValue[signChar];\n        var zone, value;\n\n        if (aValue[lastChar] == 'Z') {\n          zone = aValue[lastChar];\n          value = aValue.substr(0, lastChar);\n        } else if (aValue.length > 6 && (sign == '-' || sign == '+')) {\n          zone = aValue.substr(signChar);\n          value = aValue.substr(0, signChar);\n        } else {\n          zone = \"\";\n          value = aValue;\n        }\n\n        return [zone, value];\n      }\n    },\n\n    \"date-time\": {\n      decorate: function(aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(aValue, \"date-time\");\n      },\n\n      undecorate: function(aValue) {\n        return aValue.toString();\n      },\n\n      fromICAL: function(aValue) {\n        return vcardValues['date-and-or-time'].fromICAL(aValue);\n      },\n\n      toICAL: function(aValue) {\n        return vcardValues['date-and-or-time'].toICAL(aValue);\n      }\n    },\n\n    \"date-and-or-time\": {\n      decorate: function(aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(aValue, \"date-and-or-time\");\n      },\n\n      undecorate: function(aValue) {\n        return aValue.toString();\n      },\n\n      fromICAL: function(aValue) {\n        var parts = aValue.split('T');\n        return (parts[0] ? vcardValues.date.fromICAL(parts[0]) : '') +\n               (parts[1] ? 'T' + vcardValues.time.fromICAL(parts[1]) : '');\n      },\n\n      toICAL: function(aValue) {\n        var parts = aValue.split('T');\n        return vcardValues.date.toICAL(parts[0]) +\n               (parts[1] ? 'T' + vcardValues.time.toICAL(parts[1]) : '');\n\n      }\n    },\n    timestamp: icalValues['date-time'],\n    \"language-tag\": {\n      matches: /^[a-zA-Z0-9-]+$/ // Could go with a more strict regex here\n    }\n  });\n\n  var vcardParams = {\n    \"type\": {\n      valueType: \"text\",\n      multiValue: \",\"\n    },\n    \"value\": {\n      // since the value here is a 'type' lowercase is used.\n      values: [\"text\", \"uri\", \"date\", \"time\", \"date-time\", \"date-and-or-time\",\n               \"timestamp\", \"boolean\", \"integer\", \"float\", \"utc-offset\",\n               \"language-tag\"],\n      allowXName: true,\n      allowIanaToken: true\n    }\n  };\n\n  var vcardProperties = ICAL.helpers.extend(commonProperties, {\n    \"adr\": { defaultType: \"text\", structuredValue: \";\", multiValue: \",\" },\n    \"anniversary\": DEFAULT_TYPE_DATE_ANDOR_TIME,\n    \"bday\": DEFAULT_TYPE_DATE_ANDOR_TIME,\n    \"caladruri\": DEFAULT_TYPE_URI,\n    \"caluri\": DEFAULT_TYPE_URI,\n    \"clientpidmap\": DEFAULT_TYPE_TEXT_STRUCTURED,\n    \"email\": DEFAULT_TYPE_TEXT,\n    \"fburl\": DEFAULT_TYPE_URI,\n    \"fn\": DEFAULT_TYPE_TEXT,\n    \"gender\": DEFAULT_TYPE_TEXT_STRUCTURED,\n    \"geo\": DEFAULT_TYPE_URI,\n    \"impp\": DEFAULT_TYPE_URI,\n    \"key\": DEFAULT_TYPE_URI,\n    \"kind\": DEFAULT_TYPE_TEXT,\n    \"lang\": { defaultType: \"language-tag\" },\n    \"logo\": DEFAULT_TYPE_URI,\n    \"member\": DEFAULT_TYPE_URI,\n    \"n\": { defaultType: \"text\", structuredValue: \";\", multiValue: \",\" },\n    \"nickname\": DEFAULT_TYPE_TEXT_MULTI,\n    \"note\": DEFAULT_TYPE_TEXT,\n    \"org\": { defaultType: \"text\", structuredValue: \";\" },\n    \"photo\": DEFAULT_TYPE_URI,\n    \"related\": DEFAULT_TYPE_URI,\n    \"rev\": { defaultType: \"timestamp\" },\n    \"role\": DEFAULT_TYPE_TEXT,\n    \"sound\": DEFAULT_TYPE_URI,\n    \"source\": DEFAULT_TYPE_URI,\n    \"tel\": { defaultType: \"uri\", allowedTypes: [\"uri\", \"text\"] },\n    \"title\": DEFAULT_TYPE_TEXT,\n    \"tz\": { defaultType: \"text\", allowedTypes: [\"text\", \"utc-offset\", \"uri\"] },\n    \"xml\": DEFAULT_TYPE_TEXT\n  });\n\n  var vcard3Values = ICAL.helpers.extend(commonValues, {\n    binary: icalValues.binary,\n    date: vcardValues.date,\n    \"date-time\": vcardValues[\"date-time\"],\n    \"phone-number\": {\n      // TODO\n      /* ... */\n    },\n    uri: icalValues.uri,\n    text: icalValues.text,\n    time: icalValues.time,\n    vcard: icalValues.text,\n    \"utc-offset\": {\n      toICAL: function(aValue) {\n        return aValue.substr(0, 7);\n      },\n\n      fromICAL: function(aValue) {\n        return aValue.substr(0, 7);\n      },\n\n      decorate: function(aValue) {\n        return ICAL.UtcOffset.fromString(aValue);\n      },\n\n      undecorate: function(aValue) {\n        return aValue.toString();\n      }\n    }\n  });\n\n  var vcard3Params = {\n    \"type\": {\n      valueType: \"text\",\n      multiValue: \",\"\n    },\n    \"value\": {\n      // since the value here is a 'type' lowercase is used.\n      values: [\"text\", \"uri\", \"date\", \"date-time\", \"phone-number\", \"time\",\n               \"boolean\", \"integer\", \"float\", \"utc-offset\", \"vcard\", \"binary\"],\n      allowXName: true,\n      allowIanaToken: true\n    }\n  };\n\n  var vcard3Properties = ICAL.helpers.extend(commonProperties, {\n    fn: DEFAULT_TYPE_TEXT,\n    n: { defaultType: \"text\", structuredValue: \";\", multiValue: \",\" },\n    nickname: DEFAULT_TYPE_TEXT_MULTI,\n    photo: { defaultType: \"binary\", allowedTypes: [\"binary\", \"uri\"] },\n    bday: {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\"],\n      detectType: function(string) {\n        return (string.indexOf('T') === -1) ? 'date' : 'date-time';\n      }\n    },\n\n    adr: { defaultType: \"text\", structuredValue: \";\", multiValue: \",\" },\n    label: DEFAULT_TYPE_TEXT,\n\n    tel: { defaultType: \"phone-number\" },\n    email: DEFAULT_TYPE_TEXT,\n    mailer: DEFAULT_TYPE_TEXT,\n\n    tz: { defaultType: \"utc-offset\", allowedTypes: [\"utc-offset\", \"text\"] },\n    geo: { defaultType: \"float\", structuredValue: \";\" },\n\n    title: DEFAULT_TYPE_TEXT,\n    role: DEFAULT_TYPE_TEXT,\n    logo: { defaultType: \"binary\", allowedTypes: [\"binary\", \"uri\"] },\n    agent: { defaultType: \"vcard\", allowedTypes: [\"vcard\", \"text\", \"uri\"] },\n    org: DEFAULT_TYPE_TEXT_STRUCTURED,\n\n    note: DEFAULT_TYPE_TEXT_MULTI,\n    prodid: DEFAULT_TYPE_TEXT,\n    rev: {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\"],\n      detectType: function(string) {\n        return (string.indexOf('T') === -1) ? 'date' : 'date-time';\n      }\n    },\n    \"sort-string\": DEFAULT_TYPE_TEXT,\n    sound: { defaultType: \"binary\", allowedTypes: [\"binary\", \"uri\"] },\n\n    class: DEFAULT_TYPE_TEXT,\n    key: { defaultType: \"binary\", allowedTypes: [\"binary\", \"text\"] }\n  });\n\n  /**\n   * iCalendar design set\n   * @type {ICAL.design.designSet}\n   */\n  var icalSet = {\n    value: icalValues,\n    param: icalParams,\n    property: icalProperties\n  };\n\n  /**\n   * vCard 4.0 design set\n   * @type {ICAL.design.designSet}\n   */\n  var vcardSet = {\n    value: vcardValues,\n    param: vcardParams,\n    property: vcardProperties\n  };\n\n  /**\n   * vCard 3.0 design set\n   * @type {ICAL.design.designSet}\n   */\n  var vcard3Set = {\n    value: vcard3Values,\n    param: vcard3Params,\n    property: vcard3Properties\n  };\n\n  /**\n   * The design data, used by the parser to determine types for properties and\n   * other metadata needed to produce correct jCard/jCal data.\n   *\n   * @alias ICAL.design\n   * @namespace\n   */\n  var design = {\n    /**\n     * A designSet describes value, parameter and property data. It is used by\n     * ther parser and stringifier in components and properties to determine they\n     * should be represented.\n     *\n     * @typedef {Object} designSet\n     * @memberOf ICAL.design\n     * @property {Object} value       Definitions for value types, keys are type names\n     * @property {Object} param       Definitions for params, keys are param names\n     * @property {Object} property    Defintions for properties, keys are property names\n     */\n\n    /**\n     * Can be set to false to make the parser more lenient.\n     */\n    strict: true,\n\n    /**\n     * The default set for new properties and components if none is specified.\n     * @type {ICAL.design.designSet}\n     */\n    defaultSet: icalSet,\n\n    /**\n     * The default type for unknown properties\n     * @type {String}\n     */\n    defaultType: 'unknown',\n\n    /**\n     * Holds the design set for known top-level components\n     *\n     * @type {Object}\n     * @property {ICAL.design.designSet} vcard       vCard VCARD\n     * @property {ICAL.design.designSet} vevent      iCalendar VEVENT\n     * @property {ICAL.design.designSet} vtodo       iCalendar VTODO\n     * @property {ICAL.design.designSet} vjournal    iCalendar VJOURNAL\n     * @property {ICAL.design.designSet} valarm      iCalendar VALARM\n     * @property {ICAL.design.designSet} vtimezone   iCalendar VTIMEZONE\n     * @property {ICAL.design.designSet} daylight    iCalendar DAYLIGHT\n     * @property {ICAL.design.designSet} standard    iCalendar STANDARD\n     *\n     * @example\n     * var propertyName = 'fn';\n     * var componentDesign = ICAL.design.components.vcard;\n     * var propertyDetails = componentDesign.property[propertyName];\n     * if (propertyDetails.defaultType == 'text') {\n     *   // Yep, sure is...\n     * }\n     */\n    components: {\n      vcard: vcardSet,\n      vcard3: vcard3Set,\n      vevent: icalSet,\n      vtodo: icalSet,\n      vjournal: icalSet,\n      valarm: icalSet,\n      vtimezone: icalSet,\n      daylight: icalSet,\n      standard: icalSet\n    },\n\n\n    /**\n     * The design set for iCalendar (rfc5545/rfc7265) components.\n     * @type {ICAL.design.designSet}\n     */\n    icalendar: icalSet,\n\n    /**\n     * The design set for vCard (rfc6350/rfc7095) components.\n     * @type {ICAL.design.designSet}\n     */\n    vcard: vcardSet,\n\n    /**\n     * The design set for vCard (rfc2425/rfc2426/rfc7095) components.\n     * @type {ICAL.design.designSet}\n     */\n    vcard3: vcard3Set,\n\n    /**\n     * Gets the design set for the given component name.\n     *\n     * @param {String} componentName        The name of the component\n     * @return {ICAL.design.designSet}      The design set for the component\n     */\n    getDesignSet: function(componentName) {\n      var isInDesign = componentName && componentName in design.components;\n      return isInDesign ? design.components[componentName] : design.defaultSet;\n    }\n  };\n\n  return design;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * Contains various functions to convert jCal and jCard data back into\n * iCalendar and vCard.\n * @namespace\n */\nICAL.stringify = (function() {\n  'use strict';\n\n  var LINE_ENDING = '\\r\\n';\n  var DEFAULT_VALUE_TYPE = 'unknown';\n\n  var design = ICAL.design;\n  var helpers = ICAL.helpers;\n\n  /**\n   * Convert a full jCal/jCard array into a iCalendar/vCard string.\n   *\n   * @function ICAL.stringify\n   * @variation function\n   * @param {Array} jCal    The jCal/jCard document\n   * @return {String}       The stringified iCalendar/vCard document\n   */\n  function stringify(jCal) {\n    if (typeof jCal[0] == \"string\") {\n      // This is a single component\n      jCal = [jCal];\n    }\n\n    var i = 0;\n    var len = jCal.length;\n    var result = '';\n\n    for (; i < len; i++) {\n      result += stringify.component(jCal[i]) + LINE_ENDING;\n    }\n\n    return result;\n  }\n\n  /**\n   * Converts an jCal component array into a ICAL string.\n   * Recursive will resolve sub-components.\n   *\n   * Exact component/property order is not saved all\n   * properties will come before subcomponents.\n   *\n   * @function ICAL.stringify.component\n   * @param {Array} component\n   *        jCal/jCard fragment of a component\n   * @param {ICAL.design.designSet} designSet\n   *        The design data to use for this component\n   * @return {String}       The iCalendar/vCard string\n   */\n  stringify.component = function(component, designSet) {\n    var name = component[0].toUpperCase();\n    var result = 'BEGIN:' + name + LINE_ENDING;\n\n    var props = component[1];\n    var propIdx = 0;\n    var propLen = props.length;\n\n    var designSetName = component[0];\n    // rfc6350 requires that in vCard 4.0 the first component is the VERSION\n    // component with as value 4.0, note that 3.0 does not have this requirement.\n    if (designSetName === 'vcard' && component[1].length > 0 &&\n            !(component[1][0][0] === \"version\" && component[1][0][3] === \"4.0\")) {\n      designSetName = \"vcard3\";\n    }\n    designSet = designSet || design.getDesignSet(designSetName);\n\n    for (; propIdx < propLen; propIdx++) {\n      result += stringify.property(props[propIdx], designSet) + LINE_ENDING;\n    }\n\n    // Ignore subcomponents if none exist, e.g. in vCard.\n    var comps = component[2] || [];\n    var compIdx = 0;\n    var compLen = comps.length;\n\n    for (; compIdx < compLen; compIdx++) {\n      result += stringify.component(comps[compIdx], designSet) + LINE_ENDING;\n    }\n\n    result += 'END:' + name;\n    return result;\n  };\n\n  /**\n   * Converts a single jCal/jCard property to a iCalendar/vCard string.\n   *\n   * @function ICAL.stringify.property\n   * @param {Array} property\n   *        jCal/jCard property array\n   * @param {ICAL.design.designSet} designSet\n   *        The design data to use for this property\n   * @param {Boolean} noFold\n   *        If true, the line is not folded\n   * @return {String}       The iCalendar/vCard string\n   */\n  stringify.property = function(property, designSet, noFold) {\n    var name = property[0].toUpperCase();\n    var jsName = property[0];\n    var params = property[1];\n\n    var line = name;\n\n    var paramName;\n    for (paramName in params) {\n      var value = params[paramName];\n\n      /* istanbul ignore else */\n      if (params.hasOwnProperty(paramName)) {\n        var multiValue = (paramName in designSet.param) && designSet.param[paramName].multiValue;\n        if (multiValue && Array.isArray(value)) {\n          if (designSet.param[paramName].multiValueSeparateDQuote) {\n            multiValue = '\"' + multiValue + '\"';\n          }\n          value = value.map(stringify._rfc6868Unescape);\n          value = stringify.multiValue(value, multiValue, \"unknown\", null, designSet);\n        } else {\n          value = stringify._rfc6868Unescape(value);\n        }\n\n\n        line += ';' + paramName.toUpperCase();\n        line += '=' + stringify.propertyValue(value);\n      }\n    }\n\n    if (property.length === 3) {\n      // If there are no values, we must assume a blank value\n      return line + ':';\n    }\n\n    var valueType = property[2];\n\n    if (!designSet) {\n      designSet = design.defaultSet;\n    }\n\n    var propDetails;\n    var multiValue = false;\n    var structuredValue = false;\n    var isDefault = false;\n\n    if (jsName in designSet.property) {\n      propDetails = designSet.property[jsName];\n\n      if ('multiValue' in propDetails) {\n        multiValue = propDetails.multiValue;\n      }\n\n      if (('structuredValue' in propDetails) && Array.isArray(property[3])) {\n        structuredValue = propDetails.structuredValue;\n      }\n\n      if ('defaultType' in propDetails) {\n        if (valueType === propDetails.defaultType) {\n          isDefault = true;\n        }\n      } else {\n        if (valueType === DEFAULT_VALUE_TYPE) {\n          isDefault = true;\n        }\n      }\n    } else {\n      if (valueType === DEFAULT_VALUE_TYPE) {\n        isDefault = true;\n      }\n    }\n\n    // push the VALUE property if type is not the default\n    // for the current property.\n    if (!isDefault) {\n      // value will never contain ;/:/, so we don't escape it here.\n      line += ';VALUE=' + valueType.toUpperCase();\n    }\n\n    line += ':';\n\n    if (multiValue && structuredValue) {\n      line += stringify.multiValue(\n        property[3], structuredValue, valueType, multiValue, designSet, structuredValue\n      );\n    } else if (multiValue) {\n      line += stringify.multiValue(\n        property.slice(3), multiValue, valueType, null, designSet, false\n      );\n    } else if (structuredValue) {\n      line += stringify.multiValue(\n        property[3], structuredValue, valueType, null, designSet, structuredValue\n      );\n    } else {\n      line += stringify.value(property[3], valueType, designSet, false);\n    }\n\n    return noFold ? line : ICAL.helpers.foldline(line);\n  };\n\n  /**\n   * Handles escaping of property values that may contain:\n   *\n   *    COLON (:), SEMICOLON (;), or COMMA (,)\n   *\n   * If any of the above are present the result is wrapped\n   * in double quotes.\n   *\n   * @function ICAL.stringify.propertyValue\n   * @param {String} value      Raw property value\n   * @return {String}           Given or escaped value when needed\n   */\n  stringify.propertyValue = function(value) {\n\n    if ((helpers.unescapedIndexOf(value, ',') === -1) &&\n        (helpers.unescapedIndexOf(value, ':') === -1) &&\n        (helpers.unescapedIndexOf(value, ';') === -1)) {\n\n      return value;\n    }\n\n    return '\"' + value + '\"';\n  };\n\n  /**\n   * Converts an array of ical values into a single\n   * string based on a type and a delimiter value (like \",\").\n   *\n   * @function ICAL.stringify.multiValue\n   * @param {Array} values      List of values to convert\n   * @param {String} delim      Used to join the values (\",\", \";\", \":\")\n   * @param {String} type       Lowecase ical value type\n   *        (like boolean, date-time, etc..)\n   * @param {?String} innerMulti If set, each value will again be processed\n   *        Used for structured values\n   * @param {ICAL.design.designSet} designSet\n   *        The design data to use for this property\n   *\n   * @return {String}           iCalendar/vCard string for value\n   */\n  stringify.multiValue = function(values, delim, type, innerMulti, designSet, structuredValue) {\n    var result = '';\n    var len = values.length;\n    var i = 0;\n\n    for (; i < len; i++) {\n      if (innerMulti && Array.isArray(values[i])) {\n        result += stringify.multiValue(values[i], innerMulti, type, null, designSet, structuredValue);\n      } else {\n        result += stringify.value(values[i], type, designSet, structuredValue);\n      }\n\n      if (i !== (len - 1)) {\n        result += delim;\n      }\n    }\n\n    return result;\n  };\n\n  /**\n   * Processes a single ical value runs the associated \"toICAL\" method from the\n   * design value type if available to convert the value.\n   *\n   * @function ICAL.stringify.value\n   * @param {String|Number} value       A formatted value\n   * @param {String} type               Lowercase iCalendar/vCard value type\n   *  (like boolean, date-time, etc..)\n   * @return {String}                   iCalendar/vCard value for single value\n   */\n  stringify.value = function(value, type, designSet, structuredValue) {\n    if (type in designSet.value && 'toICAL' in designSet.value[type]) {\n      return designSet.value[type].toICAL(value, structuredValue);\n    }\n    return value;\n  };\n\n  /**\n   * Internal helper for rfc6868. Exposing this on ICAL.stringify so that\n   * hackers can disable the rfc6868 parsing if the really need to.\n   *\n   * @param {String} val        The value to unescape\n   * @return {String}           The escaped value\n   */\n  stringify._rfc6868Unescape = function(val) {\n    return val.replace(/[\\n^\"]/g, function(x) {\n      return RFC6868_REPLACE_MAP[x];\n    });\n  };\n  var RFC6868_REPLACE_MAP = { '\"': \"^'\", \"\\n\": \"^n\", \"^\": \"^^\" };\n\n  return stringify;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * Contains various functions to parse iCalendar and vCard data.\n * @namespace\n */\nICAL.parse = (function() {\n  'use strict';\n\n  var CHAR = /[^ \\t]/;\n  var MULTIVALUE_DELIMITER = ',';\n  var VALUE_DELIMITER = ':';\n  var PARAM_DELIMITER = ';';\n  var PARAM_NAME_DELIMITER = '=';\n  var DEFAULT_VALUE_TYPE = 'unknown';\n  var DEFAULT_PARAM_TYPE = 'text';\n\n  var design = ICAL.design;\n  var helpers = ICAL.helpers;\n\n  /**\n   * An error that occurred during parsing.\n   *\n   * @param {String} message        The error message\n   * @memberof ICAL.parse\n   * @extends {Error}\n   * @class\n   */\n  function ParserError(message) {\n    this.message = message;\n    this.name = 'ParserError';\n\n    try {\n      throw new Error();\n    } catch (e) {\n      if (e.stack) {\n        var split = e.stack.split('\\n');\n        split.shift();\n        this.stack = split.join('\\n');\n      }\n    }\n  }\n\n  ParserError.prototype = Error.prototype;\n\n  /**\n   * Parses iCalendar or vCard data into a raw jCal object. Consult\n   * documentation on the {@tutorial layers|layers of parsing} for more\n   * details.\n   *\n   * @function ICAL.parse\n   * @variation function\n   * @todo Fix the API to be more clear on the return type\n   * @param {String} input      The string data to parse\n   * @return {Object|Object[]}  A single jCal object, or an array thereof\n   */\n  function parser(input) {\n    var state = {};\n    var root = state.component = [];\n\n    state.stack = [root];\n\n    parser._eachLine(input, function(err, line) {\n      parser._handleContentLine(line, state);\n    });\n\n\n    // when there are still items on the stack\n    // throw a fatal error, a component was not closed\n    // correctly in that case.\n    if (state.stack.length > 1) {\n      throw new ParserError(\n        'invalid ical body. component began but did not end'\n      );\n    }\n\n    state = null;\n\n    return (root.length == 1 ? root[0] : root);\n  }\n\n  /**\n   * Parse an iCalendar property value into the jCal for a single property\n   *\n   * @function ICAL.parse.property\n   * @param {String} str\n   *   The iCalendar property string to parse\n   * @param {ICAL.design.designSet=} designSet\n   *   The design data to use for this property\n   * @return {Object}\n   *   The jCal Object containing the property\n   */\n  parser.property = function(str, designSet) {\n    var state = {\n      component: [[], []],\n      designSet: designSet || design.defaultSet\n    };\n    parser._handleContentLine(str, state);\n    return state.component[1][0];\n  };\n\n  /**\n   * Convenience method to parse a component. You can use ICAL.parse() directly\n   * instead.\n   *\n   * @function ICAL.parse.component\n   * @see ICAL.parse(function)\n   * @param {String} str    The iCalendar component string to parse\n   * @return {Object}       The jCal Object containing the component\n   */\n  parser.component = function(str) {\n    return parser(str);\n  };\n\n  // classes & constants\n  parser.ParserError = ParserError;\n\n  /**\n   * The state for parsing content lines from an iCalendar/vCard string.\n   *\n   * @private\n   * @memberof ICAL.parse\n   * @typedef {Object} parserState\n   * @property {ICAL.design.designSet} designSet    The design set to use for parsing\n   * @property {ICAL.Component[]} stack             The stack of components being processed\n   * @property {ICAL.Component} component           The currently active component\n   */\n\n\n  /**\n   * Handles a single line of iCalendar/vCard, updating the state.\n   *\n   * @private\n   * @function ICAL.parse._handleContentLine\n   * @param {String} line               The content line to process\n   * @param {ICAL.parse.parserState}    The current state of the line parsing\n   */\n  parser._handleContentLine = function(line, state) {\n    // break up the parts of the line\n    var valuePos = line.indexOf(VALUE_DELIMITER);\n    var paramPos = line.indexOf(PARAM_DELIMITER);\n\n    var lastParamIndex;\n    var lastValuePos;\n\n    // name of property or begin/end\n    var name;\n    var value;\n    // params is only overridden if paramPos !== -1.\n    // we can't do params = params || {} later on\n    // because it sacrifices ops.\n    var params = {};\n\n    /**\n     * Different property cases\n     *\n     *\n     * 1. RRULE:FREQ=foo\n     *    // FREQ= is not a param but the value\n     *\n     * 2. ATTENDEE;ROLE=REQ-PARTICIPANT;\n     *    // ROLE= is a param because : has not happened yet\n     */\n      // when the parameter delimiter is after the\n      // value delimiter then it is not a parameter.\n\n    if ((paramPos !== -1 && valuePos !== -1)) {\n      // when the parameter delimiter is after the\n      // value delimiter then it is not a parameter.\n      if (paramPos > valuePos) {\n        paramPos = -1;\n      }\n    }\n\n    var parsedParams;\n    if (paramPos !== -1) {\n      name = line.substring(0, paramPos).toLowerCase();\n      parsedParams = parser._parseParameters(line.substring(paramPos), 0, state.designSet);\n      if (parsedParams[2] == -1) {\n        throw new ParserError(\"Invalid parameters in '\" + line + \"'\");\n      }\n      params = parsedParams[0];\n      lastParamIndex = parsedParams[1].length + parsedParams[2] + paramPos;\n      if ((lastValuePos =\n        line.substring(lastParamIndex).indexOf(VALUE_DELIMITER)) !== -1) {\n        value = line.substring(lastParamIndex + lastValuePos + 1);\n      } else {\n        throw new ParserError(\"Missing parameter value in '\" + line + \"'\");\n      }\n    } else if (valuePos !== -1) {\n      // without parmeters (BEGIN:VCAENDAR, CLASS:PUBLIC)\n      name = line.substring(0, valuePos).toLowerCase();\n      value = line.substring(valuePos + 1);\n\n      if (name === 'begin') {\n        var newComponent = [value.toLowerCase(), [], []];\n        if (state.stack.length === 1) {\n          state.component.push(newComponent);\n        } else {\n          state.component[2].push(newComponent);\n        }\n        state.stack.push(state.component);\n        state.component = newComponent;\n        if (!state.designSet) {\n          state.designSet = design.getDesignSet(state.component[0]);\n        }\n        return;\n      } else if (name === 'end') {\n        state.component = state.stack.pop();\n        return;\n      }\n      // If it is not begin/end, then this is a property with an empty value,\n      // which should be considered valid.\n    } else {\n      /**\n       * Invalid line.\n       * The rational to throw an error is we will\n       * never be certain that the rest of the file\n       * is sane and it is unlikely that we can serialize\n       * the result correctly either.\n       */\n      throw new ParserError(\n        'invalid line (no token \";\" or \":\") \"' + line + '\"'\n      );\n    }\n\n    var valueType;\n    var multiValue = false;\n    var structuredValue = false;\n    var propertyDetails;\n\n    if (name in state.designSet.property) {\n      propertyDetails = state.designSet.property[name];\n\n      if ('multiValue' in propertyDetails) {\n        multiValue = propertyDetails.multiValue;\n      }\n\n      if ('structuredValue' in propertyDetails) {\n        structuredValue = propertyDetails.structuredValue;\n      }\n\n      if (value && 'detectType' in propertyDetails) {\n        valueType = propertyDetails.detectType(value);\n      }\n    }\n\n    // attempt to determine value\n    if (!valueType) {\n      if (!('value' in params)) {\n        if (propertyDetails) {\n          valueType = propertyDetails.defaultType;\n        } else {\n          valueType = DEFAULT_VALUE_TYPE;\n        }\n      } else {\n        // possible to avoid this?\n        valueType = params.value.toLowerCase();\n      }\n    }\n\n    delete params.value;\n\n    /**\n     * Note on `var result` juggling:\n     *\n     * I observed that building the array in pieces has adverse\n     * effects on performance, so where possible we inline the creation.\n     * It is a little ugly but resulted in ~2000 additional ops/sec.\n     */\n\n    var result;\n    if (multiValue && structuredValue) {\n      value = parser._parseMultiValue(value, structuredValue, valueType, [], multiValue, state.designSet, structuredValue);\n      result = [name, params, valueType, value];\n    } else if (multiValue) {\n      result = [name, params, valueType];\n      parser._parseMultiValue(value, multiValue, valueType, result, null, state.designSet, false);\n    } else if (structuredValue) {\n      value = parser._parseMultiValue(value, structuredValue, valueType, [], null, state.designSet, structuredValue);\n      result = [name, params, valueType, value];\n    } else {\n      value = parser._parseValue(value, valueType, state.designSet, false);\n      result = [name, params, valueType, value];\n    }\n    // rfc6350 requires that in vCard 4.0 the first component is the VERSION\n    // component with as value 4.0, note that 3.0 does not have this requirement.\n    if (state.component[0] === 'vcard' && state.component[1].length === 0 &&\n            !(name === 'version' && value === '4.0')) {\n      state.designSet = design.getDesignSet(\"vcard3\");\n    }\n    state.component[1].push(result);\n  };\n\n  /**\n   * Parse a value from the raw value into the jCard/jCal value.\n   *\n   * @private\n   * @function ICAL.parse._parseValue\n   * @param {String} value          Original value\n   * @param {String} type           Type of value\n   * @param {Object} designSet      The design data to use for this value\n   * @return {Object} varies on type\n   */\n  parser._parseValue = function(value, type, designSet, structuredValue) {\n    if (type in designSet.value && 'fromICAL' in designSet.value[type]) {\n      return designSet.value[type].fromICAL(value, structuredValue);\n    }\n    return value;\n  };\n\n  /**\n   * Parse parameters from a string to object.\n   *\n   * @function ICAL.parse._parseParameters\n   * @private\n   * @param {String} line           A single unfolded line\n   * @param {Numeric} start         Position to start looking for properties\n   * @param {Object} designSet      The design data to use for this property\n   * @return {Object} key/value pairs\n   */\n  parser._parseParameters = function(line, start, designSet) {\n    var lastParam = start;\n    var pos = 0;\n    var delim = PARAM_NAME_DELIMITER;\n    var result = {};\n    var name, lcname;\n    var value, valuePos = -1;\n    var type, multiValue, mvdelim;\n\n    // find the next '=' sign\n    // use lastParam and pos to find name\n    // check if \" is used if so get value from \"->\"\n    // then increment pos to find next ;\n\n    while ((pos !== false) &&\n           (pos = helpers.unescapedIndexOf(line, delim, pos + 1)) !== -1) {\n\n      name = line.substr(lastParam + 1, pos - lastParam - 1);\n      if (name.length == 0) {\n        throw new ParserError(\"Empty parameter name in '\" + line + \"'\");\n      }\n      lcname = name.toLowerCase();\n      mvdelim = false;\n      multiValue = false;\n\n      if (lcname in designSet.param && designSet.param[lcname].valueType) {\n        type = designSet.param[lcname].valueType;\n      } else {\n        type = DEFAULT_PARAM_TYPE;\n      }\n\n      if (lcname in designSet.param) {\n        multiValue = designSet.param[lcname].multiValue;\n        if (designSet.param[lcname].multiValueSeparateDQuote) {\n          mvdelim = parser._rfc6868Escape('\"' + multiValue + '\"');\n        }\n      }\n\n      var nextChar = line[pos + 1];\n      if (nextChar === '\"') {\n        valuePos = pos + 2;\n        pos = helpers.unescapedIndexOf(line, '\"', valuePos);\n        if (multiValue && pos != -1) {\n            var extendedValue = true;\n            while (extendedValue) {\n              if (line[pos + 1] == multiValue && line[pos + 2] == '\"') {\n                pos = helpers.unescapedIndexOf(line, '\"', pos + 3);\n              } else {\n                extendedValue = false;\n              }\n            }\n          }\n        if (pos === -1) {\n          throw new ParserError(\n            'invalid line (no matching double quote) \"' + line + '\"'\n          );\n        }\n        value = line.substr(valuePos, pos - valuePos);\n        lastParam = helpers.unescapedIndexOf(line, PARAM_DELIMITER, pos);\n        if (lastParam === -1) {\n          pos = false;\n        }\n      } else {\n        valuePos = pos + 1;\n\n        // move to next \";\"\n        var nextPos = helpers.unescapedIndexOf(line, PARAM_DELIMITER, valuePos);\n        var propValuePos = helpers.unescapedIndexOf(line, VALUE_DELIMITER, valuePos);\n        if (propValuePos !== -1 && nextPos > propValuePos) {\n          // this is a delimiter in the property value, let's stop here\n          nextPos = propValuePos;\n          pos = false;\n        } else if (nextPos === -1) {\n          // no \";\"\n          if (propValuePos === -1) {\n            nextPos = line.length;\n          } else {\n            nextPos = propValuePos;\n          }\n          pos = false;\n        } else {\n          lastParam = nextPos;\n          pos = nextPos;\n        }\n\n        value = line.substr(valuePos, nextPos - valuePos);\n      }\n\n      value = parser._rfc6868Escape(value);\n      if (multiValue) {\n        var delimiter = mvdelim || multiValue;\n        value = parser._parseMultiValue(value, delimiter, type, [], null, designSet);\n      } else {\n        value = parser._parseValue(value, type, designSet);\n      }\n\n      if (multiValue && (lcname in result)) {\n        if (Array.isArray(result[lcname])) {\n          result[lcname].push(value);\n        } else {\n          result[lcname] = [\n            result[lcname],\n            value\n          ];\n        }\n      } else {\n        result[lcname] = value;\n      }\n    }\n    return [result, value, valuePos];\n  };\n\n  /**\n   * Internal helper for rfc6868. Exposing this on ICAL.parse so that\n   * hackers can disable the rfc6868 parsing if the really need to.\n   *\n   * @function ICAL.parse._rfc6868Escape\n   * @param {String} val        The value to escape\n   * @return {String}           The escaped value\n   */\n  parser._rfc6868Escape = function(val) {\n    return val.replace(/\\^['n^]/g, function(x) {\n      return RFC6868_REPLACE_MAP[x];\n    });\n  };\n  var RFC6868_REPLACE_MAP = { \"^'\": '\"', \"^n\": \"\\n\", \"^^\": \"^\" };\n\n  /**\n   * Parse a multi value string. This function is used either for parsing\n   * actual multi-value property's values, or for handling parameter values. It\n   * can be used for both multi-value properties and structured value properties.\n   *\n   * @private\n   * @function ICAL.parse._parseMultiValue\n   * @param {String} buffer     The buffer containing the full value\n   * @param {String} delim      The multi-value delimiter\n   * @param {String} type       The value type to be parsed\n   * @param {Array.<?>} result        The array to append results to, varies on value type\n   * @param {String} innerMulti The inner delimiter to split each value with\n   * @param {ICAL.design.designSet} designSet   The design data for this value\n   * @return {?|Array.<?>}            Either an array of results, or the first result\n   */\n  parser._parseMultiValue = function(buffer, delim, type, result, innerMulti, designSet, structuredValue) {\n    var pos = 0;\n    var lastPos = 0;\n    var value;\n    if (delim.length === 0) {\n      return buffer;\n    }\n\n    // split each piece\n    while ((pos = helpers.unescapedIndexOf(buffer, delim, lastPos)) !== -1) {\n      value = buffer.substr(lastPos, pos - lastPos);\n      if (innerMulti) {\n        value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);\n      } else {\n        value = parser._parseValue(value, type, designSet, structuredValue);\n      }\n      result.push(value);\n      lastPos = pos + delim.length;\n    }\n\n    // on the last piece take the rest of string\n    value = buffer.substr(lastPos);\n    if (innerMulti) {\n      value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);\n    } else {\n      value = parser._parseValue(value, type, designSet, structuredValue);\n    }\n    result.push(value);\n\n    return result.length == 1 ? result[0] : result;\n  };\n\n  /**\n   * Process a complete buffer of iCalendar/vCard data line by line, correctly\n   * unfolding content. Each line will be processed with the given callback\n   *\n   * @private\n   * @function ICAL.parse._eachLine\n   * @param {String} buffer                         The buffer to process\n   * @param {function(?String, String)} callback    The callback for each line\n   */\n  parser._eachLine = function(buffer, callback) {\n    var len = buffer.length;\n    var lastPos = buffer.search(CHAR);\n    var pos = lastPos;\n    var line;\n    var firstChar;\n\n    var newlineOffset;\n\n    do {\n      pos = buffer.indexOf('\\n', lastPos) + 1;\n\n      if (pos > 1 && buffer[pos - 2] === '\\r') {\n        newlineOffset = 2;\n      } else {\n        newlineOffset = 1;\n      }\n\n      if (pos === 0) {\n        pos = len;\n        newlineOffset = 0;\n      }\n\n      firstChar = buffer[lastPos];\n\n      if (firstChar === ' ' || firstChar === '\\t') {\n        // add to line\n        line += buffer.substr(\n          lastPos + 1,\n          pos - lastPos - (newlineOffset + 1)\n        );\n      } else {\n        if (line)\n          callback(null, line);\n        // push line\n        line = buffer.substr(\n          lastPos,\n          pos - lastPos - newlineOffset\n        );\n      }\n\n      lastPos = pos;\n    } while (pos !== len);\n\n    // extra ending line\n    line = line.trim();\n\n    if (line.length)\n      callback(null, line);\n  };\n\n  return parser;\n\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.Component = (function() {\n  'use strict';\n\n  var PROPERTY_INDEX = 1;\n  var COMPONENT_INDEX = 2;\n  var NAME_INDEX = 0;\n\n  /**\n   * @classdesc\n   * Wraps a jCal component, adding convenience methods to add, remove and\n   * update subcomponents and properties.\n   *\n   * @class\n   * @alias ICAL.Component\n   * @param {Array|String} jCal         Raw jCal component data OR name of new\n   *                                      component\n   * @param {ICAL.Component} parent     Parent component to associate\n   */\n  function Component(jCal, parent) {\n    if (typeof(jCal) === 'string') {\n      // jCal spec (name, properties, components)\n      jCal = [jCal, [], []];\n    }\n\n    // mostly for legacy reasons.\n    this.jCal = jCal;\n\n    this.parent = parent || null;\n  }\n\n  Component.prototype = {\n    /**\n     * Hydrated properties are inserted into the _properties array at the same\n     * position as in the jCal array, so it is possible that the array contains\n     * undefined values for unhydrdated properties. To avoid iterating the\n     * array when checking if all properties have been hydrated, we save the\n     * count here.\n     *\n     * @type {Number}\n     * @private\n     */\n    _hydratedPropertyCount: 0,\n\n    /**\n     * The same count as for _hydratedPropertyCount, but for subcomponents\n     *\n     * @type {Number}\n     * @private\n     */\n    _hydratedComponentCount: 0,\n\n    /**\n     * The name of this component\n     * @readonly\n     */\n    get name() {\n      return this.jCal[NAME_INDEX];\n    },\n\n    /**\n     * The design set for this component, e.g. icalendar vs vcard\n     *\n     * @type {ICAL.design.designSet}\n     * @private\n     */\n    get _designSet() {\n      var parentDesign = this.parent && this.parent._designSet;\n      return parentDesign || ICAL.design.getDesignSet(this.name);\n    },\n\n    _hydrateComponent: function(index) {\n      if (!this._components) {\n        this._components = [];\n        this._hydratedComponentCount = 0;\n      }\n\n      if (this._components[index]) {\n        return this._components[index];\n      }\n\n      var comp = new Component(\n        this.jCal[COMPONENT_INDEX][index],\n        this\n      );\n\n      this._hydratedComponentCount++;\n      return (this._components[index] = comp);\n    },\n\n    _hydrateProperty: function(index) {\n      if (!this._properties) {\n        this._properties = [];\n        this._hydratedPropertyCount = 0;\n      }\n\n      if (this._properties[index]) {\n        return this._properties[index];\n      }\n\n      var prop = new ICAL.Property(\n        this.jCal[PROPERTY_INDEX][index],\n        this\n      );\n\n      this._hydratedPropertyCount++;\n      return (this._properties[index] = prop);\n    },\n\n    /**\n     * Finds first sub component, optionally filtered by name.\n     *\n     * @param {String=} name        Optional name to filter by\n     * @return {?ICAL.Component}     The found subcomponent\n     */\n    getFirstSubcomponent: function(name) {\n      if (name) {\n        var i = 0;\n        var comps = this.jCal[COMPONENT_INDEX];\n        var len = comps.length;\n\n        for (; i < len; i++) {\n          if (comps[i][NAME_INDEX] === name) {\n            var result = this._hydrateComponent(i);\n            return result;\n          }\n        }\n      } else {\n        if (this.jCal[COMPONENT_INDEX].length) {\n          return this._hydrateComponent(0);\n        }\n      }\n\n      // ensure we return a value (strict mode)\n      return null;\n    },\n\n    /**\n     * Finds all sub components, optionally filtering by name.\n     *\n     * @param {String=} name            Optional name to filter by\n     * @return {ICAL.Component[]}       The found sub components\n     */\n    getAllSubcomponents: function(name) {\n      var jCalLen = this.jCal[COMPONENT_INDEX].length;\n      var i = 0;\n\n      if (name) {\n        var comps = this.jCal[COMPONENT_INDEX];\n        var result = [];\n\n        for (; i < jCalLen; i++) {\n          if (name === comps[i][NAME_INDEX]) {\n            result.push(\n              this._hydrateComponent(i)\n            );\n          }\n        }\n        return result;\n      } else {\n        if (!this._components ||\n            (this._hydratedComponentCount !== jCalLen)) {\n          for (; i < jCalLen; i++) {\n            this._hydrateComponent(i);\n          }\n        }\n\n        return this._components || [];\n      }\n    },\n\n    /**\n     * Returns true when a named property exists.\n     *\n     * @param {String} name     The property name\n     * @return {Boolean}        True, when property is found\n     */\n    hasProperty: function(name) {\n      var props = this.jCal[PROPERTY_INDEX];\n      var len = props.length;\n\n      var i = 0;\n      for (; i < len; i++) {\n        // 0 is property name\n        if (props[i][NAME_INDEX] === name) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n    /**\n     * Finds the first property, optionally with the given name.\n     *\n     * @param {String=} name        Lowercase property name\n     * @return {?ICAL.Property}     The found property\n     */\n    getFirstProperty: function(name) {\n      if (name) {\n        var i = 0;\n        var props = this.jCal[PROPERTY_INDEX];\n        var len = props.length;\n\n        for (; i < len; i++) {\n          if (props[i][NAME_INDEX] === name) {\n            var result = this._hydrateProperty(i);\n            return result;\n          }\n        }\n      } else {\n        if (this.jCal[PROPERTY_INDEX].length) {\n          return this._hydrateProperty(0);\n        }\n      }\n\n      return null;\n    },\n\n    /**\n     * Returns first property's value, if available.\n     *\n     * @param {String=} name    Lowercase property name\n     * @return {?String}        The found property value.\n     */\n    getFirstPropertyValue: function(name) {\n      var prop = this.getFirstProperty(name);\n      if (prop) {\n        return prop.getFirstValue();\n      }\n\n      return null;\n    },\n\n    /**\n     * Get all properties in the component, optionally filtered by name.\n     *\n     * @param {String=} name        Lowercase property name\n     * @return {ICAL.Property[]}    List of properties\n     */\n    getAllProperties: function(name) {\n      var jCalLen = this.jCal[PROPERTY_INDEX].length;\n      var i = 0;\n\n      if (name) {\n        var props = this.jCal[PROPERTY_INDEX];\n        var result = [];\n\n        for (; i < jCalLen; i++) {\n          if (name === props[i][NAME_INDEX]) {\n            result.push(\n              this._hydrateProperty(i)\n            );\n          }\n        }\n        return result;\n      } else {\n        if (!this._properties ||\n            (this._hydratedPropertyCount !== jCalLen)) {\n          for (; i < jCalLen; i++) {\n            this._hydrateProperty(i);\n          }\n        }\n\n        return this._properties || [];\n      }\n    },\n\n    _removeObjectByIndex: function(jCalIndex, cache, index) {\n      cache = cache || [];\n      // remove cached version\n      if (cache[index]) {\n        var obj = cache[index];\n        if (\"parent\" in obj) {\n            obj.parent = null;\n        }\n      }\n\n      cache.splice(index, 1);\n\n      // remove it from the jCal\n      this.jCal[jCalIndex].splice(index, 1);\n    },\n\n    _removeObject: function(jCalIndex, cache, nameOrObject) {\n      var i = 0;\n      var objects = this.jCal[jCalIndex];\n      var len = objects.length;\n      var cached = this[cache];\n\n      if (typeof(nameOrObject) === 'string') {\n        for (; i < len; i++) {\n          if (objects[i][NAME_INDEX] === nameOrObject) {\n            this._removeObjectByIndex(jCalIndex, cached, i);\n            return true;\n          }\n        }\n      } else if (cached) {\n        for (; i < len; i++) {\n          if (cached[i] && cached[i] === nameOrObject) {\n            this._removeObjectByIndex(jCalIndex, cached, i);\n            return true;\n          }\n        }\n      }\n\n      return false;\n    },\n\n    _removeAllObjects: function(jCalIndex, cache, name) {\n      var cached = this[cache];\n\n      // Unfortunately we have to run through all children to reset their\n      // parent property.\n      var objects = this.jCal[jCalIndex];\n      var i = objects.length - 1;\n\n      // descending search required because splice\n      // is used and will effect the indices.\n      for (; i >= 0; i--) {\n        if (!name || objects[i][NAME_INDEX] === name) {\n          this._removeObjectByIndex(jCalIndex, cached, i);\n        }\n      }\n    },\n\n    /**\n     * Adds a single sub component.\n     *\n     * @param {ICAL.Component} component        The component to add\n     * @return {ICAL.Component}                 The passed in component\n     */\n    addSubcomponent: function(component) {\n      if (!this._components) {\n        this._components = [];\n        this._hydratedComponentCount = 0;\n      }\n\n      if (component.parent) {\n        component.parent.removeSubcomponent(component);\n      }\n\n      var idx = this.jCal[COMPONENT_INDEX].push(component.jCal);\n      this._components[idx - 1] = component;\n      this._hydratedComponentCount++;\n      component.parent = this;\n      return component;\n    },\n\n    /**\n     * Removes a single component by name or the instance of a specific\n     * component.\n     *\n     * @param {ICAL.Component|String} nameOrComp    Name of component, or component\n     * @return {Boolean}                            True when comp is removed\n     */\n    removeSubcomponent: function(nameOrComp) {\n      var removed = this._removeObject(COMPONENT_INDEX, '_components', nameOrComp);\n      if (removed) {\n        this._hydratedComponentCount--;\n      }\n      return removed;\n    },\n\n    /**\n     * Removes all components or (if given) all components by a particular\n     * name.\n     *\n     * @param {String=} name            Lowercase component name\n     */\n    removeAllSubcomponents: function(name) {\n      var removed = this._removeAllObjects(COMPONENT_INDEX, '_components', name);\n      this._hydratedComponentCount = 0;\n      return removed;\n    },\n\n    /**\n     * Adds an {@link ICAL.Property} to the component.\n     *\n     * @param {ICAL.Property} property      The property to add\n     * @return {ICAL.Property}              The passed in property\n     */\n    addProperty: function(property) {\n      if (!(property instanceof ICAL.Property)) {\n        throw new TypeError('must instance of ICAL.Property');\n      }\n\n      if (!this._properties) {\n        this._properties = [];\n        this._hydratedPropertyCount = 0;\n      }\n\n      if (property.parent) {\n        property.parent.removeProperty(property);\n      }\n\n      var idx = this.jCal[PROPERTY_INDEX].push(property.jCal);\n      this._properties[idx - 1] = property;\n      this._hydratedPropertyCount++;\n      property.parent = this;\n      return property;\n    },\n\n    /**\n     * Helper method to add a property with a value to the component.\n     *\n     * @param {String}               name         Property name to add\n     * @param {String|Number|Object} value        Property value\n     * @return {ICAL.Property}                    The created property\n     */\n    addPropertyWithValue: function(name, value) {\n      var prop = new ICAL.Property(name);\n      prop.setValue(value);\n\n      this.addProperty(prop);\n\n      return prop;\n    },\n\n    /**\n     * Helper method that will update or create a property of the given name\n     * and sets its value. If multiple properties with the given name exist,\n     * only the first is updated.\n     *\n     * @param {String}               name         Property name to update\n     * @param {String|Number|Object} value        Property value\n     * @return {ICAL.Property}                    The created property\n     */\n    updatePropertyWithValue: function(name, value) {\n      var prop = this.getFirstProperty(name);\n\n      if (prop) {\n        prop.setValue(value);\n      } else {\n        prop = this.addPropertyWithValue(name, value);\n      }\n\n      return prop;\n    },\n\n    /**\n     * Removes a single property by name or the instance of the specific\n     * property.\n     *\n     * @param {String|ICAL.Property} nameOrProp     Property name or instance to remove\n     * @return {Boolean}                            True, when deleted\n     */\n    removeProperty: function(nameOrProp) {\n      var removed = this._removeObject(PROPERTY_INDEX, '_properties', nameOrProp);\n      if (removed) {\n        this._hydratedPropertyCount--;\n      }\n      return removed;\n    },\n\n    /**\n     * Removes all properties associated with this component, optionally\n     * filtered by name.\n     *\n     * @param {String=} name        Lowercase property name\n     * @return {Boolean}            True, when deleted\n     */\n    removeAllProperties: function(name) {\n      var removed = this._removeAllObjects(PROPERTY_INDEX, '_properties', name);\n      this._hydratedPropertyCount = 0;\n      return removed;\n    },\n\n    /**\n     * Returns the Object representation of this component. The returned object\n     * is a live jCal object and should be cloned if modified.\n     * @return {Object}\n     */\n    toJSON: function() {\n      return this.jCal;\n    },\n\n    /**\n     * The string representation of this component.\n     * @return {String}\n     */\n    toString: function() {\n      return ICAL.stringify.component(\n        this.jCal, this._designSet\n      );\n    }\n  };\n\n  /**\n   * Create an {@link ICAL.Component} by parsing the passed iCalendar string.\n   *\n   * @param {String} str        The iCalendar string to parse\n   */\n  Component.fromString = function(str) {\n    return new Component(ICAL.parse.component(str));\n  };\n\n  return Component;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.Property = (function() {\n  'use strict';\n\n  var NAME_INDEX = 0;\n  var PROP_INDEX = 1;\n  var TYPE_INDEX = 2;\n  var VALUE_INDEX = 3;\n\n  var design = ICAL.design;\n\n  /**\n   * @classdesc\n   * Provides a layer on top of the raw jCal object for manipulating a single\n   * property, with its parameters and value.\n   *\n   * @description\n   * It is important to note that mutations done in the wrapper\n   * directly mutate the jCal object used to initialize.\n   *\n   * Can also be used to create new properties by passing\n   * the name of the property (as a String).\n   *\n   * @class\n   * @alias ICAL.Property\n   * @param {Array|String} jCal         Raw jCal representation OR\n   *  the new name of the property\n   *\n   * @param {ICAL.Component=} parent    Parent component\n   */\n  function Property(jCal, parent) {\n    this._parent = parent || null;\n\n    if (typeof(jCal) === 'string') {\n      // We are creating the property by name and need to detect the type\n      this.jCal = [jCal, {}, design.defaultType];\n      this.jCal[TYPE_INDEX] = this.getDefaultType();\n    } else {\n      this.jCal = jCal;\n    }\n    this._updateType();\n  }\n\n  Property.prototype = {\n\n    /**\n     * The value type for this property\n     * @readonly\n     * @type {String}\n     */\n    get type() {\n      return this.jCal[TYPE_INDEX];\n    },\n\n    /**\n     * The name of this property, in lowercase.\n     * @readonly\n     * @type {String}\n     */\n    get name() {\n      return this.jCal[NAME_INDEX];\n    },\n\n    /**\n     * The parent component for this property.\n     * @type {ICAL.Component}\n     */\n    get parent() {\n      return this._parent;\n    },\n\n    set parent(p) {\n      // Before setting the parent, check if the design set has changed. If it\n      // has, we later need to update the type if it was unknown before.\n      var designSetChanged = !this._parent || (p && p._designSet != this._parent._designSet);\n\n      this._parent = p;\n\n      if (this.type == design.defaultType && designSetChanged) {\n        this.jCal[TYPE_INDEX] = this.getDefaultType();\n        this._updateType();\n      }\n\n      return p;\n    },\n\n    /**\n     * The design set for this property, e.g. icalendar vs vcard\n     *\n     * @type {ICAL.design.designSet}\n     * @private\n     */\n    get _designSet() {\n      return this.parent ? this.parent._designSet : design.defaultSet;\n    },\n\n    /**\n     * Updates the type metadata from the current jCal type and design set.\n     *\n     * @private\n     */\n    _updateType: function() {\n      var designSet = this._designSet;\n\n      if (this.type in designSet.value) {\n        var designType = designSet.value[this.type];\n\n        if ('decorate' in designSet.value[this.type]) {\n          this.isDecorated = true;\n        } else {\n          this.isDecorated = false;\n        }\n\n        if (this.name in designSet.property) {\n          this.isMultiValue = ('multiValue' in designSet.property[this.name]);\n          this.isStructuredValue = ('structuredValue' in designSet.property[this.name]);\n        }\n      }\n    },\n\n    /**\n     * Hydrate a single value. The act of hydrating means turning the raw jCal\n     * value into a potentially wrapped object, for example {@link ICAL.Time}.\n     *\n     * @private\n     * @param {Number} index        The index of the value to hydrate\n     * @return {Object}             The decorated value.\n     */\n    _hydrateValue: function(index) {\n      if (this._values && this._values[index]) {\n        return this._values[index];\n      }\n\n      // for the case where there is no value.\n      if (this.jCal.length <= (VALUE_INDEX + index)) {\n        return null;\n      }\n\n      if (this.isDecorated) {\n        if (!this._values) {\n          this._values = [];\n        }\n        return (this._values[index] = this._decorate(\n          this.jCal[VALUE_INDEX + index]\n        ));\n      } else {\n        return this.jCal[VALUE_INDEX + index];\n      }\n    },\n\n    /**\n     * Decorate a single value, returning its wrapped object. This is used by\n     * the hydrate function to actually wrap the value.\n     *\n     * @private\n     * @param {?} value         The value to decorate\n     * @return {Object}         The decorated value\n     */\n    _decorate: function(value) {\n      return this._designSet.value[this.type].decorate(value, this);\n    },\n\n    /**\n     * Undecorate a single value, returning its raw jCal data.\n     *\n     * @private\n     * @param {Object} value         The value to undecorate\n     * @return {?}                   The undecorated value\n     */\n    _undecorate: function(value) {\n      return this._designSet.value[this.type].undecorate(value, this);\n    },\n\n    /**\n     * Sets the value at the given index while also hydrating it. The passed\n     * value can either be a decorated or undecorated value.\n     *\n     * @private\n     * @param {?} value             The value to set\n     * @param {Number} index        The index to set it at\n     */\n    _setDecoratedValue: function(value, index) {\n      if (!this._values) {\n        this._values = [];\n      }\n\n      if (typeof(value) === 'object' && 'icaltype' in value) {\n        // decorated value\n        this.jCal[VALUE_INDEX + index] = this._undecorate(value);\n        this._values[index] = value;\n      } else {\n        // undecorated value\n        this.jCal[VALUE_INDEX + index] = value;\n        this._values[index] = this._decorate(value);\n      }\n    },\n\n    /**\n     * Gets a parameter on the property.\n     *\n     * @param {String}        name   Parameter name (lowercase)\n     * @return {Array|String}        Parameter value\n     */\n    getParameter: function(name) {\n      if (name in this.jCal[PROP_INDEX]) {\n        return this.jCal[PROP_INDEX][name];\n      } else {\n        return undefined;\n      }\n    },\n\n    /**\n     * Gets first parameter on the property.\n     *\n     * @param {String}        name   Parameter name (lowercase)\n     * @return {String}        Parameter value\n     */\n    getFirstParameter: function(name) {\n      var parameters = this.getParameter(name);\n\n      if (Array.isArray(parameters)) {\n        return parameters[0];\n      }\n\n      return parameters;\n    },\n\n    /**\n     * Sets a parameter on the property.\n     *\n     * @param {String}       name     The parameter name\n     * @param {Array|String} value    The parameter value\n     */\n    setParameter: function(name, value) {\n      var lcname = name.toLowerCase();\n      if (typeof value === \"string\" &&\n          lcname in this._designSet.param &&\n          'multiValue' in this._designSet.param[lcname]) {\n          value = [value];\n      }\n      this.jCal[PROP_INDEX][name] = value;\n    },\n\n    /**\n     * Removes a parameter\n     *\n     * @param {String} name     The parameter name\n     */\n    removeParameter: function(name) {\n      delete this.jCal[PROP_INDEX][name];\n    },\n\n    /**\n     * Get the default type based on this property's name.\n     *\n     * @return {String}     The default type for this property\n     */\n    getDefaultType: function() {\n      var name = this.jCal[NAME_INDEX];\n      var designSet = this._designSet;\n\n      if (name in designSet.property) {\n        var details = designSet.property[name];\n        if ('defaultType' in details) {\n          return details.defaultType;\n        }\n      }\n      return design.defaultType;\n    },\n\n    /**\n     * Sets type of property and clears out any existing values of the current\n     * type.\n     *\n     * @param {String} type     New iCAL type (see design.*.values)\n     */\n    resetType: function(type) {\n      this.removeAllValues();\n      this.jCal[TYPE_INDEX] = type;\n      this._updateType();\n    },\n\n    /**\n     * Finds the first property value.\n     *\n     * @return {String}         First property value\n     */\n    getFirstValue: function() {\n      return this._hydrateValue(0);\n    },\n\n    /**\n     * Gets all values on the property.\n     *\n     * NOTE: this creates an array during each call.\n     *\n     * @return {Array}          List of values\n     */\n    getValues: function() {\n      var len = this.jCal.length - VALUE_INDEX;\n\n      if (len < 1) {\n        // it is possible for a property to have no value.\n        return [];\n      }\n\n      var i = 0;\n      var result = [];\n\n      for (; i < len; i++) {\n        result[i] = this._hydrateValue(i);\n      }\n\n      return result;\n    },\n\n    /**\n     * Removes all values from this property\n     */\n    removeAllValues: function() {\n      if (this._values) {\n        this._values.length = 0;\n      }\n      this.jCal.length = 3;\n    },\n\n    /**\n     * Sets the values of the property.  Will overwrite the existing values.\n     * This can only be used for multi-value properties.\n     *\n     * @param {Array} values    An array of values\n     */\n    setValues: function(values) {\n      if (!this.isMultiValue) {\n        throw new Error(\n          this.name + ': does not not support mulitValue.\\n' +\n          'override isMultiValue'\n        );\n      }\n\n      var len = values.length;\n      var i = 0;\n      this.removeAllValues();\n\n      if (len > 0 &&\n          typeof(values[0]) === 'object' &&\n          'icaltype' in values[0]) {\n        this.resetType(values[0].icaltype);\n      }\n\n      if (this.isDecorated) {\n        for (; i < len; i++) {\n          this._setDecoratedValue(values[i], i);\n        }\n      } else {\n        for (; i < len; i++) {\n          this.jCal[VALUE_INDEX + i] = values[i];\n        }\n      }\n    },\n\n    /**\n     * Sets the current value of the property. If this is a multi-value\n     * property, all other values will be removed.\n     *\n     * @param {String|Object} value     New property value.\n     */\n    setValue: function(value) {\n      this.removeAllValues();\n      if (typeof(value) === 'object' && 'icaltype' in value) {\n        this.resetType(value.icaltype);\n      }\n\n      if (this.isDecorated) {\n        this._setDecoratedValue(value, 0);\n      } else {\n        this.jCal[VALUE_INDEX] = value;\n      }\n    },\n\n    /**\n     * Returns the Object representation of this component. The returned object\n     * is a live jCal object and should be cloned if modified.\n     * @return {Object}\n     */\n    toJSON: function() {\n      return this.jCal;\n    },\n\n    /**\n     * The string representation of this component.\n     * @return {String}\n     */\n    toICALString: function() {\n      return ICAL.stringify.property(\n        this.jCal, this._designSet, true\n      );\n    }\n  };\n\n  /**\n   * Create an {@link ICAL.Property} by parsing the passed iCalendar string.\n   *\n   * @param {String} str                        The iCalendar string to parse\n   * @param {ICAL.design.designSet=} designSet  The design data to use for this property\n   * @return {ICAL.Property}                    The created iCalendar property\n   */\n  Property.fromString = function(str, designSet) {\n    return new Property(ICAL.parse.property(str, designSet));\n  };\n\n  return Property;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.UtcOffset = (function() {\n\n  /**\n   * @classdesc\n   * This class represents the \"duration\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @class\n   * @alias ICAL.UtcOffset\n   * @param {Object} aData          An object with members of the utc offset\n   * @param {Number=} aData.hours   The hours for the utc offset\n   * @param {Number=} aData.minutes The minutes in the utc offset\n   * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1\n   */\n  function UtcOffset(aData) {\n    this.fromData(aData);\n  }\n\n  UtcOffset.prototype = {\n\n    /**\n     * The hours in the utc-offset\n     * @type {Number}\n     */\n    hours: 0,\n\n    /**\n     * The minutes in the utc-offset\n     * @type {Number}\n     */\n    minutes: 0,\n\n    /**\n     * The sign of the utc offset, 1 for positive offset, -1 for negative\n     * offsets.\n     * @type {Number}\n     */\n    factor: 1,\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"utc-offset\"\n     */\n    icaltype: \"utc-offset\",\n\n    /**\n     * Returns a clone of the utc offset object.\n     *\n     * @return {ICAL.UtcOffset}     The cloned object\n     */\n    clone: function() {\n      return ICAL.UtcOffset.fromSeconds(this.toSeconds());\n    },\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} aData          An object with members of the utc offset\n     * @param {Number=} aData.hours   The hours for the utc offset\n     * @param {Number=} aData.minutes The minutes in the utc offset\n     * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1\n     */\n    fromData: function(aData) {\n      if (aData) {\n        for (var key in aData) {\n          /* istanbul ignore else */\n          if (aData.hasOwnProperty(key)) {\n            this[key] = aData[key];\n          }\n        }\n      }\n      this._normalize();\n    },\n\n    /**\n     * Sets up the current instance from the given seconds value. The seconds\n     * value is truncated to the minute. Offsets are wrapped when the world\n     * ends, the hour after UTC+14:00 is UTC-12:00.\n     *\n     * @param {Number} aSeconds         The seconds to convert into an offset\n     */\n    fromSeconds: function(aSeconds) {\n      var secs = Math.abs(aSeconds);\n\n      this.factor = aSeconds < 0 ? -1 : 1;\n      this.hours = ICAL.helpers.trunc(secs / 3600);\n\n      secs -= (this.hours * 3600);\n      this.minutes = ICAL.helpers.trunc(secs / 60);\n      return this;\n    },\n\n    /**\n     * Convert the current offset to a value in seconds\n     *\n     * @return {Number}                 The offset in seconds\n     */\n    toSeconds: function() {\n      return this.factor * (60 * this.minutes + 3600 * this.hours);\n    },\n\n    /**\n     * Compare this utc offset with another one.\n     *\n     * @param {ICAL.UtcOffset} other        The other offset to compare with\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */\n    compare: function icaltime_compare(other) {\n      var a = this.toSeconds();\n      var b = other.toSeconds();\n      return (a > b) - (b > a);\n    },\n\n    _normalize: function() {\n      // Range: 97200 seconds (with 1 hour inbetween)\n      var secs = this.toSeconds();\n      var factor = this.factor;\n      while (secs < -43200) { // = UTC-12:00\n        secs += 97200;\n      }\n      while (secs > 50400) { // = UTC+14:00\n        secs -= 97200;\n      }\n\n      this.fromSeconds(secs);\n\n      // Avoid changing the factor when on zero seconds\n      if (secs == 0) {\n        this.factor = factor;\n      }\n    },\n\n    /**\n     * The iCalendar string representation of this utc-offset.\n     * @return {String}\n     */\n    toICALString: function() {\n      return ICAL.design.icalendar.value['utc-offset'].toICAL(this.toString());\n    },\n\n    /**\n     * The string representation of this utc-offset.\n     * @return {String}\n     */\n    toString: function toString() {\n      return (this.factor == 1 ? \"+\" : \"-\") +\n              ICAL.helpers.pad2(this.hours) + ':' +\n              ICAL.helpers.pad2(this.minutes);\n    }\n  };\n\n  /**\n   * Creates a new {@link ICAL.UtcOffset} instance from the passed string.\n   *\n   * @param {String} aString    The string to parse\n   * @return {ICAL.Duration}    The created utc-offset instance\n   */\n  UtcOffset.fromString = function(aString) {\n    // -05:00\n    var options = {};\n    //TODO: support seconds per rfc5545 ?\n    options.factor = (aString[0] === '+') ? 1 : -1;\n    options.hours = ICAL.helpers.strictParseInt(aString.substr(1, 2));\n    options.minutes = ICAL.helpers.strictParseInt(aString.substr(4, 2));\n\n    return new ICAL.UtcOffset(options);\n  };\n\n  /**\n   * Creates a new {@link ICAL.UtcOffset} instance from the passed seconds\n   * value.\n   *\n   * @param {Number} aSeconds       The number of seconds to convert\n   */\n  UtcOffset.fromSeconds = function(aSeconds) {\n    var instance = new UtcOffset();\n    instance.fromSeconds(aSeconds);\n    return instance;\n  };\n\n  return UtcOffset;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.Binary = (function() {\n\n  /**\n   * @classdesc\n   * Represents the BINARY value type, which contains extra methods for\n   * encoding and decoding.\n   *\n   * @class\n   * @alias ICAL.Binary\n   * @param {String} aValue     The binary data for this value\n   */\n  function Binary(aValue) {\n    this.value = aValue;\n  }\n\n  Binary.prototype = {\n    /**\n     * The type name, to be used in the jCal object.\n     * @default \"binary\"\n     * @constant\n     */\n    icaltype: \"binary\",\n\n    /**\n     * Base64 decode the current value\n     *\n     * @return {String}         The base64-decoded value\n     */\n    decodeValue: function decodeValue() {\n      return this._b64_decode(this.value);\n    },\n\n    /**\n     * Encodes the passed parameter with base64 and sets the internal\n     * value to the result.\n     *\n     * @param {String} aValue      The raw binary value to encode\n     */\n    setEncodedValue: function setEncodedValue(aValue) {\n      this.value = this._b64_encode(aValue);\n    },\n\n    _b64_encode: function base64_encode(data) {\n      // http://kevin.vanzonneveld.net\n      // +   original by: Tyler Akins (http://rumkin.com)\n      // +   improved by: Bayron Guevara\n      // +   improved by: Thunder.m\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +   bugfixed by: Pellentesque Malesuada\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +   improved by: Rafał Kukawski (http://kukawski.pl)\n      // *     example 1: base64_encode('Kevin van Zonneveld');\n      // *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='\n      // mozilla has this native\n      // - but breaks in 2.0.0.12!\n      //if (typeof this.window['atob'] == 'function') {\n      //    return atob(data);\n      //}\n      var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" +\n                \"abcdefghijklmnopqrstuvwxyz0123456789+/=\";\n      var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,\n        ac = 0,\n        enc = \"\",\n        tmp_arr = [];\n\n      if (!data) {\n        return data;\n      }\n\n      do { // pack three octets into four hexets\n        o1 = data.charCodeAt(i++);\n        o2 = data.charCodeAt(i++);\n        o3 = data.charCodeAt(i++);\n\n        bits = o1 << 16 | o2 << 8 | o3;\n\n        h1 = bits >> 18 & 0x3f;\n        h2 = bits >> 12 & 0x3f;\n        h3 = bits >> 6 & 0x3f;\n        h4 = bits & 0x3f;\n\n        // use hexets to index into b64, and append result to encoded string\n        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);\n      } while (i < data.length);\n\n      enc = tmp_arr.join('');\n\n      var r = data.length % 3;\n\n      return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);\n\n    },\n\n    _b64_decode: function base64_decode(data) {\n      // http://kevin.vanzonneveld.net\n      // +   original by: Tyler Akins (http://rumkin.com)\n      // +   improved by: Thunder.m\n      // +      input by: Aman Gupta\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +   bugfixed by: Onno Marsman\n      // +   bugfixed by: Pellentesque Malesuada\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +      input by: Brett Zamir (http://brett-zamir.me)\n      // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // *     example 1: base64_decode('S2V2aW4gdmFuIFpvbm5ldmVsZA==');\n      // *     returns 1: 'Kevin van Zonneveld'\n      // mozilla has this native\n      // - but breaks in 2.0.0.12!\n      //if (typeof this.window['btoa'] == 'function') {\n      //    return btoa(data);\n      //}\n      var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" +\n                \"abcdefghijklmnopqrstuvwxyz0123456789+/=\";\n      var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,\n        ac = 0,\n        dec = \"\",\n        tmp_arr = [];\n\n      if (!data) {\n        return data;\n      }\n\n      data += '';\n\n      do { // unpack four hexets into three octets using index points in b64\n        h1 = b64.indexOf(data.charAt(i++));\n        h2 = b64.indexOf(data.charAt(i++));\n        h3 = b64.indexOf(data.charAt(i++));\n        h4 = b64.indexOf(data.charAt(i++));\n\n        bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;\n\n        o1 = bits >> 16 & 0xff;\n        o2 = bits >> 8 & 0xff;\n        o3 = bits & 0xff;\n\n        if (h3 == 64) {\n          tmp_arr[ac++] = String.fromCharCode(o1);\n        } else if (h4 == 64) {\n          tmp_arr[ac++] = String.fromCharCode(o1, o2);\n        } else {\n          tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);\n        }\n      } while (i < data.length);\n\n      dec = tmp_arr.join('');\n\n      return dec;\n    },\n\n    /**\n     * The string representation of this value\n     * @return {String}\n     */\n    toString: function() {\n      return this.value;\n    }\n  };\n\n  /**\n   * Creates a binary value from the given string.\n   *\n   * @param {String} aString        The binary value string\n   * @return {ICAL.Binary}          The binary value instance\n   */\n  Binary.fromString = function(aString) {\n    return new Binary(aString);\n  };\n\n  return Binary;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n\n(function() {\n  /**\n   * @classdesc\n   * This class represents the \"period\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @description\n   * The passed data object cannot contain both and end date and a duration.\n   *\n   * @class\n   * @param {Object} aData                  An object with members of the period\n   * @param {ICAL.Time=} aData.start        The start of the period\n   * @param {ICAL.Time=} aData.end          The end of the period\n   * @param {ICAL.Duration=} aData.duration The duration of the period\n   */\n  ICAL.Period = function icalperiod(aData) {\n    this.wrappedJSObject = this;\n\n    if (aData && 'start' in aData) {\n      if (aData.start && !(aData.start instanceof ICAL.Time)) {\n        throw new TypeError('.start must be an instance of ICAL.Time');\n      }\n      this.start = aData.start;\n    }\n\n    if (aData && aData.end && aData.duration) {\n      throw new Error('cannot accept both end and duration');\n    }\n\n    if (aData && 'end' in aData) {\n      if (aData.end && !(aData.end instanceof ICAL.Time)) {\n        throw new TypeError('.end must be an instance of ICAL.Time');\n      }\n      this.end = aData.end;\n    }\n\n    if (aData && 'duration' in aData) {\n      if (aData.duration && !(aData.duration instanceof ICAL.Duration)) {\n        throw new TypeError('.duration must be an instance of ICAL.Duration');\n      }\n      this.duration = aData.duration;\n    }\n  };\n\n  ICAL.Period.prototype = {\n\n    /**\n     * The start of the period\n     * @type {ICAL.Time}\n     */\n    start: null,\n\n    /**\n     * The end of the period\n     * @type {ICAL.Time}\n     */\n    end: null,\n\n    /**\n     * The duration of the period\n     * @type {ICAL.Duration}\n     */\n    duration: null,\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icalperiod\"\n     */\n    icalclass: \"icalperiod\",\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"period\"\n     */\n    icaltype: \"period\",\n\n    /**\n     * Returns a clone of the duration object.\n     *\n     * @return {ICAL.Period}      The cloned object\n     */\n    clone: function() {\n      return ICAL.Period.fromData({\n        start: this.start ? this.start.clone() : null,\n        end: this.end ? this.end.clone() : null,\n        duration: this.duration ? this.duration.clone() : null\n      });\n    },\n\n    /**\n     * Calculates the duration of the period, either directly or by subtracting\n     * start from end date.\n     *\n     * @return {ICAL.Duration}      The calculated duration\n     */\n    getDuration: function duration() {\n      if (this.duration) {\n        return this.duration;\n      } else {\n        return this.end.subtractDate(this.start);\n      }\n    },\n\n    /**\n     * Calculates the end date of the period, either directly or by adding\n     * duration to start date.\n     *\n     * @return {ICAL.Time}          The calculated end date\n     */\n    getEnd: function() {\n      if (this.end) {\n        return this.end;\n      } else {\n        var end = this.start.clone();\n        end.addDuration(this.duration);\n        return end;\n      }\n    },\n\n    /**\n     * The string representation of this period.\n     * @return {String}\n     */\n    toString: function toString() {\n      return this.start + \"/\" + (this.end || this.duration);\n    },\n\n    /**\n     * The jCal representation of this period type.\n     * @return {Object}\n     */\n    toJSON: function() {\n      return [this.start.toString(), (this.end || this.duration).toString()];\n    },\n\n    /**\n     * The iCalendar string representation of this period.\n     * @return {String}\n     */\n    toICALString: function() {\n      return this.start.toICALString() + \"/\" +\n             (this.end || this.duration).toICALString();\n    }\n  };\n\n  /**\n   * Creates a new {@link ICAL.Period} instance from the passed string.\n   *\n   * @param {String} str            The string to parse\n   * @param {ICAL.Property} prop    The property this period will be on\n   * @return {ICAL.Period}          The created period instance\n   */\n  ICAL.Period.fromString = function fromString(str, prop) {\n    var parts = str.split('/');\n\n    if (parts.length !== 2) {\n      throw new Error(\n        'Invalid string value: \"' + str + '\" must contain a \"/\" char.'\n      );\n    }\n\n    var options = {\n      start: ICAL.Time.fromDateTimeString(parts[0], prop)\n    };\n\n    var end = parts[1];\n\n    if (ICAL.Duration.isValueString(end)) {\n      options.duration = ICAL.Duration.fromString(end);\n    } else {\n      options.end = ICAL.Time.fromDateTimeString(end, prop);\n    }\n\n    return new ICAL.Period(options);\n  };\n\n  /**\n   * Creates a new {@link ICAL.Period} instance from the given data object.\n   * The passed data object cannot contain both and end date and a duration.\n   *\n   * @param {Object} aData                  An object with members of the period\n   * @param {ICAL.Time=} aData.start        The start of the period\n   * @param {ICAL.Time=} aData.end          The end of the period\n   * @param {ICAL.Duration=} aData.duration The duration of the period\n   * @return {ICAL.Period}                  The period instance\n   */\n  ICAL.Period.fromData = function fromData(aData) {\n    return new ICAL.Period(aData);\n  };\n\n  /**\n   * Returns a new period instance from the given jCal data array. The first\n   * member is always the start date string, the second member is either a\n   * duration or end date string.\n   *\n   * @param {Array<String,String>} aData    The jCal data array\n   * @param {ICAL.Property} aProp           The property this jCal data is on\n   * @param {Boolean} aLenient              If true, data value can be both date and date-time\n   * @return {ICAL.Period}                  The period instance\n   */\n  ICAL.Period.fromJSON = function(aData, aProp, aLenient) {\n    function fromDateOrDateTimeString(aValue, aProp) {\n      if (aLenient) {\n        return ICAL.Time.fromString(aValue, aProp);\n      } else {\n        return ICAL.Time.fromDateTimeString(aValue, aProp);\n      }\n    }\n\n    if (ICAL.Duration.isValueString(aData[1])) {\n      return ICAL.Period.fromData({\n        start: fromDateOrDateTimeString(aData[0], aProp),\n        duration: ICAL.Duration.fromString(aData[1])\n      });\n    } else {\n      return ICAL.Period.fromData({\n        start: fromDateOrDateTimeString(aData[0], aProp),\n        end: fromDateOrDateTimeString(aData[1], aProp)\n      });\n    }\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n\n(function() {\n  var DURATION_LETTERS = /([PDWHMTS]{1,1})/;\n\n  /**\n   * @classdesc\n   * This class represents the \"duration\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @class\n   * @alias ICAL.Duration\n   * @param {Object} data               An object with members of the duration\n   * @param {Number} data.weeks         Duration in weeks\n   * @param {Number} data.days          Duration in days\n   * @param {Number} data.hours         Duration in hours\n   * @param {Number} data.minutes       Duration in minutes\n   * @param {Number} data.seconds       Duration in seconds\n   * @param {Boolean} data.isNegative   If true, the duration is negative\n   */\n  ICAL.Duration = function icalduration(data) {\n    this.wrappedJSObject = this;\n    this.fromData(data);\n  };\n\n  ICAL.Duration.prototype = {\n    /**\n     * The weeks in this duration\n     * @type {Number}\n     * @default 0\n     */\n    weeks: 0,\n\n    /**\n     * The days in this duration\n     * @type {Number}\n     * @default 0\n     */\n    days: 0,\n\n    /**\n     * The days in this duration\n     * @type {Number}\n     * @default 0\n     */\n    hours: 0,\n\n    /**\n     * The minutes in this duration\n     * @type {Number}\n     * @default 0\n     */\n    minutes: 0,\n\n    /**\n     * The seconds in this duration\n     * @type {Number}\n     * @default 0\n     */\n    seconds: 0,\n\n    /**\n     * The seconds in this duration\n     * @type {Boolean}\n     * @default false\n     */\n    isNegative: false,\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icalduration\"\n     */\n    icalclass: \"icalduration\",\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"duration\"\n     */\n    icaltype: \"duration\",\n\n    /**\n     * Returns a clone of the duration object.\n     *\n     * @return {ICAL.Duration}      The cloned object\n     */\n    clone: function clone() {\n      return ICAL.Duration.fromData(this);\n    },\n\n    /**\n     * The duration value expressed as a number of seconds.\n     *\n     * @return {Number}             The duration value in seconds\n     */\n    toSeconds: function toSeconds() {\n      var seconds = this.seconds + 60 * this.minutes + 3600 * this.hours +\n                    86400 * this.days + 7 * 86400 * this.weeks;\n      return (this.isNegative ? -seconds : seconds);\n    },\n\n    /**\n     * Reads the passed seconds value into this duration object. Afterwards,\n     * members like {@link ICAL.Duration#days days} and {@link ICAL.Duration#weeks weeks} will be set up\n     * accordingly.\n     *\n     * @param {Number} aSeconds     The duration value in seconds\n     * @return {ICAL.Duration}      Returns this instance\n     */\n    fromSeconds: function fromSeconds(aSeconds) {\n      var secs = Math.abs(aSeconds);\n\n      this.isNegative = (aSeconds < 0);\n      this.days = ICAL.helpers.trunc(secs / 86400);\n\n      // If we have a flat number of weeks, use them.\n      if (this.days % 7 == 0) {\n        this.weeks = this.days / 7;\n        this.days = 0;\n      } else {\n        this.weeks = 0;\n      }\n\n      secs -= (this.days + 7 * this.weeks) * 86400;\n\n      this.hours = ICAL.helpers.trunc(secs / 3600);\n      secs -= this.hours * 3600;\n\n      this.minutes = ICAL.helpers.trunc(secs / 60);\n      secs -= this.minutes * 60;\n\n      this.seconds = secs;\n      return this;\n    },\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} aData               An object with members of the duration\n     * @param {Number} aData.weeks         Duration in weeks\n     * @param {Number} aData.days          Duration in days\n     * @param {Number} aData.hours         Duration in hours\n     * @param {Number} aData.minutes       Duration in minutes\n     * @param {Number} aData.seconds       Duration in seconds\n     * @param {Boolean} aData.isNegative   If true, the duration is negative\n     */\n    fromData: function fromData(aData) {\n      var propsToCopy = [\"weeks\", \"days\", \"hours\",\n                         \"minutes\", \"seconds\", \"isNegative\"];\n      for (var key in propsToCopy) {\n        /* istanbul ignore if */\n        if (!propsToCopy.hasOwnProperty(key)) {\n          continue;\n        }\n        var prop = propsToCopy[key];\n        if (aData && prop in aData) {\n          this[prop] = aData[prop];\n        } else {\n          this[prop] = 0;\n        }\n      }\n    },\n\n    /**\n     * Resets the duration instance to the default values, i.e. PT0S\n     */\n    reset: function reset() {\n      this.isNegative = false;\n      this.weeks = 0;\n      this.days = 0;\n      this.hours = 0;\n      this.minutes = 0;\n      this.seconds = 0;\n    },\n\n    /**\n     * Compares the duration instance with another one.\n     *\n     * @param {ICAL.Duration} aOther        The instance to compare with\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */\n    compare: function compare(aOther) {\n      var thisSeconds = this.toSeconds();\n      var otherSeconds = aOther.toSeconds();\n      return (thisSeconds > otherSeconds) - (thisSeconds < otherSeconds);\n    },\n\n    /**\n     * Normalizes the duration instance. For example, a duration with a value\n     * of 61 seconds will be normalized to 1 minute and 1 second.\n     */\n    normalize: function normalize() {\n      this.fromSeconds(this.toSeconds());\n    },\n\n    /**\n     * The string representation of this duration.\n     * @return {String}\n     */\n    toString: function toString() {\n      if (this.toSeconds() == 0) {\n        return \"PT0S\";\n      } else {\n        var str = \"\";\n        if (this.isNegative) str += \"-\";\n        str += \"P\";\n        if (this.weeks) str += this.weeks + \"W\";\n        if (this.days) str += this.days + \"D\";\n\n        if (this.hours || this.minutes || this.seconds) {\n          str += \"T\";\n          if (this.hours) str += this.hours + \"H\";\n          if (this.minutes) str += this.minutes + \"M\";\n          if (this.seconds) str += this.seconds + \"S\";\n        }\n        return str;\n      }\n    },\n\n    /**\n     * The iCalendar string representation of this duration.\n     * @return {String}\n     */\n    toICALString: function() {\n      return this.toString();\n    }\n  };\n\n  /**\n   * Returns a new ICAL.Duration instance from the passed seconds value.\n   *\n   * @param {Number} aSeconds       The seconds to create the instance from\n   * @return {ICAL.Duration}        The newly created duration instance\n   */\n  ICAL.Duration.fromSeconds = function icalduration_from_seconds(aSeconds) {\n    return (new ICAL.Duration()).fromSeconds(aSeconds);\n  };\n\n  /**\n   * Internal helper function to handle a chunk of a duration.\n   *\n   * @param {String} letter type of duration chunk\n   * @param {String} number numeric value or -/+\n   * @param {Object} dict target to assign values to\n   */\n  function parseDurationChunk(letter, number, object) {\n    var type;\n    switch (letter) {\n      case 'P':\n        if (number && number === '-') {\n          object.isNegative = true;\n        } else {\n          object.isNegative = false;\n        }\n        // period\n        break;\n      case 'D':\n        type = 'days';\n        break;\n      case 'W':\n        type = 'weeks';\n        break;\n      case 'H':\n        type = 'hours';\n        break;\n      case 'M':\n        type = 'minutes';\n        break;\n      case 'S':\n        type = 'seconds';\n        break;\n      default:\n        // Not a valid chunk\n        return 0;\n    }\n\n    if (type) {\n      if (!number && number !== 0) {\n        throw new Error(\n          'invalid duration value: Missing number before \"' + letter + '\"'\n        );\n      }\n      var num = parseInt(number, 10);\n      if (ICAL.helpers.isStrictlyNaN(num)) {\n        throw new Error(\n          'invalid duration value: Invalid number \"' + number + '\" before \"' + letter + '\"'\n        );\n      }\n      object[type] = num;\n    }\n\n    return 1;\n  }\n\n  /**\n   * Checks if the given string is an iCalendar duration value.\n   *\n   * @param {String} value      The raw ical value\n   * @return {Boolean}          True, if the given value is of the\n   *                              duration ical type\n   */\n  ICAL.Duration.isValueString = function(string) {\n    return (string[0] === 'P' || string[1] === 'P');\n  };\n\n  /**\n   * Creates a new {@link ICAL.Duration} instance from the passed string.\n   *\n   * @param {String} aStr       The string to parse\n   * @return {ICAL.Duration}    The created duration instance\n   */\n  ICAL.Duration.fromString = function icalduration_from_string(aStr) {\n    var pos = 0;\n    var dict = Object.create(null);\n    var chunks = 0;\n\n    while ((pos = aStr.search(DURATION_LETTERS)) !== -1) {\n      var type = aStr[pos];\n      var numeric = aStr.substr(0, pos);\n      aStr = aStr.substr(pos + 1);\n\n      chunks += parseDurationChunk(type, numeric, dict);\n    }\n\n    if (chunks < 2) {\n      // There must be at least a chunk with \"P\" and some unit chunk\n      throw new Error(\n        'invalid duration value: Not enough duration components in \"' + aStr + '\"'\n      );\n    }\n\n    return new ICAL.Duration(dict);\n  };\n\n  /**\n   * Creates a new ICAL.Duration instance from the given data object.\n   *\n   * @param {Object} aData               An object with members of the duration\n   * @param {Number} aData.weeks         Duration in weeks\n   * @param {Number} aData.days          Duration in days\n   * @param {Number} aData.hours         Duration in hours\n   * @param {Number} aData.minutes       Duration in minutes\n   * @param {Number} aData.seconds       Duration in seconds\n   * @param {Boolean} aData.isNegative   If true, the duration is negative\n   * @return {ICAL.Duration}             The createad duration instance\n   */\n  ICAL.Duration.fromData = function icalduration_from_data(aData) {\n    return new ICAL.Duration(aData);\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2012 */\n\n\n\n(function() {\n  var OPTIONS = [\"tzid\", \"location\", \"tznames\",\n                 \"latitude\", \"longitude\"];\n\n  /**\n   * @classdesc\n   * Timezone representation, created by passing in a tzid and component.\n   *\n   * @example\n   * var vcalendar;\n   * var timezoneComp = vcalendar.getFirstSubcomponent('vtimezone');\n   * var tzid = timezoneComp.getFirstPropertyValue('tzid');\n   *\n   * var timezone = new ICAL.Timezone({\n   *   component: timezoneComp,\n   *   tzid\n   * });\n   *\n   * @class\n   * @param {ICAL.Component|Object} data options for class\n   * @param {String|ICAL.Component} data.component\n   *        If data is a simple object, then this member can be set to either a\n   *        string containing the component data, or an already parsed\n   *        ICAL.Component\n   * @param {String} data.tzid      The timezone identifier\n   * @param {String} data.location  The timezone locationw\n   * @param {String} data.tznames   An alternative string representation of the\n   *                                  timezone\n   * @param {Number} data.latitude  The latitude of the timezone\n   * @param {Number} data.longitude The longitude of the timezone\n   */\n  ICAL.Timezone = function icaltimezone(data) {\n    this.wrappedJSObject = this;\n    this.fromData(data);\n  };\n\n  ICAL.Timezone.prototype = {\n\n    /**\n     * Timezone identifier\n     * @type {String}\n     */\n    tzid: \"\",\n\n    /**\n     * Timezone location\n     * @type {String}\n     */\n    location: \"\",\n\n    /**\n     * Alternative timezone name, for the string representation\n     * @type {String}\n     */\n    tznames: \"\",\n\n    /**\n     * The primary latitude for the timezone.\n     * @type {Number}\n     */\n    latitude: 0.0,\n\n    /**\n     * The primary longitude for the timezone.\n     * @type {Number}\n     */\n    longitude: 0.0,\n\n    /**\n     * The vtimezone component for this timezone.\n     * @type {ICAL.Component}\n     */\n    component: null,\n\n    /**\n     * The year this timezone has been expanded to. All timezone transition\n     * dates until this year are known and can be used for calculation\n     *\n     * @private\n     * @type {Number}\n     */\n    expandedUntilYear: 0,\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icaltimezone\"\n     */\n    icalclass: \"icaltimezone\",\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {ICAL.Component|Object} aData options for class\n     * @param {String|ICAL.Component} aData.component\n     *        If aData is a simple object, then this member can be set to either a\n     *        string containing the component data, or an already parsed\n     *        ICAL.Component\n     * @param {String} aData.tzid      The timezone identifier\n     * @param {String} aData.location  The timezone locationw\n     * @param {String} aData.tznames   An alternative string representation of the\n     *                                  timezone\n     * @param {Number} aData.latitude  The latitude of the timezone\n     * @param {Number} aData.longitude The longitude of the timezone\n     */\n    fromData: function fromData(aData) {\n      this.expandedUntilYear = 0;\n      this.changes = [];\n\n      if (aData instanceof ICAL.Component) {\n        // Either a component is passed directly\n        this.component = aData;\n      } else {\n        // Otherwise the component may be in the data object\n        if (aData && \"component\" in aData) {\n          if (typeof aData.component == \"string\") {\n            // If a string was passed, parse it as a component\n            var jCal = ICAL.parse(aData.component);\n            this.component = new ICAL.Component(jCal);\n          } else if (aData.component instanceof ICAL.Component) {\n            // If it was a component already, then just set it\n            this.component = aData.component;\n          } else {\n            // Otherwise just null out the component\n            this.component = null;\n          }\n        }\n\n        // Copy remaining passed properties\n        for (var key in OPTIONS) {\n          /* istanbul ignore else */\n          if (OPTIONS.hasOwnProperty(key)) {\n            var prop = OPTIONS[key];\n            if (aData && prop in aData) {\n              this[prop] = aData[prop];\n            }\n          }\n        }\n      }\n\n      // If we have a component but no TZID, attempt to get it from the\n      // component's properties.\n      if (this.component instanceof ICAL.Component && !this.tzid) {\n        this.tzid = this.component.getFirstPropertyValue('tzid');\n      }\n\n      return this;\n    },\n\n    /**\n     * Finds the utcOffset the given time would occur in this timezone.\n     *\n     * @param {ICAL.Time} tt        The time to check for\n     * @return {Number} utc offset in seconds\n     */\n    utcOffset: function utcOffset(tt) {\n      if (this == ICAL.Timezone.utcTimezone || this == ICAL.Timezone.localTimezone) {\n        return 0;\n      }\n\n      this._ensureCoverage(tt.year);\n\n      if (!this.changes.length) {\n        return 0;\n      }\n\n      var tt_change = {\n        year: tt.year,\n        month: tt.month,\n        day: tt.day,\n        hour: tt.hour,\n        minute: tt.minute,\n        second: tt.second\n      };\n\n      var change_num = this._findNearbyChange(tt_change);\n      var change_num_to_use = -1;\n      var step = 1;\n\n      // TODO: replace with bin search?\n      for (;;) {\n        var change = ICAL.helpers.clone(this.changes[change_num], true);\n        if (change.utcOffset < change.prevUtcOffset) {\n          ICAL.Timezone.adjust_change(change, 0, 0, 0, change.utcOffset);\n        } else {\n          ICAL.Timezone.adjust_change(change, 0, 0, 0,\n                                          change.prevUtcOffset);\n        }\n\n        var cmp = ICAL.Timezone._compare_change_fn(tt_change, change);\n\n        if (cmp >= 0) {\n          change_num_to_use = change_num;\n        } else {\n          step = -1;\n        }\n\n        if (step == -1 && change_num_to_use != -1) {\n          break;\n        }\n\n        change_num += step;\n\n        if (change_num < 0) {\n          return 0;\n        }\n\n        if (change_num >= this.changes.length) {\n          break;\n        }\n      }\n\n      var zone_change = this.changes[change_num_to_use];\n      var utcOffset_change = zone_change.utcOffset - zone_change.prevUtcOffset;\n\n      if (utcOffset_change < 0 && change_num_to_use > 0) {\n        var tmp_change = ICAL.helpers.clone(zone_change, true);\n        ICAL.Timezone.adjust_change(tmp_change, 0, 0, 0,\n                                        tmp_change.prevUtcOffset);\n\n        if (ICAL.Timezone._compare_change_fn(tt_change, tmp_change) < 0) {\n          var prev_zone_change = this.changes[change_num_to_use - 1];\n\n          var want_daylight = false; // TODO\n\n          if (zone_change.is_daylight != want_daylight &&\n              prev_zone_change.is_daylight == want_daylight) {\n            zone_change = prev_zone_change;\n          }\n        }\n      }\n\n      // TODO return is_daylight?\n      return zone_change.utcOffset;\n    },\n\n    _findNearbyChange: function icaltimezone_find_nearby_change(change) {\n      // find the closest match\n      var idx = ICAL.helpers.binsearchInsert(\n        this.changes,\n        change,\n        ICAL.Timezone._compare_change_fn\n      );\n\n      if (idx >= this.changes.length) {\n        return this.changes.length - 1;\n      }\n\n      return idx;\n    },\n\n    _ensureCoverage: function(aYear) {\n      if (ICAL.Timezone._minimumExpansionYear == -1) {\n        var today = ICAL.Time.now();\n        ICAL.Timezone._minimumExpansionYear = today.year;\n      }\n\n      var changesEndYear = aYear;\n      if (changesEndYear < ICAL.Timezone._minimumExpansionYear) {\n        changesEndYear = ICAL.Timezone._minimumExpansionYear;\n      }\n\n      changesEndYear += ICAL.Timezone.EXTRA_COVERAGE;\n\n      if (changesEndYear > ICAL.Timezone.MAX_YEAR) {\n        changesEndYear = ICAL.Timezone.MAX_YEAR;\n      }\n\n      if (!this.changes.length || this.expandedUntilYear < aYear) {\n        var subcomps = this.component.getAllSubcomponents();\n        var compLen = subcomps.length;\n        var compIdx = 0;\n\n        for (; compIdx < compLen; compIdx++) {\n          this._expandComponent(\n            subcomps[compIdx], changesEndYear, this.changes\n          );\n        }\n\n        this.changes.sort(ICAL.Timezone._compare_change_fn);\n        this.expandedUntilYear = changesEndYear;\n      }\n    },\n\n    _expandComponent: function(aComponent, aYear, changes) {\n      if (!aComponent.hasProperty(\"dtstart\") ||\n          !aComponent.hasProperty(\"tzoffsetto\") ||\n          !aComponent.hasProperty(\"tzoffsetfrom\")) {\n        return null;\n      }\n\n      var dtstart = aComponent.getFirstProperty(\"dtstart\").getFirstValue();\n      var change;\n\n      function convert_tzoffset(offset) {\n        return offset.factor * (offset.hours * 3600 + offset.minutes * 60);\n      }\n\n      function init_changes() {\n        var changebase = {};\n        changebase.is_daylight = (aComponent.name == \"daylight\");\n        changebase.utcOffset = convert_tzoffset(\n          aComponent.getFirstProperty(\"tzoffsetto\").getFirstValue()\n        );\n\n        changebase.prevUtcOffset = convert_tzoffset(\n          aComponent.getFirstProperty(\"tzoffsetfrom\").getFirstValue()\n        );\n\n        return changebase;\n      }\n\n      if (!aComponent.hasProperty(\"rrule\") && !aComponent.hasProperty(\"rdate\")) {\n        change = init_changes();\n        change.year = dtstart.year;\n        change.month = dtstart.month;\n        change.day = dtstart.day;\n        change.hour = dtstart.hour;\n        change.minute = dtstart.minute;\n        change.second = dtstart.second;\n\n        ICAL.Timezone.adjust_change(change, 0, 0, 0,\n                                        -change.prevUtcOffset);\n        changes.push(change);\n      } else {\n        var props = aComponent.getAllProperties(\"rdate\");\n        for (var rdatekey in props) {\n          /* istanbul ignore if */\n          if (!props.hasOwnProperty(rdatekey)) {\n            continue;\n          }\n          var rdate = props[rdatekey];\n          var time = rdate.getFirstValue();\n          change = init_changes();\n\n          change.year = time.year;\n          change.month = time.month;\n          change.day = time.day;\n\n          if (time.isDate) {\n            change.hour = dtstart.hour;\n            change.minute = dtstart.minute;\n            change.second = dtstart.second;\n\n            if (dtstart.zone != ICAL.Timezone.utcTimezone) {\n              ICAL.Timezone.adjust_change(change, 0, 0, 0,\n                                              -change.prevUtcOffset);\n            }\n          } else {\n            change.hour = time.hour;\n            change.minute = time.minute;\n            change.second = time.second;\n\n            if (time.zone != ICAL.Timezone.utcTimezone) {\n              ICAL.Timezone.adjust_change(change, 0, 0, 0,\n                                              -change.prevUtcOffset);\n            }\n          }\n\n          changes.push(change);\n        }\n\n        var rrule = aComponent.getFirstProperty(\"rrule\");\n\n        if (rrule) {\n          rrule = rrule.getFirstValue();\n          change = init_changes();\n\n          if (rrule.until && rrule.until.zone == ICAL.Timezone.utcTimezone) {\n            rrule.until.adjust(0, 0, 0, change.prevUtcOffset);\n            rrule.until.zone = ICAL.Timezone.localTimezone;\n          }\n\n          var iterator = rrule.iterator(dtstart);\n\n          var occ;\n          while ((occ = iterator.next())) {\n            change = init_changes();\n            if (occ.year > aYear || !occ) {\n              break;\n            }\n\n            change.year = occ.year;\n            change.month = occ.month;\n            change.day = occ.day;\n            change.hour = occ.hour;\n            change.minute = occ.minute;\n            change.second = occ.second;\n            change.isDate = occ.isDate;\n\n            ICAL.Timezone.adjust_change(change, 0, 0, 0,\n                                            -change.prevUtcOffset);\n            changes.push(change);\n          }\n        }\n      }\n\n      return changes;\n    },\n\n    /**\n     * The string representation of this timezone.\n     * @return {String}\n     */\n    toString: function toString() {\n      return (this.tznames ? this.tznames : this.tzid);\n    }\n  };\n\n  ICAL.Timezone._compare_change_fn = function icaltimezone_compare_change_fn(a, b) {\n    if (a.year < b.year) return -1;\n    else if (a.year > b.year) return 1;\n\n    if (a.month < b.month) return -1;\n    else if (a.month > b.month) return 1;\n\n    if (a.day < b.day) return -1;\n    else if (a.day > b.day) return 1;\n\n    if (a.hour < b.hour) return -1;\n    else if (a.hour > b.hour) return 1;\n\n    if (a.minute < b.minute) return -1;\n    else if (a.minute > b.minute) return 1;\n\n    if (a.second < b.second) return -1;\n    else if (a.second > b.second) return 1;\n\n    return 0;\n  };\n\n  /**\n   * Convert the date/time from one zone to the next.\n   *\n   * @param {ICAL.Time} tt                  The time to convert\n   * @param {ICAL.Timezone} from_zone       The source zone to convert from\n   * @param {ICAL.Timezone} to_zone         The target zone to convert to\n   * @return {ICAL.Time}                    The converted date/time object\n   */\n  ICAL.Timezone.convert_time = function icaltimezone_convert_time(tt, from_zone, to_zone) {\n    if (tt.isDate ||\n        from_zone.tzid == to_zone.tzid ||\n        from_zone == ICAL.Timezone.localTimezone ||\n        to_zone == ICAL.Timezone.localTimezone) {\n      tt.zone = to_zone;\n      return tt;\n    }\n\n    var utcOffset = from_zone.utcOffset(tt);\n    tt.adjust(0, 0, 0, - utcOffset);\n\n    utcOffset = to_zone.utcOffset(tt);\n    tt.adjust(0, 0, 0, utcOffset);\n\n    return null;\n  };\n\n  /**\n   * Creates a new ICAL.Timezone instance from the passed data object.\n   *\n   * @param {ICAL.Component|Object} aData options for class\n   * @param {String|ICAL.Component} aData.component\n   *        If aData is a simple object, then this member can be set to either a\n   *        string containing the component data, or an already parsed\n   *        ICAL.Component\n   * @param {String} aData.tzid      The timezone identifier\n   * @param {String} aData.location  The timezone locationw\n   * @param {String} aData.tznames   An alternative string representation of the\n   *                                  timezone\n   * @param {Number} aData.latitude  The latitude of the timezone\n   * @param {Number} aData.longitude The longitude of the timezone\n   */\n  ICAL.Timezone.fromData = function icaltimezone_fromData(aData) {\n    var tt = new ICAL.Timezone();\n    return tt.fromData(aData);\n  };\n\n  /**\n   * The instance describing the UTC timezone\n   * @type {ICAL.Timezone}\n   * @constant\n   * @instance\n   */\n  ICAL.Timezone.utcTimezone = ICAL.Timezone.fromData({\n    tzid: \"UTC\"\n  });\n\n  /**\n   * The instance describing the local timezone\n   * @type {ICAL.Timezone}\n   * @constant\n   * @instance\n   */\n  ICAL.Timezone.localTimezone = ICAL.Timezone.fromData({\n    tzid: \"floating\"\n  });\n\n  /**\n   * Adjust a timezone change object.\n   * @private\n   * @param {Object} change     The timezone change object\n   * @param {Number} days       The extra amount of days\n   * @param {Number} hours      The extra amount of hours\n   * @param {Number} minutes    The extra amount of minutes\n   * @param {Number} seconds    The extra amount of seconds\n   */\n  ICAL.Timezone.adjust_change = function icaltimezone_adjust_change(change, days, hours, minutes, seconds) {\n    return ICAL.Time.prototype.adjust.call(\n      change,\n      days,\n      hours,\n      minutes,\n      seconds,\n      change\n    );\n  };\n\n  ICAL.Timezone._minimumExpansionYear = -1;\n  ICAL.Timezone.MAX_YEAR = 2035; // TODO this is because of time_t, which we don't need. Still usefull?\n  ICAL.Timezone.EXTRA_COVERAGE = 5;\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.TimezoneService = (function() {\n  var zones;\n\n  /**\n   * @classdesc\n   * Singleton class to contain timezones.  Right now it is all manual registry in\n   * the future we may use this class to download timezone information or handle\n   * loading pre-expanded timezones.\n   *\n   * @namespace\n   * @alias ICAL.TimezoneService\n   */\n  var TimezoneService = {\n    get count() {\n      return Object.keys(zones).length;\n    },\n\n    reset: function() {\n      zones = Object.create(null);\n      var utc = ICAL.Timezone.utcTimezone;\n\n      zones.Z = utc;\n      zones.UTC = utc;\n      zones.GMT = utc;\n    },\n\n    /**\n     * Checks if timezone id has been registered.\n     *\n     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\n     * @return {Boolean}        False, when not present\n     */\n    has: function(tzid) {\n      return !!zones[tzid];\n    },\n\n    /**\n     * Returns a timezone by its tzid if present.\n     *\n     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\n     * @return {?ICAL.Timezone} The timezone, or null if not found\n     */\n    get: function(tzid) {\n      return zones[tzid];\n    },\n\n    /**\n     * Registers a timezone object or component.\n     *\n     * @param {String=} name\n     *        The name of the timezone. Defaults to the component's TZID if not\n     *        passed.\n     * @param {ICAL.Component|ICAL.Timezone} zone\n     *        The initialized zone or vtimezone.\n     */\n    register: function(name, timezone) {\n      if (name instanceof ICAL.Component) {\n        if (name.name === 'vtimezone') {\n          timezone = new ICAL.Timezone(name);\n          name = timezone.tzid;\n        }\n      }\n\n      if (timezone instanceof ICAL.Timezone) {\n        zones[name] = timezone;\n      } else {\n        throw new TypeError('timezone must be ICAL.Timezone or ICAL.Component');\n      }\n    },\n\n    /**\n     * Removes a timezone by its tzid from the list.\n     *\n     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\n     * @return {?ICAL.Timezone} The removed timezone, or null if not registered\n     */\n    remove: function(tzid) {\n      return (delete zones[tzid]);\n    }\n  };\n\n  // initialize defaults\n  TimezoneService.reset();\n\n  return TimezoneService;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n\n(function() {\n\n  /**\n   * @classdesc\n   * iCalendar Time representation (similar to JS Date object).  Fully\n   * independent of system (OS) timezone / time.  Unlike JS Date, the month\n   * January is 1, not zero.\n   *\n   * @example\n   * var time = new ICAL.Time({\n   *   year: 2012,\n   *   month: 10,\n   *   day: 11\n   *   minute: 0,\n   *   second: 0,\n   *   isDate: false\n   * });\n   *\n   *\n   * @alias ICAL.Time\n   * @class\n   * @param {Object} data           Time initialization\n   * @param {Number=} data.year     The year for this date\n   * @param {Number=} data.month    The month for this date\n   * @param {Number=} data.day      The day for this date\n   * @param {Number=} data.hour     The hour for this date\n   * @param {Number=} data.minute   The minute for this date\n   * @param {Number=} data.second   The second for this date\n   * @param {Boolean=} data.isDate  If true, the instance represents a date (as\n   *                                  opposed to a date-time)\n   * @param {ICAL.Timezone} zone timezone this position occurs in\n   */\n  ICAL.Time = function icaltime(data, zone) {\n    this.wrappedJSObject = this;\n    var time = this._time = Object.create(null);\n\n    /* time defaults */\n    time.year = 0;\n    time.month = 1;\n    time.day = 1;\n    time.hour = 0;\n    time.minute = 0;\n    time.second = 0;\n    time.isDate = false;\n\n    this.fromData(data, zone);\n  };\n\n  ICAL.Time._dowCache = {};\n  ICAL.Time._wnCache = {};\n\n  ICAL.Time.prototype = {\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icaltime\"\n     */\n    icalclass: \"icaltime\",\n    _cachedUnixTime: null,\n\n    /**\n     * The type name, to be used in the jCal object. This value may change and\n     * is strictly defined by the {@link ICAL.Time#isDate isDate} member.\n     * @readonly\n     * @type {String}\n     * @default \"date-time\"\n     */\n    get icaltype() {\n      return this.isDate ? 'date' : 'date-time';\n    },\n\n    /**\n     * The timezone for this time.\n     * @type {ICAL.Timezone}\n     */\n    zone: null,\n\n    /**\n     * Internal uses to indicate that a change has been made and the next read\n     * operation must attempt to normalize the value (for example changing the\n     * day to 33).\n     *\n     * @type {Boolean}\n     * @private\n     */\n    _pendingNormalization: false,\n\n    /**\n     * Returns a clone of the time object.\n     *\n     * @return {ICAL.Time}              The cloned object\n     */\n    clone: function() {\n      return new ICAL.Time(this._time, this.zone);\n    },\n\n    /**\n     * Reset the time instance to epoch time\n     */\n    reset: function icaltime_reset() {\n      this.fromData(ICAL.Time.epochTime);\n      this.zone = ICAL.Timezone.utcTimezone;\n    },\n\n    /**\n     * Reset the time instance to the given date/time values.\n     *\n     * @param {Number} year             The year to set\n     * @param {Number} month            The month to set\n     * @param {Number} day              The day to set\n     * @param {Number} hour             The hour to set\n     * @param {Number} minute           The minute to set\n     * @param {Number} second           The second to set\n     * @param {ICAL.Timezone} timezone  The timezone to set\n     */\n    resetTo: function icaltime_resetTo(year, month, day,\n                                       hour, minute, second, timezone) {\n      this.fromData({\n        year: year,\n        month: month,\n        day: day,\n        hour: hour,\n        minute: minute,\n        second: second,\n        zone: timezone\n      });\n    },\n\n    /**\n     * Set up the current instance from the Javascript date value.\n     *\n     * @param {?Date} aDate     The Javascript Date to read, or null to reset\n     * @param {Boolean} useUTC  If true, the UTC values of the date will be used\n     */\n    fromJSDate: function icaltime_fromJSDate(aDate, useUTC) {\n      if (!aDate) {\n        this.reset();\n      } else {\n        if (useUTC) {\n          this.zone = ICAL.Timezone.utcTimezone;\n          this.year = aDate.getUTCFullYear();\n          this.month = aDate.getUTCMonth() + 1;\n          this.day = aDate.getUTCDate();\n          this.hour = aDate.getUTCHours();\n          this.minute = aDate.getUTCMinutes();\n          this.second = aDate.getUTCSeconds();\n        } else {\n          this.zone = ICAL.Timezone.localTimezone;\n          this.year = aDate.getFullYear();\n          this.month = aDate.getMonth() + 1;\n          this.day = aDate.getDate();\n          this.hour = aDate.getHours();\n          this.minute = aDate.getMinutes();\n          this.second = aDate.getSeconds();\n        }\n      }\n      this._cachedUnixTime = null;\n      return this;\n    },\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} aData            Time initialization\n     * @param {Number=} aData.year      The year for this date\n     * @param {Number=} aData.month     The month for this date\n     * @param {Number=} aData.day       The day for this date\n     * @param {Number=} aData.hour      The hour for this date\n     * @param {Number=} aData.minute    The minute for this date\n     * @param {Number=} aData.second    The second for this date\n     * @param {Boolean=} aData.isDate   If true, the instance represents a date\n     *                                    (as opposed to a date-time)\n     * @param {ICAL.Timezone=} aZone    Timezone this position occurs in\n     */\n    fromData: function fromData(aData, aZone) {\n      if (aData) {\n        for (var key in aData) {\n          /* istanbul ignore else */\n          if (Object.prototype.hasOwnProperty.call(aData, key)) {\n            // ical type cannot be set\n            if (key === 'icaltype') continue;\n            this[key] = aData[key];\n          }\n        }\n      }\n\n      if (aZone) {\n        this.zone = aZone;\n      }\n\n      if (aData && !(\"isDate\" in aData)) {\n        this.isDate = !(\"hour\" in aData);\n      } else if (aData && (\"isDate\" in aData)) {\n        this.isDate = aData.isDate;\n      }\n\n      if (aData && \"timezone\" in aData) {\n        var zone = ICAL.TimezoneService.get(\n          aData.timezone\n        );\n\n        this.zone = zone || ICAL.Timezone.localTimezone;\n      }\n\n      if (aData && \"zone\" in aData) {\n        this.zone = aData.zone;\n      }\n\n      if (!this.zone) {\n        this.zone = ICAL.Timezone.localTimezone;\n      }\n\n      this._cachedUnixTime = null;\n      return this;\n    },\n\n    /**\n     * Calculate the day of week.\n     * @param {ICAL.Time.weekDay=} aWeekStart\n     *        The week start weekday, defaults to SUNDAY\n     * @return {ICAL.Time.weekDay}\n     */\n    dayOfWeek: function icaltime_dayOfWeek(aWeekStart) {\n      var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n      var dowCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + firstDow;\n      if (dowCacheKey in ICAL.Time._dowCache) {\n        return ICAL.Time._dowCache[dowCacheKey];\n      }\n\n      // Using Zeller's algorithm\n      var q = this.day;\n      var m = this.month + (this.month < 3 ? 12 : 0);\n      var Y = this.year - (this.month < 3 ? 1 : 0);\n\n      var h = (q + Y + ICAL.helpers.trunc(((m + 1) * 26) / 10) + ICAL.helpers.trunc(Y / 4));\n      /* istanbul ignore else */\n      if (true /* gregorian */) {\n        h += ICAL.helpers.trunc(Y / 100) * 6 + ICAL.helpers.trunc(Y / 400);\n      } else {\n        h += 5;\n      }\n\n      // Normalize to 1 = wkst\n      h = ((h + 7 - firstDow) % 7) + 1;\n      ICAL.Time._dowCache[dowCacheKey] = h;\n      return h;\n    },\n\n    /**\n     * Calculate the day of year.\n     * @return {Number}\n     */\n    dayOfYear: function dayOfYear() {\n      var is_leap = (ICAL.Time.isLeapYear(this.year) ? 1 : 0);\n      var diypm = ICAL.Time.daysInYearPassedMonth;\n      return diypm[is_leap][this.month - 1] + this.day;\n    },\n\n    /**\n     * Returns a copy of the current date/time, rewound to the start of the\n     * week. The resulting ICAL.Time instance is of icaltype date, even if this\n     * is a date-time.\n     *\n     * @param {ICAL.Time.weekDay=} aWeekStart\n     *        The week start weekday, defaults to SUNDAY\n     * @return {ICAL.Time}      The start of the week (cloned)\n     */\n    startOfWeek: function startOfWeek(aWeekStart) {\n      var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n      var result = this.clone();\n      result.day -= ((this.dayOfWeek() + 7 - firstDow) % 7);\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, shifted to the end of the week.\n     * The resulting ICAL.Time instance is of icaltype date, even if this is a\n     * date-time.\n     *\n     * @param {ICAL.Time.weekDay=} aWeekStart\n     *        The week start weekday, defaults to SUNDAY\n     * @return {ICAL.Time}      The end of the week (cloned)\n     */\n    endOfWeek: function endOfWeek(aWeekStart) {\n      var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n      var result = this.clone();\n      result.day += (7 - this.dayOfWeek() + firstDow - ICAL.Time.SUNDAY) % 7;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, rewound to the start of the\n     * month. The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The start of the month (cloned)\n     */\n    startOfMonth: function startOfMonth() {\n      var result = this.clone();\n      result.day = 1;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, shifted to the end of the\n     * month.  The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The end of the month (cloned)\n     */\n    endOfMonth: function endOfMonth() {\n      var result = this.clone();\n      result.day = ICAL.Time.daysInMonth(result.month, result.year);\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, rewound to the start of the\n     * year. The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The start of the year (cloned)\n     */\n    startOfYear: function startOfYear() {\n      var result = this.clone();\n      result.day = 1;\n      result.month = 1;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, shifted to the end of the\n     * year.  The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The end of the year (cloned)\n     */\n    endOfYear: function endOfYear() {\n      var result = this.clone();\n      result.day = 31;\n      result.month = 12;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * First calculates the start of the week, then returns the day of year for\n     * this date. If the day falls into the previous year, the day is zero or negative.\n     *\n     * @param {ICAL.Time.weekDay=} aFirstDayOfWeek\n     *        The week start weekday, defaults to SUNDAY\n     * @return {Number}     The calculated day of year\n     */\n    startDoyWeek: function startDoyWeek(aFirstDayOfWeek) {\n      var firstDow = aFirstDayOfWeek || ICAL.Time.SUNDAY;\n      var delta = this.dayOfWeek() - firstDow;\n      if (delta < 0) delta += 7;\n      return this.dayOfYear() - delta;\n    },\n\n    /**\n     * Get the dominical letter for the current year. Letters range from A - G\n     * for common years, and AG to GF for leap years.\n     *\n     * @param {Number} yr           The year to retrieve the letter for\n     * @return {String}             The dominical letter.\n     */\n    getDominicalLetter: function() {\n      return ICAL.Time.getDominicalLetter(this.year);\n    },\n\n    /**\n     * Finds the nthWeekDay relative to the current month (not day).  The\n     * returned value is a day relative the month that this month belongs to so\n     * 1 would indicate the first of the month and 40 would indicate a day in\n     * the following month.\n     *\n     * @param {Number} aDayOfWeek   Day of the week see the day name constants\n     * @param {Number} aPos         Nth occurrence of a given week day values\n     *        of 1 and 0 both indicate the first weekday of that type. aPos may\n     *        be either positive or negative\n     *\n     * @return {Number} numeric value indicating a day relative\n     *                   to the current month of this time object\n     */\n    nthWeekDay: function icaltime_nthWeekDay(aDayOfWeek, aPos) {\n      var daysInMonth = ICAL.Time.daysInMonth(this.month, this.year);\n      var weekday;\n      var pos = aPos;\n\n      var start = 0;\n\n      var otherDay = this.clone();\n\n      if (pos >= 0) {\n        otherDay.day = 1;\n\n        // because 0 means no position has been given\n        // 1 and 0 indicate the same day.\n        if (pos != 0) {\n          // remove the extra numeric value\n          pos--;\n        }\n\n        // set current start offset to current day.\n        start = otherDay.day;\n\n        // find the current day of week\n        var startDow = otherDay.dayOfWeek();\n\n        // calculate the difference between current\n        // day of the week and desired day of the week\n        var offset = aDayOfWeek - startDow;\n\n\n        // if the offset goes into the past\n        // week we add 7 so it goes into the next\n        // week. We only want to go forward in time here.\n        if (offset < 0)\n          // this is really important otherwise we would\n          // end up with dates from in the past.\n          offset += 7;\n\n        // add offset to start so start is the same\n        // day of the week as the desired day of week.\n        start += offset;\n\n        // because we are going to add (and multiply)\n        // the numeric value of the day we subtract it\n        // from the start position so not to add it twice.\n        start -= aDayOfWeek;\n\n        // set week day\n        weekday = aDayOfWeek;\n      } else {\n\n        // then we set it to the last day in the current month\n        otherDay.day = daysInMonth;\n\n        // find the ends weekday\n        var endDow = otherDay.dayOfWeek();\n\n        pos++;\n\n        weekday = (endDow - aDayOfWeek);\n\n        if (weekday < 0) {\n          weekday += 7;\n        }\n\n        weekday = daysInMonth - weekday;\n      }\n\n      weekday += pos * 7;\n\n      return start + weekday;\n    },\n\n    /**\n     * Checks if current time is the nth weekday, relative to the current\n     * month.  Will always return false when rule resolves outside of current\n     * month.\n     *\n     * @param {ICAL.Time.weekDay} aDayOfWeek       Day of week to check\n     * @param {Number} aPos                        Relative position\n     * @return {Boolean}                           True, if it is the nth weekday\n     */\n    isNthWeekDay: function(aDayOfWeek, aPos) {\n      var dow = this.dayOfWeek();\n\n      if (aPos === 0 && dow === aDayOfWeek) {\n        return true;\n      }\n\n      // get pos\n      var day = this.nthWeekDay(aDayOfWeek, aPos);\n\n      if (day === this.day) {\n        return true;\n      }\n\n      return false;\n    },\n\n    /**\n     * Calculates the ISO 8601 week number. The first week of a year is the\n     * week that contains the first Thursday. The year can have 53 weeks, if\n     * January 1st is a Friday.\n     *\n     * Note there are regions where the first week of the year is the one that\n     * starts on January 1st, which may offset the week number. Also, if a\n     * different week start is specified, this will also affect the week\n     * number.\n     *\n     * @see ICAL.Time.weekOneStarts\n     * @param {ICAL.Time.weekDay} aWeekStart        The weekday the week starts with\n     * @return {Number}                             The ISO week number\n     */\n    weekNumber: function weekNumber(aWeekStart) {\n      var wnCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + aWeekStart;\n      if (wnCacheKey in ICAL.Time._wnCache) {\n        return ICAL.Time._wnCache[wnCacheKey];\n      }\n      // This function courtesty of Julian Bucknall, published under the MIT license\n      // http://www.boyet.com/articles/publishedarticles/calculatingtheisoweeknumb.html\n      // plus some fixes to be able to use different week starts.\n      var week1;\n\n      var dt = this.clone();\n      dt.isDate = true;\n      var isoyear = this.year;\n\n      if (dt.month == 12 && dt.day > 25) {\n        week1 = ICAL.Time.weekOneStarts(isoyear + 1, aWeekStart);\n        if (dt.compare(week1) < 0) {\n          week1 = ICAL.Time.weekOneStarts(isoyear, aWeekStart);\n        } else {\n          isoyear++;\n        }\n      } else {\n        week1 = ICAL.Time.weekOneStarts(isoyear, aWeekStart);\n        if (dt.compare(week1) < 0) {\n          week1 = ICAL.Time.weekOneStarts(--isoyear, aWeekStart);\n        }\n      }\n\n      var daysBetween = (dt.subtractDate(week1).toSeconds() / 86400);\n      var answer = ICAL.helpers.trunc(daysBetween / 7) + 1;\n      ICAL.Time._wnCache[wnCacheKey] = answer;\n      return answer;\n    },\n\n    /**\n     * Adds the duration to the current time. The instance is modified in\n     * place.\n     *\n     * @param {ICAL.Duration} aDuration         The duration to add\n     */\n    addDuration: function icaltime_add(aDuration) {\n      var mult = (aDuration.isNegative ? -1 : 1);\n\n      // because of the duration optimizations it is much\n      // more efficient to grab all the values up front\n      // then set them directly (which will avoid a normalization call).\n      // So we don't actually normalize until we need it.\n      var second = this.second;\n      var minute = this.minute;\n      var hour = this.hour;\n      var day = this.day;\n\n      second += mult * aDuration.seconds;\n      minute += mult * aDuration.minutes;\n      hour += mult * aDuration.hours;\n      day += mult * aDuration.days;\n      day += mult * 7 * aDuration.weeks;\n\n      this.second = second;\n      this.minute = minute;\n      this.hour = hour;\n      this.day = day;\n\n      this._cachedUnixTime = null;\n    },\n\n    /**\n     * Subtract the date details (_excluding_ timezone).  Useful for finding\n     * the relative difference between two time objects excluding their\n     * timezone differences.\n     *\n     * @param {ICAL.Time} aDate     The date to substract\n     * @return {ICAL.Duration}      The difference as a duration\n     */\n    subtractDate: function icaltime_subtract(aDate) {\n      var unixTime = this.toUnixTime() + this.utcOffset();\n      var other = aDate.toUnixTime() + aDate.utcOffset();\n      return ICAL.Duration.fromSeconds(unixTime - other);\n    },\n\n    /**\n     * Subtract the date details, taking timezones into account.\n     *\n     * @param {ICAL.Time} aDate  The date to subtract\n     * @return {ICAL.Duration}  The difference in duration\n     */\n    subtractDateTz: function icaltime_subtract_abs(aDate) {\n      var unixTime = this.toUnixTime();\n      var other = aDate.toUnixTime();\n      return ICAL.Duration.fromSeconds(unixTime - other);\n    },\n\n    /**\n     * Compares the ICAL.Time instance with another one.\n     *\n     * @param {ICAL.Duration} aOther        The instance to compare with\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */\n    compare: function icaltime_compare(other) {\n      var a = this.toUnixTime();\n      var b = other.toUnixTime();\n\n      if (a > b) return 1;\n      if (b > a) return -1;\n      return 0;\n    },\n\n    /**\n     * Compares only the date part of this instance with another one.\n     *\n     * @param {ICAL.Duration} other         The instance to compare with\n     * @param {ICAL.Timezone} tz            The timezone to compare in\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */\n    compareDateOnlyTz: function icaltime_compareDateOnlyTz(other, tz) {\n      function cmp(attr) {\n        return ICAL.Time._cmp_attr(a, b, attr);\n      }\n      var a = this.convertToZone(tz);\n      var b = other.convertToZone(tz);\n      var rc = 0;\n\n      if ((rc = cmp(\"year\")) != 0) return rc;\n      if ((rc = cmp(\"month\")) != 0) return rc;\n      if ((rc = cmp(\"day\")) != 0) return rc;\n\n      return rc;\n    },\n\n    /**\n     * Convert the instance into another timezone. The returned ICAL.Time\n     * instance is always a copy.\n     *\n     * @param {ICAL.Timezone} zone      The zone to convert to\n     * @return {ICAL.Time}              The copy, converted to the zone\n     */\n    convertToZone: function convertToZone(zone) {\n      var copy = this.clone();\n      var zone_equals = (this.zone.tzid == zone.tzid);\n\n      if (!this.isDate && !zone_equals) {\n        ICAL.Timezone.convert_time(copy, this.zone, zone);\n      }\n\n      copy.zone = zone;\n      return copy;\n    },\n\n    /**\n     * Calculates the UTC offset of the current date/time in the timezone it is\n     * in.\n     *\n     * @return {Number}     UTC offset in seconds\n     */\n    utcOffset: function utc_offset() {\n      if (this.zone == ICAL.Timezone.localTimezone ||\n          this.zone == ICAL.Timezone.utcTimezone) {\n        return 0;\n      } else {\n        return this.zone.utcOffset(this);\n      }\n    },\n\n    /**\n     * Returns an RFC 5545 compliant ical representation of this object.\n     *\n     * @return {String} ical date/date-time\n     */\n    toICALString: function() {\n      var string = this.toString();\n\n      if (string.length > 10) {\n        return ICAL.design.icalendar.value['date-time'].toICAL(string);\n      } else {\n        return ICAL.design.icalendar.value.date.toICAL(string);\n      }\n    },\n\n    /**\n     * The string representation of this date/time, in jCal form\n     * (including : and - separators).\n     * @return {String}\n     */\n    toString: function toString() {\n      var result = this.year + '-' +\n                   ICAL.helpers.pad2(this.month) + '-' +\n                   ICAL.helpers.pad2(this.day);\n\n      if (!this.isDate) {\n          result += 'T' + ICAL.helpers.pad2(this.hour) + ':' +\n                    ICAL.helpers.pad2(this.minute) + ':' +\n                    ICAL.helpers.pad2(this.second);\n\n        if (this.zone === ICAL.Timezone.utcTimezone) {\n          result += 'Z';\n        }\n      }\n\n      return result;\n    },\n\n    /**\n     * Converts the current instance to a Javascript date\n     * @return {Date}\n     */\n    toJSDate: function toJSDate() {\n      if (this.zone == ICAL.Timezone.localTimezone) {\n        if (this.isDate) {\n          return new Date(this.year, this.month - 1, this.day);\n        } else {\n          return new Date(this.year, this.month - 1, this.day,\n                          this.hour, this.minute, this.second, 0);\n        }\n      } else {\n        return new Date(this.toUnixTime() * 1000);\n      }\n    },\n\n    _normalize: function icaltime_normalize() {\n      var isDate = this._time.isDate;\n      if (this._time.isDate) {\n        this._time.hour = 0;\n        this._time.minute = 0;\n        this._time.second = 0;\n      }\n      this.adjust(0, 0, 0, 0);\n\n      return this;\n    },\n\n    /**\n     * Adjust the date/time by the given offset\n     *\n     * @param {Number} aExtraDays       The extra amount of days\n     * @param {Number} aExtraHours      The extra amount of hours\n     * @param {Number} aExtraMinutes    The extra amount of minutes\n     * @param {Number} aExtraSeconds    The extra amount of seconds\n     * @param {Number=} aTime           The time to adjust, defaults to the\n     *                                    current instance.\n     */\n    adjust: function icaltime_adjust(aExtraDays, aExtraHours,\n                                     aExtraMinutes, aExtraSeconds, aTime) {\n\n      var minutesOverflow, hoursOverflow,\n          daysOverflow = 0, yearsOverflow = 0;\n\n      var second, minute, hour, day;\n      var daysInMonth;\n\n      var time = aTime || this._time;\n\n      if (!time.isDate) {\n        second = time.second + aExtraSeconds;\n        time.second = second % 60;\n        minutesOverflow = ICAL.helpers.trunc(second / 60);\n        if (time.second < 0) {\n          time.second += 60;\n          minutesOverflow--;\n        }\n\n        minute = time.minute + aExtraMinutes + minutesOverflow;\n        time.minute = minute % 60;\n        hoursOverflow = ICAL.helpers.trunc(minute / 60);\n        if (time.minute < 0) {\n          time.minute += 60;\n          hoursOverflow--;\n        }\n\n        hour = time.hour + aExtraHours + hoursOverflow;\n\n        time.hour = hour % 24;\n        daysOverflow = ICAL.helpers.trunc(hour / 24);\n        if (time.hour < 0) {\n          time.hour += 24;\n          daysOverflow--;\n        }\n      }\n\n\n      // Adjust month and year first, because we need to know what month the day\n      // is in before adjusting it.\n      if (time.month > 12) {\n        yearsOverflow = ICAL.helpers.trunc((time.month - 1) / 12);\n      } else if (time.month < 1) {\n        yearsOverflow = ICAL.helpers.trunc(time.month / 12) - 1;\n      }\n\n      time.year += yearsOverflow;\n      time.month -= 12 * yearsOverflow;\n\n      // Now take care of the days (and adjust month if needed)\n      day = time.day + aExtraDays + daysOverflow;\n\n      if (day > 0) {\n        for (;;) {\n          daysInMonth = ICAL.Time.daysInMonth(time.month, time.year);\n          if (day <= daysInMonth) {\n            break;\n          }\n\n          time.month++;\n          if (time.month > 12) {\n            time.year++;\n            time.month = 1;\n          }\n\n          day -= daysInMonth;\n        }\n      } else {\n        while (day <= 0) {\n          if (time.month == 1) {\n            time.year--;\n            time.month = 12;\n          } else {\n            time.month--;\n          }\n\n          day += ICAL.Time.daysInMonth(time.month, time.year);\n        }\n      }\n\n      time.day = day;\n\n      this._cachedUnixTime = null;\n      return this;\n    },\n\n    /**\n     * Sets up the current instance from unix time, the number of seconds since\n     * January 1st, 1970.\n     *\n     * @param {Number} seconds      The seconds to set up with\n     */\n    fromUnixTime: function fromUnixTime(seconds) {\n      this.zone = ICAL.Timezone.utcTimezone;\n      var epoch = ICAL.Time.epochTime.clone();\n      epoch.adjust(0, 0, 0, seconds);\n\n      this.year = epoch.year;\n      this.month = epoch.month;\n      this.day = epoch.day;\n      this.hour = epoch.hour;\n      this.minute = epoch.minute;\n      this.second = Math.floor(epoch.second);\n\n      this._cachedUnixTime = null;\n    },\n\n    /**\n     * Converts the current instance to seconds since January 1st 1970.\n     *\n     * @return {Number}         Seconds since 1970\n     */\n    toUnixTime: function toUnixTime() {\n      if (this._cachedUnixTime !== null) {\n        return this._cachedUnixTime;\n      }\n      var offset = this.utcOffset();\n\n      // we use the offset trick to ensure\n      // that we are getting the actual UTC time\n      var ms = Date.UTC(\n        this.year,\n        this.month - 1,\n        this.day,\n        this.hour,\n        this.minute,\n        this.second - offset\n      );\n\n      // seconds\n      this._cachedUnixTime = ms / 1000;\n      return this._cachedUnixTime;\n    },\n\n    /**\n     * Converts time to into Object which can be serialized then re-created\n     * using the constructor.\n     *\n     * @example\n     * // toJSON will automatically be called\n     * var json = JSON.stringify(mytime);\n     *\n     * var deserialized = JSON.parse(json);\n     *\n     * var time = new ICAL.Time(deserialized);\n     *\n     * @return {Object}\n     */\n    toJSON: function() {\n      var copy = [\n        'year',\n        'month',\n        'day',\n        'hour',\n        'minute',\n        'second',\n        'isDate'\n      ];\n\n      var result = Object.create(null);\n\n      var i = 0;\n      var len = copy.length;\n      var prop;\n\n      for (; i < len; i++) {\n        prop = copy[i];\n        result[prop] = this[prop];\n      }\n\n      if (this.zone) {\n        result.timezone = this.zone.tzid;\n      }\n\n      return result;\n    }\n\n  };\n\n  (function setupNormalizeAttributes() {\n    // This needs to run before any instances are created!\n    function defineAttr(attr) {\n      Object.defineProperty(ICAL.Time.prototype, attr, {\n        get: function getTimeAttr() {\n          if (this._pendingNormalization) {\n            this._normalize();\n            this._pendingNormalization = false;\n          }\n\n          return this._time[attr];\n        },\n        set: function setTimeAttr(val) {\n          // Check if isDate will be set and if was not set to normalize date.\n          // This avoids losing days when seconds, minutes and hours are zeroed\n          // what normalize will do when time is a date.\n          if (attr === \"isDate\" && val && !this._time.isDate) {\n            this.adjust(0, 0, 0, 0);\n          }\n          this._cachedUnixTime = null;\n          this._pendingNormalization = true;\n          this._time[attr] = val;\n\n          return val;\n        }\n      });\n\n    }\n\n    /* istanbul ignore else */\n    if (\"defineProperty\" in Object) {\n      defineAttr(\"year\");\n      defineAttr(\"month\");\n      defineAttr(\"day\");\n      defineAttr(\"hour\");\n      defineAttr(\"minute\");\n      defineAttr(\"second\");\n      defineAttr(\"isDate\");\n    }\n  })();\n\n  /**\n   * Returns the days in the given month\n   *\n   * @param {Number} month      The month to check\n   * @param {Number} year       The year to check\n   * @return {Number}           The number of days in the month\n   */\n  ICAL.Time.daysInMonth = function icaltime_daysInMonth(month, year) {\n    var _daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    var days = 30;\n\n    if (month < 1 || month > 12) return days;\n\n    days = _daysInMonth[month];\n\n    if (month == 2) {\n      days += ICAL.Time.isLeapYear(year);\n    }\n\n    return days;\n  };\n\n  /**\n   * Checks if the year is a leap year\n   *\n   * @param {Number} year       The year to check\n   * @return {Boolean}          True, if the year is a leap year\n   */\n  ICAL.Time.isLeapYear = function isLeapYear(year) {\n    if (year <= 1752) {\n      return ((year % 4) == 0);\n    } else {\n      return (((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0));\n    }\n  };\n\n  /**\n   * Create a new ICAL.Time from the day of year and year. The date is returned\n   * in floating timezone.\n   *\n   * @param {Number} aDayOfYear     The day of year\n   * @param {Number} aYear          The year to create the instance in\n   * @return {ICAL.Time}            The created instance with the calculated date\n   */\n  ICAL.Time.fromDayOfYear = function icaltime_fromDayOfYear(aDayOfYear, aYear) {\n    var year = aYear;\n    var doy = aDayOfYear;\n    var tt = new ICAL.Time();\n    tt.auto_normalize = false;\n    var is_leap = (ICAL.Time.isLeapYear(year) ? 1 : 0);\n\n    if (doy < 1) {\n      year--;\n      is_leap = (ICAL.Time.isLeapYear(year) ? 1 : 0);\n      doy += ICAL.Time.daysInYearPassedMonth[is_leap][12];\n      return ICAL.Time.fromDayOfYear(doy, year);\n    } else if (doy > ICAL.Time.daysInYearPassedMonth[is_leap][12]) {\n      is_leap = (ICAL.Time.isLeapYear(year) ? 1 : 0);\n      doy -= ICAL.Time.daysInYearPassedMonth[is_leap][12];\n      year++;\n      return ICAL.Time.fromDayOfYear(doy, year);\n    }\n\n    tt.year = year;\n    tt.isDate = true;\n\n    for (var month = 11; month >= 0; month--) {\n      if (doy > ICAL.Time.daysInYearPassedMonth[is_leap][month]) {\n        tt.month = month + 1;\n        tt.day = doy - ICAL.Time.daysInYearPassedMonth[is_leap][month];\n        break;\n      }\n    }\n\n    tt.auto_normalize = true;\n    return tt;\n  };\n\n  /**\n   * Returns a new ICAL.Time instance from a date string, e.g 2015-01-02.\n   *\n   * @deprecated                Use {@link ICAL.Time.fromDateString} instead\n   * @param {String} str        The string to create from\n   * @return {ICAL.Time}        The date/time instance\n   */\n  ICAL.Time.fromStringv2 = function fromString(str) {\n    return new ICAL.Time({\n      year: parseInt(str.substr(0, 4), 10),\n      month: parseInt(str.substr(5, 2), 10),\n      day: parseInt(str.substr(8, 2), 10),\n      isDate: true\n    });\n  };\n\n  /**\n   * Returns a new ICAL.Time instance from a date string, e.g 2015-01-02.\n   *\n   * @param {String} aValue     The string to create from\n   * @return {ICAL.Time}        The date/time instance\n   */\n  ICAL.Time.fromDateString = function(aValue) {\n    // Dates should have no timezone.\n    // Google likes to sometimes specify Z on dates\n    // we specifically ignore that to avoid issues.\n\n    // YYYY-MM-DD\n    // 2012-10-10\n    return new ICAL.Time({\n      year: ICAL.helpers.strictParseInt(aValue.substr(0, 4)),\n      month: ICAL.helpers.strictParseInt(aValue.substr(5, 2)),\n      day: ICAL.helpers.strictParseInt(aValue.substr(8, 2)),\n      isDate: true\n    });\n  };\n\n  /**\n   * Returns a new ICAL.Time instance from a date-time string, e.g\n   * 2015-01-02T03:04:05. If a property is specified, the timezone is set up\n   * from the property's TZID parameter.\n   *\n   * @param {String} aValue         The string to create from\n   * @param {ICAL.Property=} prop   The property the date belongs to\n   * @return {ICAL.Time}            The date/time instance\n   */\n  ICAL.Time.fromDateTimeString = function(aValue, prop) {\n    if (aValue.length < 19) {\n      throw new Error(\n        'invalid date-time value: \"' + aValue + '\"'\n      );\n    }\n\n    var zone;\n\n    if (aValue[19] && aValue[19] === 'Z') {\n      zone = 'Z';\n    } else if (prop) {\n      zone = prop.getParameter('tzid');\n    }\n\n    // 2012-10-10T10:10:10(Z)?\n    var time = new ICAL.Time({\n      year: ICAL.helpers.strictParseInt(aValue.substr(0, 4)),\n      month: ICAL.helpers.strictParseInt(aValue.substr(5, 2)),\n      day: ICAL.helpers.strictParseInt(aValue.substr(8, 2)),\n      hour: ICAL.helpers.strictParseInt(aValue.substr(11, 2)),\n      minute: ICAL.helpers.strictParseInt(aValue.substr(14, 2)),\n      second: ICAL.helpers.strictParseInt(aValue.substr(17, 2)),\n      timezone: zone\n    });\n\n    return time;\n  };\n\n  /**\n   * Returns a new ICAL.Time instance from a date or date-time string,\n   *\n   * @param {String} aValue         The string to create from\n   * @param {ICAL.Property=} prop   The property the date belongs to\n   * @return {ICAL.Time}            The date/time instance\n   */\n  ICAL.Time.fromString = function fromString(aValue, aProperty) {\n    if (aValue.length > 10) {\n      return ICAL.Time.fromDateTimeString(aValue, aProperty);\n    } else {\n      return ICAL.Time.fromDateString(aValue);\n    }\n  };\n\n  /**\n   * Creates a new ICAL.Time instance from the given Javascript Date.\n   *\n   * @param {?Date} aDate     The Javascript Date to read, or null to reset\n   * @param {Boolean} useUTC  If true, the UTC values of the date will be used\n   */\n  ICAL.Time.fromJSDate = function fromJSDate(aDate, useUTC) {\n    var tt = new ICAL.Time();\n    return tt.fromJSDate(aDate, useUTC);\n  };\n\n  /**\n   * Creates a new ICAL.Time instance from the the passed data object.\n   *\n   * @param {Object} aData            Time initialization\n   * @param {Number=} aData.year      The year for this date\n   * @param {Number=} aData.month     The month for this date\n   * @param {Number=} aData.day       The day for this date\n   * @param {Number=} aData.hour      The hour for this date\n   * @param {Number=} aData.minute    The minute for this date\n   * @param {Number=} aData.second    The second for this date\n   * @param {Boolean=} aData.isDate   If true, the instance represents a date\n   *                                    (as opposed to a date-time)\n   * @param {ICAL.Timezone=} aZone    Timezone this position occurs in\n   */\n  ICAL.Time.fromData = function fromData(aData, aZone) {\n    var t = new ICAL.Time();\n    return t.fromData(aData, aZone);\n  };\n\n  /**\n   * Creates a new ICAL.Time instance from the current moment.\n   * The instance is “floating” - has no timezone relation.\n   * To create an instance considering the time zone, call\n   * ICAL.Time.fromJSDate(new Date(), true)\n   * @return {ICAL.Time}\n   */\n  ICAL.Time.now = function icaltime_now() {\n    return ICAL.Time.fromJSDate(new Date(), false);\n  };\n\n  /**\n   * Returns the date on which ISO week number 1 starts.\n   *\n   * @see ICAL.Time#weekNumber\n   * @param {Number} aYear                  The year to search in\n   * @param {ICAL.Time.weekDay=} aWeekStart The week start weekday, used for calculation.\n   * @return {ICAL.Time}                    The date on which week number 1 starts\n   */\n  ICAL.Time.weekOneStarts = function weekOneStarts(aYear, aWeekStart) {\n    var t = ICAL.Time.fromData({\n      year: aYear,\n      month: 1,\n      day: 1,\n      isDate: true\n    });\n\n    var dow = t.dayOfWeek();\n    var wkst = aWeekStart || ICAL.Time.DEFAULT_WEEK_START;\n    if (dow > ICAL.Time.THURSDAY) {\n      t.day += 7;\n    }\n    if (wkst > ICAL.Time.THURSDAY) {\n      t.day -= 7;\n    }\n\n    t.day -= dow - wkst;\n\n    return t;\n  };\n\n  /**\n   * Get the dominical letter for the given year. Letters range from A - G for\n   * common years, and AG to GF for leap years.\n   *\n   * @param {Number} yr           The year to retrieve the letter for\n   * @return {String}             The dominical letter.\n   */\n  ICAL.Time.getDominicalLetter = function(yr) {\n    var LTRS = \"GFEDCBA\";\n    var dom = (yr + (yr / 4 | 0) + (yr / 400 | 0) - (yr / 100 | 0) - 1) % 7;\n    var isLeap = ICAL.Time.isLeapYear(yr);\n    if (isLeap) {\n      return LTRS[(dom + 6) % 7] + LTRS[dom];\n    } else {\n      return LTRS[dom];\n    }\n  };\n\n  /**\n   * January 1st, 1970 as an ICAL.Time.\n   * @type {ICAL.Time}\n   * @constant\n   * @instance\n   */\n  ICAL.Time.epochTime = ICAL.Time.fromData({\n    year: 1970,\n    month: 1,\n    day: 1,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    isDate: false,\n    timezone: \"Z\"\n  });\n\n  ICAL.Time._cmp_attr = function _cmp_attr(a, b, attr) {\n    if (a[attr] > b[attr]) return 1;\n    if (a[attr] < b[attr]) return -1;\n    return 0;\n  };\n\n  /**\n   * The days that have passed in the year after a given month. The array has\n   * two members, one being an array of passed days for non-leap years, the\n   * other analog for leap years.\n   * @example\n   * var isLeapYear = ICAL.Time.isLeapYear(year);\n   * var passedDays = ICAL.Time.daysInYearPassedMonth[isLeapYear][month];\n   * @type {Array.<Array.<Number>>}\n   */\n  ICAL.Time.daysInYearPassedMonth = [\n    [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365],\n    [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366]\n  ];\n\n  /**\n   * The weekday, 1 = SUNDAY, 7 = SATURDAY. Access via\n   * ICAL.Time.MONDAY, ICAL.Time.TUESDAY, ...\n   *\n   * @typedef {Number} weekDay\n   * @memberof ICAL.Time\n   */\n\n  ICAL.Time.SUNDAY = 1;\n  ICAL.Time.MONDAY = 2;\n  ICAL.Time.TUESDAY = 3;\n  ICAL.Time.WEDNESDAY = 4;\n  ICAL.Time.THURSDAY = 5;\n  ICAL.Time.FRIDAY = 6;\n  ICAL.Time.SATURDAY = 7;\n\n  /**\n   * The default weekday for the WKST part.\n   * @constant\n   * @default ICAL.Time.MONDAY\n   */\n  ICAL.Time.DEFAULT_WEEK_START = ICAL.Time.MONDAY;\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2015 */\n\n\n\n(function() {\n\n  /**\n   * Describes a vCard time, which has slight differences to the ICAL.Time.\n   * Properties can be null if not specified, for example for dates with\n   * reduced accuracy or truncation.\n   *\n   * Note that currently not all methods are correctly re-implemented for\n   * VCardTime. For example, comparison will have undefined results when some\n   * members are null.\n   *\n   * Also, normalization is not yet implemented for this class!\n   *\n   * @alias ICAL.VCardTime\n   * @class\n   * @extends {ICAL.Time}\n   * @param {Object} data                           The data for the time instance\n   * @param {Number=} data.year                     The year for this date\n   * @param {Number=} data.month                    The month for this date\n   * @param {Number=} data.day                      The day for this date\n   * @param {Number=} data.hour                     The hour for this date\n   * @param {Number=} data.minute                   The minute for this date\n   * @param {Number=} data.second                   The second for this date\n   * @param {ICAL.Timezone|ICAL.UtcOffset} zone     The timezone to use\n   * @param {String} icaltype                       The type for this date/time object\n   */\n  ICAL.VCardTime = function(data, zone, icaltype) {\n    this.wrappedJSObject = this;\n    var time = this._time = Object.create(null);\n\n    time.year = null;\n    time.month = null;\n    time.day = null;\n    time.hour = null;\n    time.minute = null;\n    time.second = null;\n\n    this.icaltype = icaltype || \"date-and-or-time\";\n\n    this.fromData(data, zone);\n  };\n  ICAL.helpers.inherits(ICAL.Time, ICAL.VCardTime, /** @lends ICAL.VCardTime */ {\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"vcardtime\"\n     */\n    icalclass: \"vcardtime\",\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @type {String}\n     * @default \"date-and-or-time\"\n     */\n    icaltype: \"date-and-or-time\",\n\n    /**\n     * The timezone. This can either be floating, UTC, or an instance of\n     * ICAL.UtcOffset.\n     * @type {ICAL.Timezone|ICAL.UtcOFfset}\n     */\n    zone: null,\n\n    /**\n     * Returns a clone of the vcard date/time object.\n     *\n     * @return {ICAL.VCardTime}     The cloned object\n     */\n    clone: function() {\n      return new ICAL.VCardTime(this._time, this.zone, this.icaltype);\n    },\n\n    _normalize: function() {\n      return this;\n    },\n\n    /**\n     * @inheritdoc\n     */\n    utcOffset: function() {\n      if (this.zone instanceof ICAL.UtcOffset) {\n        return this.zone.toSeconds();\n      } else {\n        return ICAL.Time.prototype.utcOffset.apply(this, arguments);\n      }\n    },\n\n    /**\n     * Returns an RFC 6350 compliant representation of this object.\n     *\n     * @return {String}         vcard date/time string\n     */\n    toICALString: function() {\n      return ICAL.design.vcard.value[this.icaltype].toICAL(this.toString());\n    },\n\n    /**\n     * The string representation of this date/time, in jCard form\n     * (including : and - separators).\n     * @return {String}\n     */\n    toString: function toString() {\n      var p2 = ICAL.helpers.pad2;\n      var y = this.year, m = this.month, d = this.day;\n      var h = this.hour, mm = this.minute, s = this.second;\n\n      var hasYear = y !== null, hasMonth = m !== null, hasDay = d !== null;\n      var hasHour = h !== null, hasMinute = mm !== null, hasSecond = s !== null;\n\n      var datepart = (hasYear ? p2(y) + (hasMonth || hasDay ? '-' : '') : (hasMonth || hasDay ? '--' : '')) +\n                     (hasMonth ? p2(m) : '') +\n                     (hasDay ? '-' + p2(d) : '');\n      var timepart = (hasHour ? p2(h) : '-') + (hasHour && hasMinute ? ':' : '') +\n                     (hasMinute ? p2(mm) : '') + (!hasHour && !hasMinute ? '-' : '') +\n                     (hasMinute && hasSecond ? ':' : '') +\n                     (hasSecond ? p2(s) : '');\n\n      var zone;\n      if (this.zone === ICAL.Timezone.utcTimezone) {\n        zone = 'Z';\n      } else if (this.zone instanceof ICAL.UtcOffset) {\n        zone = this.zone.toString();\n      } else if (this.zone === ICAL.Timezone.localTimezone) {\n        zone = '';\n      } else if (this.zone instanceof ICAL.Timezone) {\n        var offset = ICAL.UtcOffset.fromSeconds(this.zone.utcOffset(this));\n        zone = offset.toString();\n      } else {\n        zone = '';\n      }\n\n      switch (this.icaltype) {\n        case \"time\":\n          return timepart + zone;\n        case \"date-and-or-time\":\n        case \"date-time\":\n          return datepart + (timepart == '--' ? '' : 'T' + timepart + zone);\n        case \"date\":\n          return datepart;\n      }\n      return null;\n    }\n  });\n\n  /**\n   * Returns a new ICAL.VCardTime instance from a date and/or time string.\n   *\n   * @param {String} aValue     The string to create from\n   * @param {String} aIcalType  The type for this instance, e.g. date-and-or-time\n   * @return {ICAL.VCardTime}   The date/time instance\n   */\n  ICAL.VCardTime.fromDateAndOrTimeString = function(aValue, aIcalType) {\n    function part(v, s, e) {\n      return v ? ICAL.helpers.strictParseInt(v.substr(s, e)) : null;\n    }\n    var parts = aValue.split('T');\n    var dt = parts[0], tmz = parts[1];\n    var splitzone = tmz ? ICAL.design.vcard.value.time._splitZone(tmz) : [];\n    var zone = splitzone[0], tm = splitzone[1];\n\n    var stoi = ICAL.helpers.strictParseInt;\n    var dtlen = dt ? dt.length : 0;\n    var tmlen = tm ? tm.length : 0;\n\n    var hasDashDate = dt && dt[0] == '-' && dt[1] == '-';\n    var hasDashTime = tm && tm[0] == '-';\n\n    var o = {\n      year: hasDashDate ? null : part(dt, 0, 4),\n      month: hasDashDate && (dtlen == 4 || dtlen == 7) ? part(dt, 2, 2) : dtlen == 7 ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 5, 2) : null,\n      day: dtlen == 5 ? part(dt, 3, 2) : dtlen == 7 && hasDashDate ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 8, 2) : null,\n\n      hour: hasDashTime ? null : part(tm, 0, 2),\n      minute: hasDashTime && tmlen == 3 ? part(tm, 1, 2) : tmlen > 4 ? hasDashTime ? part(tm, 1, 2) : part(tm, 3, 2) : null,\n      second: tmlen == 4 ? part(tm, 2, 2) : tmlen == 6 ? part(tm, 4, 2) : tmlen == 8 ? part(tm, 6, 2) : null\n    };\n\n    if (zone == 'Z') {\n      zone = ICAL.Timezone.utcTimezone;\n    } else if (zone && zone[3] == ':') {\n      zone = ICAL.UtcOffset.fromString(zone);\n    } else {\n      zone = null;\n    }\n\n    return new ICAL.VCardTime(o, zone, aIcalType);\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n\n(function() {\n  var DOW_MAP = {\n    SU: ICAL.Time.SUNDAY,\n    MO: ICAL.Time.MONDAY,\n    TU: ICAL.Time.TUESDAY,\n    WE: ICAL.Time.WEDNESDAY,\n    TH: ICAL.Time.THURSDAY,\n    FR: ICAL.Time.FRIDAY,\n    SA: ICAL.Time.SATURDAY\n  };\n\n  var REVERSE_DOW_MAP = {};\n  for (var key in DOW_MAP) {\n    /* istanbul ignore else */\n    if (DOW_MAP.hasOwnProperty(key)) {\n      REVERSE_DOW_MAP[DOW_MAP[key]] = key;\n    }\n  }\n\n  var COPY_PARTS = [\"BYSECOND\", \"BYMINUTE\", \"BYHOUR\", \"BYDAY\",\n                    \"BYMONTHDAY\", \"BYYEARDAY\", \"BYWEEKNO\",\n                    \"BYMONTH\", \"BYSETPOS\"];\n\n  /**\n   * @classdesc\n   * This class represents the \"recur\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @class\n   * @alias ICAL.Recur\n   * @param {Object} data                               An object with members of the recurrence\n   * @param {ICAL.Recur.frequencyValues=} data.freq     The frequency value\n   * @param {Number=} data.interval                     The INTERVAL value\n   * @param {ICAL.Time.weekDay=} data.wkst              The week start value\n   * @param {ICAL.Time=} data.until                     The end of the recurrence set\n   * @param {Number=} data.count                        The number of occurrences\n   * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part\n   * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part\n   * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part\n   * @param {Array.<String>=} data.byday                The BYDAY values\n   * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part\n   * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part\n   * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part\n   * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part\n   * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part\n   */\n  ICAL.Recur = function icalrecur(data) {\n    this.wrappedJSObject = this;\n    this.parts = {};\n\n    if (data && typeof(data) === 'object') {\n      this.fromData(data);\n    }\n  };\n\n  ICAL.Recur.prototype = {\n    /**\n     * An object holding the BY-parts of the recurrence rule\n     * @type {Object}\n     */\n    parts: null,\n\n    /**\n     * The interval value for the recurrence rule.\n     * @type {Number}\n     */\n    interval: 1,\n\n    /**\n     * The week start day\n     *\n     * @type {ICAL.Time.weekDay}\n     * @default ICAL.Time.MONDAY\n     */\n    wkst: ICAL.Time.MONDAY,\n\n    /**\n     * The end of the recurrence\n     * @type {?ICAL.Time}\n     */\n    until: null,\n\n    /**\n     * The maximum number of occurrences\n     * @type {?Number}\n     */\n    count: null,\n\n    /**\n     * The frequency value.\n     * @type {ICAL.Recur.frequencyValues}\n     */\n    freq: null,\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icalrecur\"\n     */\n    icalclass: \"icalrecur\",\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"recur\"\n     */\n    icaltype: \"recur\",\n\n    /**\n     * Create a new iterator for this recurrence rule. The passed start date\n     * must be the start date of the event, not the start of the range to\n     * search in.\n     *\n     * @example\n     * var recur = comp.getFirstPropertyValue('rrule');\n     * var dtstart = comp.getFirstPropertyValue('dtstart');\n     * var iter = recur.iterator(dtstart);\n     * for (var next = iter.next(); next; next = iter.next()) {\n     *   if (next.compare(rangeStart) < 0) {\n     *     continue;\n     *   }\n     *   console.log(next.toString());\n     * }\n     *\n     * @param {ICAL.Time} aStart        The item's start date\n     * @return {ICAL.RecurIterator}     The recurrence iterator\n     */\n    iterator: function(aStart) {\n      return new ICAL.RecurIterator({\n        rule: this,\n        dtstart: aStart\n      });\n    },\n\n    /**\n     * Returns a clone of the recurrence object.\n     *\n     * @return {ICAL.Recur}      The cloned object\n     */\n    clone: function clone() {\n      return new ICAL.Recur(this.toJSON());\n    },\n\n    /**\n     * Checks if the current rule is finite, i.e. has a count or until part.\n     *\n     * @return {Boolean}        True, if the rule is finite\n     */\n    isFinite: function isfinite() {\n      return !!(this.count || this.until);\n    },\n\n    /**\n     * Checks if the current rule has a count part, and not limited by an until\n     * part.\n     *\n     * @return {Boolean}        True, if the rule is by count\n     */\n    isByCount: function isbycount() {\n      return !!(this.count && !this.until);\n    },\n\n    /**\n     * Adds a component (part) to the recurrence rule. This is not a component\n     * in the sense of {@link ICAL.Component}, but a part of the recurrence\n     * rule, i.e. BYMONTH.\n     *\n     * @param {String} aType            The name of the component part\n     * @param {Array|String} aValue     The component value\n     */\n    addComponent: function addPart(aType, aValue) {\n      var ucname = aType.toUpperCase();\n      if (ucname in this.parts) {\n        this.parts[ucname].push(aValue);\n      } else {\n        this.parts[ucname] = [aValue];\n      }\n    },\n\n    /**\n     * Sets the component value for the given by-part.\n     *\n     * @param {String} aType        The component part name\n     * @param {Array} aValues       The component values\n     */\n    setComponent: function setComponent(aType, aValues) {\n      this.parts[aType.toUpperCase()] = aValues.slice();\n    },\n\n    /**\n     * Gets (a copy) of the requested component value.\n     *\n     * @param {String} aType        The component part name\n     * @return {Array}              The component part value\n     */\n    getComponent: function getComponent(aType) {\n      var ucname = aType.toUpperCase();\n      return (ucname in this.parts ? this.parts[ucname].slice() : []);\n    },\n\n    /**\n     * Retrieves the next occurrence after the given recurrence id. See the\n     * guide on {@tutorial terminology} for more details.\n     *\n     * NOTE: Currently, this method iterates all occurrences from the start\n     * date. It should not be called in a loop for performance reasons. If you\n     * would like to get more than one occurrence, you can iterate the\n     * occurrences manually, see the example on the\n     * {@link ICAL.Recur#iterator iterator} method.\n     *\n     * @param {ICAL.Time} aStartTime        The start of the event series\n     * @param {ICAL.Time} aRecurrenceId     The date of the last occurrence\n     * @return {ICAL.Time}                  The next occurrence after\n     */\n    getNextOccurrence: function getNextOccurrence(aStartTime, aRecurrenceId) {\n      var iter = this.iterator(aStartTime);\n      var next, cdt;\n\n      do {\n        next = iter.next();\n      } while (next && next.compare(aRecurrenceId) <= 0);\n\n      if (next && aRecurrenceId.zone) {\n        next.zone = aRecurrenceId.zone;\n      }\n\n      return next;\n    },\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} data                               An object with members of the recurrence\n     * @param {ICAL.Recur.frequencyValues=} data.freq     The frequency value\n     * @param {Number=} data.interval                     The INTERVAL value\n     * @param {ICAL.Time.weekDay=} data.wkst              The week start value\n     * @param {ICAL.Time=} data.until                     The end of the recurrence set\n     * @param {Number=} data.count                        The number of occurrences\n     * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part\n     * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part\n     * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part\n     * @param {Array.<String>=} data.byday                The BYDAY values\n     * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part\n     * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part\n     * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part\n     * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part\n     * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part\n     */\n    fromData: function(data) {\n      for (var key in data) {\n        var uckey = key.toUpperCase();\n\n        if (uckey in partDesign) {\n          if (Array.isArray(data[key])) {\n            this.parts[uckey] = data[key];\n          } else {\n            this.parts[uckey] = [data[key]];\n          }\n        } else {\n          this[key] = data[key];\n        }\n      }\n\n      if (this.interval && typeof this.interval != \"number\") {\n        optionDesign.INTERVAL(this.interval, this);\n      }\n\n      if (this.wkst && typeof this.wkst != \"number\") {\n        this.wkst = ICAL.Recur.icalDayToNumericDay(this.wkst);\n      }\n\n      if (this.until && !(this.until instanceof ICAL.Time)) {\n        this.until = ICAL.Time.fromString(this.until);\n      }\n    },\n\n    /**\n     * The jCal representation of this recurrence type.\n     * @return {Object}\n     */\n    toJSON: function() {\n      var res = Object.create(null);\n      res.freq = this.freq;\n\n      if (this.count) {\n        res.count = this.count;\n      }\n\n      if (this.interval > 1) {\n        res.interval = this.interval;\n      }\n\n      for (var k in this.parts) {\n        /* istanbul ignore if */\n        if (!this.parts.hasOwnProperty(k)) {\n          continue;\n        }\n        var kparts = this.parts[k];\n        if (Array.isArray(kparts) && kparts.length == 1) {\n          res[k.toLowerCase()] = kparts[0];\n        } else {\n          res[k.toLowerCase()] = ICAL.helpers.clone(this.parts[k]);\n        }\n      }\n\n      if (this.until) {\n        res.until = this.until.toString();\n      }\n      if ('wkst' in this && this.wkst !== ICAL.Time.DEFAULT_WEEK_START) {\n        res.wkst = ICAL.Recur.numericDayToIcalDay(this.wkst);\n      }\n      return res;\n    },\n\n    /**\n     * The string representation of this recurrence rule.\n     * @return {String}\n     */\n    toString: function icalrecur_toString() {\n      // TODO retain order\n      var str = \"FREQ=\" + this.freq;\n      if (this.count) {\n        str += \";COUNT=\" + this.count;\n      }\n      if (this.interval > 1) {\n        str += \";INTERVAL=\" + this.interval;\n      }\n      for (var k in this.parts) {\n        /* istanbul ignore else */\n        if (this.parts.hasOwnProperty(k)) {\n          str += \";\" + k + \"=\" + this.parts[k];\n        }\n      }\n      if (this.until) {\n        str += ';UNTIL=' + this.until.toICALString();\n      }\n      if ('wkst' in this && this.wkst !== ICAL.Time.DEFAULT_WEEK_START) {\n        str += ';WKST=' + ICAL.Recur.numericDayToIcalDay(this.wkst);\n      }\n      return str;\n    }\n  };\n\n  function parseNumericValue(type, min, max, value) {\n    var result = value;\n\n    if (value[0] === '+') {\n      result = value.substr(1);\n    }\n\n    result = ICAL.helpers.strictParseInt(result);\n\n    if (min !== undefined && value < min) {\n      throw new Error(\n        type + ': invalid value \"' + value + '\" must be > ' + min\n      );\n    }\n\n    if (max !== undefined && value > max) {\n      throw new Error(\n        type + ': invalid value \"' + value + '\" must be < ' + min\n      );\n    }\n\n    return result;\n  }\n\n  /**\n   * Convert an ical representation of a day (SU, MO, etc..)\n   * into a numeric value of that day.\n   *\n   * @param {String} string     The iCalendar day name\n   * @param {ICAL.Time.weekDay=} aWeekStart\n   *        The week start weekday, defaults to SUNDAY\n   * @return {Number}           Numeric value of given day\n   */\n  ICAL.Recur.icalDayToNumericDay = function toNumericDay(string, aWeekStart) {\n    //XXX: this is here so we can deal\n    //     with possibly invalid string values.\n    var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n    return ((DOW_MAP[string] - firstDow + 7) % 7) + 1;\n  };\n\n  /**\n   * Convert a numeric day value into its ical representation (SU, MO, etc..)\n   *\n   * @param {Number} num        Numeric value of given day\n   * @param {ICAL.Time.weekDay=} aWeekStart\n   *        The week start weekday, defaults to SUNDAY\n   * @return {String}           The ICAL day value, e.g SU,MO,...\n   */\n  ICAL.Recur.numericDayToIcalDay = function toIcalDay(num, aWeekStart) {\n    //XXX: this is here so we can deal with possibly invalid number values.\n    //     Also, this allows consistent mapping between day numbers and day\n    //     names for external users.\n    var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n    var dow = (num + firstDow - ICAL.Time.SUNDAY);\n    if (dow > 7) {\n      dow -= 7;\n    }\n    return REVERSE_DOW_MAP[dow];\n  };\n\n  var VALID_DAY_NAMES = /^(SU|MO|TU|WE|TH|FR|SA)$/;\n  var VALID_BYDAY_PART = /^([+-])?(5[0-3]|[1-4][0-9]|[1-9])?(SU|MO|TU|WE|TH|FR|SA)$/;\n\n  /**\n   * Possible frequency values for the FREQ part\n   * (YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY, SECONDLY)\n   *\n   * @typedef {String} frequencyValues\n   * @memberof ICAL.Recur\n   */\n\n  var ALLOWED_FREQ = ['SECONDLY', 'MINUTELY', 'HOURLY',\n                      'DAILY', 'WEEKLY', 'MONTHLY', 'YEARLY'];\n\n  var optionDesign = {\n    FREQ: function(value, dict, fmtIcal) {\n      // yes this is actually equal or faster then regex.\n      // upside here is we can enumerate the valid values.\n      if (ALLOWED_FREQ.indexOf(value) !== -1) {\n        dict.freq = value;\n      } else {\n        throw new Error(\n          'invalid frequency \"' + value + '\" expected: \"' +\n          ALLOWED_FREQ.join(', ') + '\"'\n        );\n      }\n    },\n\n    COUNT: function(value, dict, fmtIcal) {\n      dict.count = ICAL.helpers.strictParseInt(value);\n    },\n\n    INTERVAL: function(value, dict, fmtIcal) {\n      dict.interval = ICAL.helpers.strictParseInt(value);\n      if (dict.interval < 1) {\n        // 0 or negative values are not allowed, some engines seem to generate\n        // it though. Assume 1 instead.\n        dict.interval = 1;\n      }\n    },\n\n    UNTIL: function(value, dict, fmtIcal) {\n      if (value.length > 10) {\n        dict.until = ICAL.design.icalendar.value['date-time'].fromICAL(value);\n      } else {\n        dict.until = ICAL.design.icalendar.value.date.fromICAL(value);\n      }\n      if (!fmtIcal) {\n        dict.until = ICAL.Time.fromString(dict.until);\n      }\n    },\n\n    WKST: function(value, dict, fmtIcal) {\n      if (VALID_DAY_NAMES.test(value)) {\n        dict.wkst = ICAL.Recur.icalDayToNumericDay(value);\n      } else {\n        throw new Error('invalid WKST value \"' + value + '\"');\n      }\n    }\n  };\n\n  var partDesign = {\n    BYSECOND: parseNumericValue.bind(this, 'BYSECOND', 0, 60),\n    BYMINUTE: parseNumericValue.bind(this, 'BYMINUTE', 0, 59),\n    BYHOUR: parseNumericValue.bind(this, 'BYHOUR', 0, 23),\n    BYDAY: function(value) {\n      if (VALID_BYDAY_PART.test(value)) {\n        return value;\n      } else {\n        throw new Error('invalid BYDAY value \"' + value + '\"');\n      }\n    },\n    BYMONTHDAY: parseNumericValue.bind(this, 'BYMONTHDAY', -31, 31),\n    BYYEARDAY: parseNumericValue.bind(this, 'BYYEARDAY', -366, 366),\n    BYWEEKNO: parseNumericValue.bind(this, 'BYWEEKNO', -53, 53),\n    BYMONTH: parseNumericValue.bind(this, 'BYMONTH', 1, 12),\n    BYSETPOS: parseNumericValue.bind(this, 'BYSETPOS', -366, 366)\n  };\n\n\n  /**\n   * Creates a new {@link ICAL.Recur} instance from the passed string.\n   *\n   * @param {String} string         The string to parse\n   * @return {ICAL.Recur}           The created recurrence instance\n   */\n  ICAL.Recur.fromString = function(string) {\n    var data = ICAL.Recur._stringToData(string, false);\n    return new ICAL.Recur(data);\n  };\n\n  /**\n   * Creates a new {@link ICAL.Recur} instance using members from the passed\n   * data object.\n   *\n   * @param {Object} aData                              An object with members of the recurrence\n   * @param {ICAL.Recur.frequencyValues=} aData.freq    The frequency value\n   * @param {Number=} aData.interval                    The INTERVAL value\n   * @param {ICAL.Time.weekDay=} aData.wkst             The week start value\n   * @param {ICAL.Time=} aData.until                    The end of the recurrence set\n   * @param {Number=} aData.count                       The number of occurrences\n   * @param {Array.<Number>=} aData.bysecond            The seconds for the BYSECOND part\n   * @param {Array.<Number>=} aData.byminute            The minutes for the BYMINUTE part\n   * @param {Array.<Number>=} aData.byhour              The hours for the BYHOUR part\n   * @param {Array.<String>=} aData.byday               The BYDAY values\n   * @param {Array.<Number>=} aData.bymonthday          The days for the BYMONTHDAY part\n   * @param {Array.<Number>=} aData.byyearday           The days for the BYYEARDAY part\n   * @param {Array.<Number>=} aData.byweekno            The weeks for the BYWEEKNO part\n   * @param {Array.<Number>=} aData.bymonth             The month for the BYMONTH part\n   * @param {Array.<Number>=} aData.bysetpos            The positionals for the BYSETPOS part\n   */\n  ICAL.Recur.fromData = function(aData) {\n    return new ICAL.Recur(aData);\n  };\n\n  /**\n   * Converts a recurrence string to a data object, suitable for the fromData\n   * method.\n   *\n   * @param {String} string     The string to parse\n   * @param {Boolean} fmtIcal   If true, the string is considered to be an\n   *                              iCalendar string\n   * @return {ICAL.Recur}       The recurrence instance\n   */\n  ICAL.Recur._stringToData = function(string, fmtIcal) {\n    var dict = Object.create(null);\n\n    // split is slower in FF but fast enough.\n    // v8 however this is faster then manual split?\n    var values = string.split(';');\n    var len = values.length;\n\n    for (var i = 0; i < len; i++) {\n      var parts = values[i].split('=');\n      var ucname = parts[0].toUpperCase();\n      var lcname = parts[0].toLowerCase();\n      var name = (fmtIcal ? lcname : ucname);\n      var value = parts[1];\n\n      if (ucname in partDesign) {\n        var partArr = value.split(',');\n        var partArrIdx = 0;\n        var partArrLen = partArr.length;\n\n        for (; partArrIdx < partArrLen; partArrIdx++) {\n          partArr[partArrIdx] = partDesign[ucname](partArr[partArrIdx]);\n        }\n        dict[name] = (partArr.length == 1 ? partArr[0] : partArr);\n      } else if (ucname in optionDesign) {\n        optionDesign[ucname](value, dict, fmtIcal);\n      } else {\n        // Don't swallow unknown values. Just set them as they are.\n        dict[lcname] = value;\n      }\n    }\n\n    return dict;\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.RecurIterator = (function() {\n\n  /**\n   * @classdesc\n   * An iterator for a single recurrence rule. This class usually doesn't have\n   * to be instanciated directly, the convenience method\n   * {@link ICAL.Recur#iterator} can be used.\n   *\n   * @description\n   * The options object may contain additional members when resuming iteration from a previous run\n   *\n   * @description\n   * The options object may contain additional members when resuming iteration\n   * from a previous run.\n   *\n   * @class\n   * @alias ICAL.RecurIterator\n   * @param {Object} options                The iterator options\n   * @param {ICAL.Recur} options.rule       The rule to iterate.\n   * @param {ICAL.Time} options.dtstart     The start date of the event.\n   * @param {Boolean=} options.initialized  When true, assume that options are\n   *        from a previously constructed iterator. Initialization will not be\n   *        repeated.\n   */\n  function icalrecur_iterator(options) {\n    this.fromData(options);\n  }\n\n  icalrecur_iterator.prototype = {\n\n    /**\n     * True when iteration is finished.\n     * @type {Boolean}\n     */\n    completed: false,\n\n    /**\n     * The rule that is being iterated\n     * @type {ICAL.Recur}\n     */\n    rule: null,\n\n    /**\n     * The start date of the event being iterated.\n     * @type {ICAL.Time}\n     */\n    dtstart: null,\n\n    /**\n     * The last occurrence that was returned from the\n     * {@link ICAL.RecurIterator#next} method.\n     * @type {ICAL.Time}\n     */\n    last: null,\n\n    /**\n     * The sequence number from the occurrence\n     * @type {Number}\n     */\n    occurrence_number: 0,\n\n    /**\n     * The indices used for the {@link ICAL.RecurIterator#by_data} object.\n     * @type {Object}\n     * @private\n     */\n    by_indices: null,\n\n    /**\n     * If true, the iterator has already been initialized\n     * @type {Boolean}\n     * @private\n     */\n    initialized: false,\n\n    /**\n     * The initializd by-data.\n     * @type {Object}\n     * @private\n     */\n    by_data: null,\n\n    /**\n     * The expanded yeardays\n     * @type {Array}\n     * @private\n     */\n    days: null,\n\n    /**\n     * The index in the {@link ICAL.RecurIterator#days} array.\n     * @type {Number}\n     * @private\n     */\n    days_index: 0,\n\n    /**\n     * Initialize the recurrence iterator from the passed data object. This\n     * method is usually not called directly, you can initialize the iterator\n     * through the constructor.\n     *\n     * @param {Object} options                The iterator options\n     * @param {ICAL.Recur} options.rule       The rule to iterate.\n     * @param {ICAL.Time} options.dtstart     The start date of the event.\n     * @param {Boolean=} options.initialized  When true, assume that options are\n     *        from a previously constructed iterator. Initialization will not be\n     *        repeated.\n     */\n    fromData: function(options) {\n      this.rule = ICAL.helpers.formatClassType(options.rule, ICAL.Recur);\n\n      if (!this.rule) {\n        throw new Error('iterator requires a (ICAL.Recur) rule');\n      }\n\n      this.dtstart = ICAL.helpers.formatClassType(options.dtstart, ICAL.Time);\n\n      if (!this.dtstart) {\n        throw new Error('iterator requires a (ICAL.Time) dtstart');\n      }\n\n      if (options.by_data) {\n        this.by_data = options.by_data;\n      } else {\n        this.by_data = ICAL.helpers.clone(this.rule.parts, true);\n      }\n\n      if (options.occurrence_number)\n        this.occurrence_number = options.occurrence_number;\n\n      this.days = options.days || [];\n      if (options.last) {\n        this.last = ICAL.helpers.formatClassType(options.last, ICAL.Time);\n      }\n\n      this.by_indices = options.by_indices;\n\n      if (!this.by_indices) {\n        this.by_indices = {\n          \"BYSECOND\": 0,\n          \"BYMINUTE\": 0,\n          \"BYHOUR\": 0,\n          \"BYDAY\": 0,\n          \"BYMONTH\": 0,\n          \"BYWEEKNO\": 0,\n          \"BYMONTHDAY\": 0\n        };\n      }\n\n      this.initialized = options.initialized || false;\n\n      if (!this.initialized) {\n        this.init();\n      }\n    },\n\n    /**\n     * Intialize the iterator\n     * @private\n     */\n    init: function icalrecur_iterator_init() {\n      this.initialized = true;\n      this.last = this.dtstart.clone();\n      var parts = this.by_data;\n\n      if (\"BYDAY\" in parts) {\n        // libical does this earlier when the rule is loaded, but we postpone to\n        // now so we can preserve the original order.\n        this.sort_byday_rules(parts.BYDAY);\n      }\n\n      // If the BYYEARDAY appares, no other date rule part may appear\n      if (\"BYYEARDAY\" in parts) {\n        if (\"BYMONTH\" in parts || \"BYWEEKNO\" in parts ||\n            \"BYMONTHDAY\" in parts || \"BYDAY\" in parts) {\n          throw new Error(\"Invalid BYYEARDAY rule\");\n        }\n      }\n\n      // BYWEEKNO and BYMONTHDAY rule parts may not both appear\n      if (\"BYWEEKNO\" in parts && \"BYMONTHDAY\" in parts) {\n        throw new Error(\"BYWEEKNO does not fit to BYMONTHDAY\");\n      }\n\n      // For MONTHLY recurrences (FREQ=MONTHLY) neither BYYEARDAY nor\n      // BYWEEKNO may appear.\n      if (this.rule.freq == \"MONTHLY\" &&\n          (\"BYYEARDAY\" in parts || \"BYWEEKNO\" in parts)) {\n        throw new Error(\"For MONTHLY recurrences neither BYYEARDAY nor BYWEEKNO may appear\");\n      }\n\n      // For WEEKLY recurrences (FREQ=WEEKLY) neither BYMONTHDAY nor\n      // BYYEARDAY may appear.\n      if (this.rule.freq == \"WEEKLY\" &&\n          (\"BYYEARDAY\" in parts || \"BYMONTHDAY\" in parts)) {\n        throw new Error(\"For WEEKLY recurrences neither BYMONTHDAY nor BYYEARDAY may appear\");\n      }\n\n      // BYYEARDAY may only appear in YEARLY rules\n      if (this.rule.freq != \"YEARLY\" && \"BYYEARDAY\" in parts) {\n        throw new Error(\"BYYEARDAY may only appear in YEARLY rules\");\n      }\n\n      this.last.second = this.setup_defaults(\"BYSECOND\", \"SECONDLY\", this.dtstart.second);\n      this.last.minute = this.setup_defaults(\"BYMINUTE\", \"MINUTELY\", this.dtstart.minute);\n      this.last.hour = this.setup_defaults(\"BYHOUR\", \"HOURLY\", this.dtstart.hour);\n      this.last.day = this.setup_defaults(\"BYMONTHDAY\", \"DAILY\", this.dtstart.day);\n      this.last.month = this.setup_defaults(\"BYMONTH\", \"MONTHLY\", this.dtstart.month);\n\n      if (this.rule.freq == \"WEEKLY\") {\n        if (\"BYDAY\" in parts) {\n          var bydayParts = this.ruleDayOfWeek(parts.BYDAY[0], this.rule.wkst);\n          var pos = bydayParts[0];\n          var dow = bydayParts[1];\n          var wkdy = dow - this.last.dayOfWeek(this.rule.wkst);\n          if ((this.last.dayOfWeek(this.rule.wkst) < dow && wkdy >= 0) || wkdy < 0) {\n            // Initial time is after first day of BYDAY data\n            this.last.day += wkdy;\n          }\n        } else {\n          var dayName = ICAL.Recur.numericDayToIcalDay(this.dtstart.dayOfWeek());\n          parts.BYDAY = [dayName];\n        }\n      }\n\n      if (this.rule.freq == \"YEARLY\") {\n        for (;;) {\n          this.expand_year_days(this.last.year);\n          if (this.days.length > 0) {\n            break;\n          }\n          this.increment_year(this.rule.interval);\n        }\n\n        this._nextByYearDay();\n      }\n\n      if (this.rule.freq == \"MONTHLY\" && this.has_by_data(\"BYDAY\")) {\n        var tempLast = null;\n        var initLast = this.last.clone();\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n\n        // Check every weekday in BYDAY with relative dow and pos.\n        for (var i in this.by_data.BYDAY) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYDAY.hasOwnProperty(i)) {\n            continue;\n          }\n          this.last = initLast.clone();\n          var bydayParts = this.ruleDayOfWeek(this.by_data.BYDAY[i]);\n          var pos = bydayParts[0];\n          var dow = bydayParts[1];\n          var dayOfMonth = this.last.nthWeekDay(dow, pos);\n\n          // If |pos| >= 6, the byday is invalid for a monthly rule.\n          if (pos >= 6 || pos <= -6) {\n            throw new Error(\"Malformed values in BYDAY part\");\n          }\n\n          // If a Byday with pos=+/-5 is not in the current month it\n          // must be searched in the next months.\n          if (dayOfMonth > daysInMonth || dayOfMonth <= 0) {\n            // Skip if we have already found a \"last\" in this month.\n            if (tempLast && tempLast.month == initLast.month) {\n              continue;\n            }\n            while (dayOfMonth > daysInMonth || dayOfMonth <= 0) {\n              this.increment_month();\n              daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n              dayOfMonth = this.last.nthWeekDay(dow, pos);\n            }\n          }\n\n          this.last.day = dayOfMonth;\n          if (!tempLast || this.last.compare(tempLast) < 0) {\n            tempLast = this.last.clone();\n          }\n        }\n        this.last = tempLast.clone();\n\n        //XXX: This feels like a hack, but we need to initialize\n        //     the BYMONTHDAY case correctly and byDayAndMonthDay handles\n        //     this case. It accepts a special flag which will avoid incrementing\n        //     the initial value without the flag days that match the start time\n        //     would be missed.\n        if (this.has_by_data('BYMONTHDAY')) {\n          this._byDayAndMonthDay(true);\n        }\n\n        if (this.last.day > daysInMonth || this.last.day == 0) {\n          throw new Error(\"Malformed values in BYDAY part\");\n        }\n\n      } else if (this.has_by_data(\"BYMONTHDAY\")) {\n        if (this.last.day < 0) {\n          var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n          this.last.day = daysInMonth + this.last.day + 1;\n        }\n      }\n\n    },\n\n    /**\n     * Retrieve the next occurrence from the iterator.\n     * @return {ICAL.Time}\n     */\n    next: function icalrecur_iterator_next() {\n      var before = (this.last ? this.last.clone() : null);\n\n      if ((this.rule.count && this.occurrence_number >= this.rule.count) ||\n          (this.rule.until && this.last.compare(this.rule.until) > 0)) {\n\n        //XXX: right now this is just a flag and has no impact\n        //     we can simplify the above case to check for completed later.\n        this.completed = true;\n\n        return null;\n      }\n\n      if (this.occurrence_number == 0 && this.last.compare(this.dtstart) >= 0) {\n        // First of all, give the instance that was initialized\n        this.occurrence_number++;\n        return this.last;\n      }\n\n\n      var valid;\n      do {\n        valid = 1;\n\n        switch (this.rule.freq) {\n        case \"SECONDLY\":\n          this.next_second();\n          break;\n        case \"MINUTELY\":\n          this.next_minute();\n          break;\n        case \"HOURLY\":\n          this.next_hour();\n          break;\n        case \"DAILY\":\n          this.next_day();\n          break;\n        case \"WEEKLY\":\n          this.next_week();\n          break;\n        case \"MONTHLY\":\n          valid = this.next_month();\n          break;\n        case \"YEARLY\":\n          this.next_year();\n          break;\n\n        default:\n          return null;\n        }\n      } while (!this.check_contracting_rules() ||\n               this.last.compare(this.dtstart) < 0 ||\n               !valid);\n\n      // TODO is this valid?\n      if (this.last.compare(before) == 0) {\n        throw new Error(\"Same occurrence found twice, protecting \" +\n                        \"you from death by recursion\");\n      }\n\n      if (this.rule.until && this.last.compare(this.rule.until) > 0) {\n        this.completed = true;\n        return null;\n      } else {\n        this.occurrence_number++;\n        return this.last;\n      }\n    },\n\n    next_second: function next_second() {\n      return this.next_generic(\"BYSECOND\", \"SECONDLY\", \"second\", \"minute\");\n    },\n\n    increment_second: function increment_second(inc) {\n      return this.increment_generic(inc, \"second\", 60, \"minute\");\n    },\n\n    next_minute: function next_minute() {\n      return this.next_generic(\"BYMINUTE\", \"MINUTELY\",\n                               \"minute\", \"hour\", \"next_second\");\n    },\n\n    increment_minute: function increment_minute(inc) {\n      return this.increment_generic(inc, \"minute\", 60, \"hour\");\n    },\n\n    next_hour: function next_hour() {\n      return this.next_generic(\"BYHOUR\", \"HOURLY\", \"hour\",\n                               \"monthday\", \"next_minute\");\n    },\n\n    increment_hour: function increment_hour(inc) {\n      this.increment_generic(inc, \"hour\", 24, \"monthday\");\n    },\n\n    next_day: function next_day() {\n      var has_by_day = (\"BYDAY\" in this.by_data);\n      var this_freq = (this.rule.freq == \"DAILY\");\n\n      if (this.next_hour() == 0) {\n        return 0;\n      }\n\n      if (this_freq) {\n        this.increment_monthday(this.rule.interval);\n      } else {\n        this.increment_monthday(1);\n      }\n\n      return 0;\n    },\n\n    next_week: function next_week() {\n      var end_of_data = 0;\n\n      if (this.next_weekday_by_week() == 0) {\n        return end_of_data;\n      }\n\n      if (this.has_by_data(\"BYWEEKNO\")) {\n        var idx = ++this.by_indices.BYWEEKNO;\n\n        if (this.by_indices.BYWEEKNO == this.by_data.BYWEEKNO.length) {\n          this.by_indices.BYWEEKNO = 0;\n          end_of_data = 1;\n        }\n\n        // HACK should be first month of the year\n        this.last.month = 1;\n        this.last.day = 1;\n\n        var week_no = this.by_data.BYWEEKNO[this.by_indices.BYWEEKNO];\n\n        this.last.day += 7 * week_no;\n\n        if (end_of_data) {\n          this.increment_year(1);\n        }\n      } else {\n        // Jump to the next week\n        this.increment_monthday(7 * this.rule.interval);\n      }\n\n      return end_of_data;\n    },\n\n    /**\n     * Normalize each by day rule for a given year/month.\n     * Takes into account ordering and negative rules\n     *\n     * @private\n     * @param {Number} year         Current year.\n     * @param {Number} month        Current month.\n     * @param {Array}  rules        Array of rules.\n     *\n     * @return {Array} sorted and normalized rules.\n     *                 Negative rules will be expanded to their\n     *                 correct positive values for easier processing.\n     */\n    normalizeByMonthDayRules: function(year, month, rules) {\n      var daysInMonth = ICAL.Time.daysInMonth(month, year);\n\n      // XXX: This is probably bad for performance to allocate\n      //      a new array for each month we scan, if possible\n      //      we should try to optimize this...\n      var newRules = [];\n\n      var ruleIdx = 0;\n      var len = rules.length;\n      var rule;\n\n      for (; ruleIdx < len; ruleIdx++) {\n        rule = rules[ruleIdx];\n\n        // if this rule falls outside of given\n        // month discard it.\n        if (Math.abs(rule) > daysInMonth) {\n          continue;\n        }\n\n        // negative case\n        if (rule < 0) {\n          // we add (not subtract it is a negative number)\n          // one from the rule because 1 === last day of month\n          rule = daysInMonth + (rule + 1);\n        } else if (rule === 0) {\n          // skip zero: it is invalid.\n          continue;\n        }\n\n        // only add unique items...\n        if (newRules.indexOf(rule) === -1) {\n          newRules.push(rule);\n        }\n\n      }\n\n      // unique and sort\n      return newRules.sort(function(a, b) { return a - b; });\n    },\n\n    /**\n     * NOTES:\n     * We are given a list of dates in the month (BYMONTHDAY) (23, etc..)\n     * Also we are given a list of days (BYDAY) (MO, 2SU, etc..) when\n     * both conditions match a given date (this.last.day) iteration stops.\n     *\n     * @private\n     * @param {Boolean=} isInit     When given true will not increment the\n     *                                current day (this.last).\n     */\n    _byDayAndMonthDay: function(isInit) {\n      var byMonthDay; // setup in initMonth\n      var byDay = this.by_data.BYDAY;\n\n      var date;\n      var dateIdx = 0;\n      var dateLen; // setup in initMonth\n      var dayLen = byDay.length;\n\n      // we are not valid by default\n      var dataIsValid = 0;\n\n      var daysInMonth;\n      var self = this;\n      // we need a copy of this, because a DateTime gets normalized\n      // automatically if the day is out of range. At some points we\n      // set the last day to 0 to start counting.\n      var lastDay = this.last.day;\n\n      function initMonth() {\n        daysInMonth = ICAL.Time.daysInMonth(\n          self.last.month, self.last.year\n        );\n\n        byMonthDay = self.normalizeByMonthDayRules(\n          self.last.year,\n          self.last.month,\n          self.by_data.BYMONTHDAY\n        );\n\n        dateLen = byMonthDay.length;\n\n        // For the case of more than one occurrence in one month\n        // we have to be sure to start searching after the last\n        // found date or at the last BYMONTHDAY, unless we are\n        // initializing the iterator because in this case we have\n        // to consider the last found date too.\n        while (byMonthDay[dateIdx] <= lastDay &&\n               !(isInit && byMonthDay[dateIdx] == lastDay) &&\n               dateIdx < dateLen - 1) {\n          dateIdx++;\n        }\n      }\n\n      function nextMonth() {\n        // since the day is incremented at the start\n        // of the loop below, we need to start at 0\n        lastDay = 0;\n        self.increment_month();\n        dateIdx = 0;\n        initMonth();\n      }\n\n      initMonth();\n\n      // should come after initMonth\n      if (isInit) {\n        lastDay -= 1;\n      }\n\n      // Use a counter to avoid an infinite loop with malformed rules.\n      // Stop checking after 4 years so we consider also a leap year.\n      var monthsCounter = 48;\n\n      while (!dataIsValid && monthsCounter) {\n        monthsCounter--;\n        // increment the current date. This is really\n        // important otherwise we may fall into the infinite\n        // loop trap. The initial date takes care of the case\n        // where the current date is the date we are looking\n        // for.\n        date = lastDay + 1;\n\n        if (date > daysInMonth) {\n          nextMonth();\n          continue;\n        }\n\n        // find next date\n        var next = byMonthDay[dateIdx++];\n\n        // this logic is dependant on the BYMONTHDAYS\n        // being in order (which is done by #normalizeByMonthDayRules)\n        if (next >= date) {\n          // if the next month day is in the future jump to it.\n          lastDay = next;\n        } else {\n          // in this case the 'next' monthday has past\n          // we must move to the month.\n          nextMonth();\n          continue;\n        }\n\n        // Now we can loop through the day rules to see\n        // if one matches the current month date.\n        for (var dayIdx = 0; dayIdx < dayLen; dayIdx++) {\n          var parts = this.ruleDayOfWeek(byDay[dayIdx]);\n          var pos = parts[0];\n          var dow = parts[1];\n\n          this.last.day = lastDay;\n          if (this.last.isNthWeekDay(dow, pos)) {\n            // when we find the valid one we can mark\n            // the conditions as met and break the loop.\n            // (Because we have this condition above\n            //  it will also break the parent loop).\n            dataIsValid = 1;\n            break;\n          }\n        }\n\n        // It is completely possible that the combination\n        // cannot be matched in the current month.\n        // When we reach the end of possible combinations\n        // in the current month we iterate to the next one.\n        // since dateIdx is incremented right after getting\n        // \"next\", we don't need dateLen -1 here.\n        if (!dataIsValid && dateIdx === dateLen) {\n          nextMonth();\n          continue;\n        }\n      }\n\n      if (monthsCounter <= 0) {\n        // Checked 4 years without finding a Byday that matches\n        // a Bymonthday. Maybe the rule is not correct.\n        throw new Error(\"Malformed values in BYDAY combined with BYMONTHDAY parts\");\n      }\n\n\n      return dataIsValid;\n    },\n\n    next_month: function next_month() {\n      var this_freq = (this.rule.freq == \"MONTHLY\");\n      var data_valid = 1;\n\n      if (this.next_hour() == 0) {\n        return data_valid;\n      }\n\n      if (this.has_by_data(\"BYDAY\") && this.has_by_data(\"BYMONTHDAY\")) {\n        data_valid = this._byDayAndMonthDay();\n      } else if (this.has_by_data(\"BYDAY\")) {\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n        var setpos = 0;\n        var setpos_total = 0;\n\n        if (this.has_by_data(\"BYSETPOS\")) {\n          var last_day = this.last.day;\n          for (var day = 1; day <= daysInMonth; day++) {\n            this.last.day = day;\n            if (this.is_day_in_byday(this.last)) {\n              setpos_total++;\n              if (day <= last_day) {\n                setpos++;\n              }\n            }\n          }\n          this.last.day = last_day;\n        }\n\n        data_valid = 0;\n        for (var day = this.last.day + 1; day <= daysInMonth; day++) {\n          this.last.day = day;\n\n          if (this.is_day_in_byday(this.last)) {\n            if (!this.has_by_data(\"BYSETPOS\") ||\n                this.check_set_position(++setpos) ||\n                this.check_set_position(setpos - setpos_total - 1)) {\n\n              data_valid = 1;\n              break;\n            }\n          }\n        }\n\n        if (day > daysInMonth) {\n          this.last.day = 1;\n          this.increment_month();\n\n          if (this.is_day_in_byday(this.last)) {\n            if (!this.has_by_data(\"BYSETPOS\") || this.check_set_position(1)) {\n              data_valid = 1;\n            }\n          } else {\n            data_valid = 0;\n          }\n        }\n      } else if (this.has_by_data(\"BYMONTHDAY\")) {\n        this.by_indices.BYMONTHDAY++;\n\n        if (this.by_indices.BYMONTHDAY >= this.by_data.BYMONTHDAY.length) {\n          this.by_indices.BYMONTHDAY = 0;\n          this.increment_month();\n        }\n\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n        var day = this.by_data.BYMONTHDAY[this.by_indices.BYMONTHDAY];\n\n        if (day < 0) {\n          day = daysInMonth + day + 1;\n        }\n\n        if (day > daysInMonth) {\n          this.last.day = 1;\n          data_valid = this.is_day_in_byday(this.last);\n        } else {\n          this.last.day = day;\n        }\n\n      } else {\n        this.increment_month();\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n        if (this.by_data.BYMONTHDAY[0] > daysInMonth) {\n          data_valid = 0;\n        } else {\n          this.last.day = this.by_data.BYMONTHDAY[0];\n        }\n      }\n\n      return data_valid;\n    },\n\n    next_weekday_by_week: function next_weekday_by_week() {\n      var end_of_data = 0;\n\n      if (this.next_hour() == 0) {\n        return end_of_data;\n      }\n\n      if (!this.has_by_data(\"BYDAY\")) {\n        return 1;\n      }\n\n      for (;;) {\n        var tt = new ICAL.Time();\n        this.by_indices.BYDAY++;\n\n        if (this.by_indices.BYDAY == Object.keys(this.by_data.BYDAY).length) {\n          this.by_indices.BYDAY = 0;\n          end_of_data = 1;\n        }\n\n        var coded_day = this.by_data.BYDAY[this.by_indices.BYDAY];\n        var parts = this.ruleDayOfWeek(coded_day);\n        var dow = parts[1];\n\n        dow -= this.rule.wkst;\n\n        if (dow < 0) {\n          dow += 7;\n        }\n\n        tt.year = this.last.year;\n        tt.month = this.last.month;\n        tt.day = this.last.day;\n\n        var startOfWeek = tt.startDoyWeek(this.rule.wkst);\n\n        if (dow + startOfWeek < 1) {\n          // The selected date is in the previous year\n          if (!end_of_data) {\n            continue;\n          }\n        }\n\n        var next = ICAL.Time.fromDayOfYear(startOfWeek + dow,\n                                                  this.last.year);\n\n        /**\n         * The normalization horrors below are due to\n         * the fact that when the year/month/day changes\n         * it can effect the other operations that come after.\n         */\n        this.last.year = next.year;\n        this.last.month = next.month;\n        this.last.day = next.day;\n\n        return end_of_data;\n      }\n    },\n\n    next_year: function next_year() {\n\n      if (this.next_hour() == 0) {\n        return 0;\n      }\n\n      if (++this.days_index == this.days.length) {\n        this.days_index = 0;\n        do {\n          this.increment_year(this.rule.interval);\n          this.expand_year_days(this.last.year);\n        } while (this.days.length == 0);\n      }\n\n      this._nextByYearDay();\n\n      return 1;\n    },\n\n    _nextByYearDay: function _nextByYearDay() {\n        var doy = this.days[this.days_index];\n        var year = this.last.year;\n        if (doy < 1) {\n            // Time.fromDayOfYear(doy, year) indexes relative to the\n            // start of the given year. That is different from the\n            // semantics of BYYEARDAY where negative indexes are an\n            // offset from the end of the given year.\n            doy += 1;\n            year += 1;\n        }\n        var next = ICAL.Time.fromDayOfYear(doy, year);\n        this.last.day = next.day;\n        this.last.month = next.month;\n    },\n\n    /**\n     * @param dow (eg: '1TU', '-1MO')\n     * @param {ICAL.Time.weekDay=} aWeekStart The week start weekday\n     * @return [pos, numericDow] (eg: [1, 3]) numericDow is relative to aWeekStart\n     */\n    ruleDayOfWeek: function ruleDayOfWeek(dow, aWeekStart) {\n      var matches = dow.match(/([+-]?[0-9])?(MO|TU|WE|TH|FR|SA|SU)/);\n      if (matches) {\n        var pos = parseInt(matches[1] || 0, 10);\n        dow = ICAL.Recur.icalDayToNumericDay(matches[2], aWeekStart);\n        return [pos, dow];\n      } else {\n        return [0, 0];\n      }\n    },\n\n    next_generic: function next_generic(aRuleType, aInterval, aDateAttr,\n                                        aFollowingAttr, aPreviousIncr) {\n      var has_by_rule = (aRuleType in this.by_data);\n      var this_freq = (this.rule.freq == aInterval);\n      var end_of_data = 0;\n\n      if (aPreviousIncr && this[aPreviousIncr]() == 0) {\n        return end_of_data;\n      }\n\n      if (has_by_rule) {\n        this.by_indices[aRuleType]++;\n        var idx = this.by_indices[aRuleType];\n        var dta = this.by_data[aRuleType];\n\n        if (this.by_indices[aRuleType] == dta.length) {\n          this.by_indices[aRuleType] = 0;\n          end_of_data = 1;\n        }\n        this.last[aDateAttr] = dta[this.by_indices[aRuleType]];\n      } else if (this_freq) {\n        this[\"increment_\" + aDateAttr](this.rule.interval);\n      }\n\n      if (has_by_rule && end_of_data && this_freq) {\n        this[\"increment_\" + aFollowingAttr](1);\n      }\n\n      return end_of_data;\n    },\n\n    increment_monthday: function increment_monthday(inc) {\n      for (var i = 0; i < inc; i++) {\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n        this.last.day++;\n\n        if (this.last.day > daysInMonth) {\n          this.last.day -= daysInMonth;\n          this.increment_month();\n        }\n      }\n    },\n\n    increment_month: function increment_month() {\n      this.last.day = 1;\n      if (this.has_by_data(\"BYMONTH\")) {\n        this.by_indices.BYMONTH++;\n\n        if (this.by_indices.BYMONTH == this.by_data.BYMONTH.length) {\n          this.by_indices.BYMONTH = 0;\n          this.increment_year(1);\n        }\n\n        this.last.month = this.by_data.BYMONTH[this.by_indices.BYMONTH];\n      } else {\n        if (this.rule.freq == \"MONTHLY\") {\n          this.last.month += this.rule.interval;\n        } else {\n          this.last.month++;\n        }\n\n        this.last.month--;\n        var years = ICAL.helpers.trunc(this.last.month / 12);\n        this.last.month %= 12;\n        this.last.month++;\n\n        if (years != 0) {\n          this.increment_year(years);\n        }\n      }\n    },\n\n    increment_year: function increment_year(inc) {\n      this.last.year += inc;\n    },\n\n    increment_generic: function increment_generic(inc, aDateAttr,\n                                                  aFactor, aNextIncrement) {\n      this.last[aDateAttr] += inc;\n      var nextunit = ICAL.helpers.trunc(this.last[aDateAttr] / aFactor);\n      this.last[aDateAttr] %= aFactor;\n      if (nextunit != 0) {\n        this[\"increment_\" + aNextIncrement](nextunit);\n      }\n    },\n\n    has_by_data: function has_by_data(aRuleType) {\n      return (aRuleType in this.rule.parts);\n    },\n\n    expand_year_days: function expand_year_days(aYear) {\n      var t = new ICAL.Time();\n      this.days = [];\n\n      // We need our own copy with a few keys set\n      var parts = {};\n      var rules = [\"BYDAY\", \"BYWEEKNO\", \"BYMONTHDAY\", \"BYMONTH\", \"BYYEARDAY\"];\n      for (var p in rules) {\n        /* istanbul ignore else */\n        if (rules.hasOwnProperty(p)) {\n          var part = rules[p];\n          if (part in this.rule.parts) {\n            parts[part] = this.rule.parts[part];\n          }\n        }\n      }\n\n      if (\"BYMONTH\" in parts && \"BYWEEKNO\" in parts) {\n        var valid = 1;\n        var validWeeks = {};\n        t.year = aYear;\n        t.isDate = true;\n\n        for (var monthIdx = 0; monthIdx < this.by_data.BYMONTH.length; monthIdx++) {\n          var month = this.by_data.BYMONTH[monthIdx];\n          t.month = month;\n          t.day = 1;\n          var first_week = t.weekNumber(this.rule.wkst);\n          t.day = ICAL.Time.daysInMonth(month, aYear);\n          var last_week = t.weekNumber(this.rule.wkst);\n          for (monthIdx = first_week; monthIdx < last_week; monthIdx++) {\n            validWeeks[monthIdx] = 1;\n          }\n        }\n\n        for (var weekIdx = 0; weekIdx < this.by_data.BYWEEKNO.length && valid; weekIdx++) {\n          var weekno = this.by_data.BYWEEKNO[weekIdx];\n          if (weekno < 52) {\n            valid &= validWeeks[weekIdx];\n          } else {\n            valid = 0;\n          }\n        }\n\n        if (valid) {\n          delete parts.BYMONTH;\n        } else {\n          delete parts.BYWEEKNO;\n        }\n      }\n\n      var partCount = Object.keys(parts).length;\n\n      if (partCount == 0) {\n        var t1 = this.dtstart.clone();\n        t1.year = this.last.year;\n        this.days.push(t1.dayOfYear());\n      } else if (partCount == 1 && \"BYMONTH\" in parts) {\n        for (var monthkey in this.by_data.BYMONTH) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {\n            continue;\n          }\n          var t2 = this.dtstart.clone();\n          t2.year = aYear;\n          t2.month = this.by_data.BYMONTH[monthkey];\n          t2.isDate = true;\n          this.days.push(t2.dayOfYear());\n        }\n      } else if (partCount == 1 && \"BYMONTHDAY\" in parts) {\n        for (var monthdaykey in this.by_data.BYMONTHDAY) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {\n            continue;\n          }\n          var t3 = this.dtstart.clone();\n          var day_ = this.by_data.BYMONTHDAY[monthdaykey];\n          if (day_ < 0) {\n            var daysInMonth = ICAL.Time.daysInMonth(t3.month, aYear);\n            day_ = day_ + daysInMonth + 1;\n          }\n          t3.day = day_;\n          t3.year = aYear;\n          t3.isDate = true;\n          this.days.push(t3.dayOfYear());\n        }\n      } else if (partCount == 2 &&\n                 \"BYMONTHDAY\" in parts &&\n                 \"BYMONTH\" in parts) {\n        for (var monthkey in this.by_data.BYMONTH) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {\n            continue;\n          }\n          var month_ = this.by_data.BYMONTH[monthkey];\n          var daysInMonth = ICAL.Time.daysInMonth(month_, aYear);\n          for (var monthdaykey in this.by_data.BYMONTHDAY) {\n            /* istanbul ignore if */\n            if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {\n              continue;\n            }\n            var day_ = this.by_data.BYMONTHDAY[monthdaykey];\n            if (day_ < 0) {\n              day_ = day_ + daysInMonth + 1;\n            }\n            t.day = day_;\n            t.month = month_;\n            t.year = aYear;\n            t.isDate = true;\n\n            this.days.push(t.dayOfYear());\n          }\n        }\n      } else if (partCount == 1 && \"BYWEEKNO\" in parts) {\n        // TODO unimplemented in libical\n      } else if (partCount == 2 &&\n                 \"BYWEEKNO\" in parts &&\n                 \"BYMONTHDAY\" in parts) {\n        // TODO unimplemented in libical\n      } else if (partCount == 1 && \"BYDAY\" in parts) {\n        this.days = this.days.concat(this.expand_by_day(aYear));\n      } else if (partCount == 2 && \"BYDAY\" in parts && \"BYMONTH\" in parts) {\n        for (var monthkey in this.by_data.BYMONTH) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {\n            continue;\n          }\n          var month = this.by_data.BYMONTH[monthkey];\n          var daysInMonth = ICAL.Time.daysInMonth(month, aYear);\n\n          t.year = aYear;\n          t.month = this.by_data.BYMONTH[monthkey];\n          t.day = 1;\n          t.isDate = true;\n\n          var first_dow = t.dayOfWeek();\n          var doy_offset = t.dayOfYear() - 1;\n\n          t.day = daysInMonth;\n          var last_dow = t.dayOfWeek();\n\n          if (this.has_by_data(\"BYSETPOS\")) {\n            var set_pos_counter = 0;\n            var by_month_day = [];\n            for (var day = 1; day <= daysInMonth; day++) {\n              t.day = day;\n              if (this.is_day_in_byday(t)) {\n                by_month_day.push(day);\n              }\n            }\n\n            for (var spIndex = 0; spIndex < by_month_day.length; spIndex++) {\n              if (this.check_set_position(spIndex + 1) ||\n                  this.check_set_position(spIndex - by_month_day.length)) {\n                this.days.push(doy_offset + by_month_day[spIndex]);\n              }\n            }\n          } else {\n            for (var daycodedkey in this.by_data.BYDAY) {\n              /* istanbul ignore if */\n              if (!this.by_data.BYDAY.hasOwnProperty(daycodedkey)) {\n                continue;\n              }\n              var coded_day = this.by_data.BYDAY[daycodedkey];\n              var bydayParts = this.ruleDayOfWeek(coded_day);\n              var pos = bydayParts[0];\n              var dow = bydayParts[1];\n              var month_day;\n\n              var first_matching_day = ((dow + 7 - first_dow) % 7) + 1;\n              var last_matching_day = daysInMonth - ((last_dow + 7 - dow) % 7);\n\n              if (pos == 0) {\n                for (var day = first_matching_day; day <= daysInMonth; day += 7) {\n                  this.days.push(doy_offset + day);\n                }\n              } else if (pos > 0) {\n                month_day = first_matching_day + (pos - 1) * 7;\n\n                if (month_day <= daysInMonth) {\n                  this.days.push(doy_offset + month_day);\n                }\n              } else {\n                month_day = last_matching_day + (pos + 1) * 7;\n\n                if (month_day > 0) {\n                  this.days.push(doy_offset + month_day);\n                }\n              }\n            }\n          }\n        }\n        // Return dates in order of occurrence (1,2,3,...) instead\n        // of by groups of weekdays (1,8,15,...,2,9,16,...).\n        this.days.sort(function(a, b) { return a - b; }); // Comparator function allows to sort numbers.\n      } else if (partCount == 2 && \"BYDAY\" in parts && \"BYMONTHDAY\" in parts) {\n        var expandedDays = this.expand_by_day(aYear);\n\n        for (var daykey in expandedDays) {\n          /* istanbul ignore if */\n          if (!expandedDays.hasOwnProperty(daykey)) {\n            continue;\n          }\n          var day = expandedDays[daykey];\n          var tt = ICAL.Time.fromDayOfYear(day, aYear);\n          if (this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {\n            this.days.push(day);\n          }\n        }\n      } else if (partCount == 3 &&\n                 \"BYDAY\" in parts &&\n                 \"BYMONTHDAY\" in parts &&\n                 \"BYMONTH\" in parts) {\n        var expandedDays = this.expand_by_day(aYear);\n\n        for (var daykey in expandedDays) {\n          /* istanbul ignore if */\n          if (!expandedDays.hasOwnProperty(daykey)) {\n            continue;\n          }\n          var day = expandedDays[daykey];\n          var tt = ICAL.Time.fromDayOfYear(day, aYear);\n\n          if (this.by_data.BYMONTH.indexOf(tt.month) >= 0 &&\n              this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {\n            this.days.push(day);\n          }\n        }\n      } else if (partCount == 2 && \"BYDAY\" in parts && \"BYWEEKNO\" in parts) {\n        var expandedDays = this.expand_by_day(aYear);\n\n        for (var daykey in expandedDays) {\n          /* istanbul ignore if */\n          if (!expandedDays.hasOwnProperty(daykey)) {\n            continue;\n          }\n          var day = expandedDays[daykey];\n          var tt = ICAL.Time.fromDayOfYear(day, aYear);\n          var weekno = tt.weekNumber(this.rule.wkst);\n\n          if (this.by_data.BYWEEKNO.indexOf(weekno)) {\n            this.days.push(day);\n          }\n        }\n      } else if (partCount == 3 &&\n                 \"BYDAY\" in parts &&\n                 \"BYWEEKNO\" in parts &&\n                 \"BYMONTHDAY\" in parts) {\n        // TODO unimplemted in libical\n      } else if (partCount == 1 && \"BYYEARDAY\" in parts) {\n        this.days = this.days.concat(this.by_data.BYYEARDAY);\n      } else {\n        this.days = [];\n      }\n      return 0;\n    },\n\n    expand_by_day: function expand_by_day(aYear) {\n\n      var days_list = [];\n      var tmp = this.last.clone();\n\n      tmp.year = aYear;\n      tmp.month = 1;\n      tmp.day = 1;\n      tmp.isDate = true;\n\n      var start_dow = tmp.dayOfWeek();\n\n      tmp.month = 12;\n      tmp.day = 31;\n      tmp.isDate = true;\n\n      var end_dow = tmp.dayOfWeek();\n      var end_year_day = tmp.dayOfYear();\n\n      for (var daykey in this.by_data.BYDAY) {\n        /* istanbul ignore if */\n        if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {\n          continue;\n        }\n        var day = this.by_data.BYDAY[daykey];\n        var parts = this.ruleDayOfWeek(day);\n        var pos = parts[0];\n        var dow = parts[1];\n\n        if (pos == 0) {\n          var tmp_start_doy = ((dow + 7 - start_dow) % 7) + 1;\n\n          for (var doy = tmp_start_doy; doy <= end_year_day; doy += 7) {\n            days_list.push(doy);\n          }\n\n        } else if (pos > 0) {\n          var first;\n          if (dow >= start_dow) {\n            first = dow - start_dow + 1;\n          } else {\n            first = dow - start_dow + 8;\n          }\n\n          days_list.push(first + (pos - 1) * 7);\n        } else {\n          var last;\n          pos = -pos;\n\n          if (dow <= end_dow) {\n            last = end_year_day - end_dow + dow;\n          } else {\n            last = end_year_day - end_dow + dow - 7;\n          }\n\n          days_list.push(last - (pos - 1) * 7);\n        }\n      }\n      return days_list;\n    },\n\n    is_day_in_byday: function is_day_in_byday(tt) {\n      for (var daykey in this.by_data.BYDAY) {\n        /* istanbul ignore if */\n        if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {\n          continue;\n        }\n        var day = this.by_data.BYDAY[daykey];\n        var parts = this.ruleDayOfWeek(day);\n        var pos = parts[0];\n        var dow = parts[1];\n        var this_dow = tt.dayOfWeek();\n\n        if ((pos == 0 && dow == this_dow) ||\n            (tt.nthWeekDay(dow, pos) == tt.day)) {\n          return 1;\n        }\n      }\n\n      return 0;\n    },\n\n    /**\n     * Checks if given value is in BYSETPOS.\n     *\n     * @private\n     * @param {Numeric} aPos position to check for.\n     * @return {Boolean} false unless BYSETPOS rules exist\n     *                   and the given value is present in rules.\n     */\n    check_set_position: function check_set_position(aPos) {\n      if (this.has_by_data('BYSETPOS')) {\n        var idx = this.by_data.BYSETPOS.indexOf(aPos);\n        // negative numbers are not false-y\n        return idx !== -1;\n      }\n      return false;\n    },\n\n    sort_byday_rules: function icalrecur_sort_byday_rules(aRules) {\n      for (var i = 0; i < aRules.length; i++) {\n        for (var j = 0; j < i; j++) {\n          var one = this.ruleDayOfWeek(aRules[j], this.rule.wkst)[1];\n          var two = this.ruleDayOfWeek(aRules[i], this.rule.wkst)[1];\n\n          if (one > two) {\n            var tmp = aRules[i];\n            aRules[i] = aRules[j];\n            aRules[j] = tmp;\n          }\n        }\n      }\n    },\n\n    check_contract_restriction: function check_contract_restriction(aRuleType, v) {\n      var indexMapValue = icalrecur_iterator._indexMap[aRuleType];\n      var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];\n      var pass = false;\n\n      if (aRuleType in this.by_data &&\n          ruleMapValue == icalrecur_iterator.CONTRACT) {\n\n        var ruleType = this.by_data[aRuleType];\n\n        for (var bydatakey in ruleType) {\n          /* istanbul ignore else */\n          if (ruleType.hasOwnProperty(bydatakey)) {\n            if (ruleType[bydatakey] == v) {\n              pass = true;\n              break;\n            }\n          }\n        }\n      } else {\n        // Not a contracting byrule or has no data, test passes\n        pass = true;\n      }\n      return pass;\n    },\n\n    check_contracting_rules: function check_contracting_rules() {\n      var dow = this.last.dayOfWeek();\n      var weekNo = this.last.weekNumber(this.rule.wkst);\n      var doy = this.last.dayOfYear();\n\n      return (this.check_contract_restriction(\"BYSECOND\", this.last.second) &&\n              this.check_contract_restriction(\"BYMINUTE\", this.last.minute) &&\n              this.check_contract_restriction(\"BYHOUR\", this.last.hour) &&\n              this.check_contract_restriction(\"BYDAY\", ICAL.Recur.numericDayToIcalDay(dow)) &&\n              this.check_contract_restriction(\"BYWEEKNO\", weekNo) &&\n              this.check_contract_restriction(\"BYMONTHDAY\", this.last.day) &&\n              this.check_contract_restriction(\"BYMONTH\", this.last.month) &&\n              this.check_contract_restriction(\"BYYEARDAY\", doy));\n    },\n\n    setup_defaults: function setup_defaults(aRuleType, req, deftime) {\n      var indexMapValue = icalrecur_iterator._indexMap[aRuleType];\n      var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];\n\n      if (ruleMapValue != icalrecur_iterator.CONTRACT) {\n        if (!(aRuleType in this.by_data)) {\n          this.by_data[aRuleType] = [deftime];\n        }\n        if (this.rule.freq != req) {\n          return this.by_data[aRuleType][0];\n        }\n      }\n      return deftime;\n    },\n\n    /**\n     * Convert iterator into a serialize-able object.  Will preserve current\n     * iteration sequence to ensure the seamless continuation of the recurrence\n     * rule.\n     * @return {Object}\n     */\n    toJSON: function() {\n      var result = Object.create(null);\n\n      result.initialized = this.initialized;\n      result.rule = this.rule.toJSON();\n      result.dtstart = this.dtstart.toJSON();\n      result.by_data = this.by_data;\n      result.days = this.days;\n      result.last = this.last.toJSON();\n      result.by_indices = this.by_indices;\n      result.occurrence_number = this.occurrence_number;\n\n      return result;\n    }\n  };\n\n  icalrecur_iterator._indexMap = {\n    \"BYSECOND\": 0,\n    \"BYMINUTE\": 1,\n    \"BYHOUR\": 2,\n    \"BYDAY\": 3,\n    \"BYMONTHDAY\": 4,\n    \"BYYEARDAY\": 5,\n    \"BYWEEKNO\": 6,\n    \"BYMONTH\": 7,\n    \"BYSETPOS\": 8\n  };\n\n  icalrecur_iterator._expandMap = {\n    \"SECONDLY\": [1, 1, 1, 1, 1, 1, 1, 1],\n    \"MINUTELY\": [2, 1, 1, 1, 1, 1, 1, 1],\n    \"HOURLY\": [2, 2, 1, 1, 1, 1, 1, 1],\n    \"DAILY\": [2, 2, 2, 1, 1, 1, 1, 1],\n    \"WEEKLY\": [2, 2, 2, 2, 3, 3, 1, 1],\n    \"MONTHLY\": [2, 2, 2, 2, 2, 3, 3, 1],\n    \"YEARLY\": [2, 2, 2, 2, 2, 2, 2, 2]\n  };\n  icalrecur_iterator.UNKNOWN = 0;\n  icalrecur_iterator.CONTRACT = 1;\n  icalrecur_iterator.EXPAND = 2;\n  icalrecur_iterator.ILLEGAL = 3;\n\n  return icalrecur_iterator;\n\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.RecurExpansion = (function() {\n  function formatTime(item) {\n    return ICAL.helpers.formatClassType(item, ICAL.Time);\n  }\n\n  function compareTime(a, b) {\n    return a.compare(b);\n  }\n\n  function isRecurringComponent(comp) {\n    return comp.hasProperty('rdate') ||\n           comp.hasProperty('rrule') ||\n           comp.hasProperty('recurrence-id');\n  }\n\n  /**\n   * @classdesc\n   * Primary class for expanding recurring rules.  Can take multiple rrules,\n   * rdates, exdate(s) and iterate (in order) over each next occurrence.\n   *\n   * Once initialized this class can also be serialized saved and continue\n   * iteration from the last point.\n   *\n   * NOTE: it is intended that this class is to be used\n   *       with ICAL.Event which handles recurrence exceptions.\n   *\n   * @example\n   * // assuming event is a parsed ical component\n   * var event;\n   *\n   * var expand = new ICAL.RecurExpansion({\n   *   component: event,\n   *   dtstart: event.getFirstPropertyValue('dtstart')\n   * });\n   *\n   * // remember there are infinite rules\n   * // so it is a good idea to limit the scope\n   * // of the iterations then resume later on.\n   *\n   * // next is always an ICAL.Time or null\n   * var next;\n   *\n   * while (someCondition && (next = expand.next())) {\n   *   // do something with next\n   * }\n   *\n   * // save instance for later\n   * var json = JSON.stringify(expand);\n   *\n   * //...\n   *\n   * // NOTE: if the component's properties have\n   * //       changed you will need to rebuild the\n   * //       class and start over. This only works\n   * //       when the component's recurrence info is the same.\n   * var expand = new ICAL.RecurExpansion(JSON.parse(json));\n   *\n   * @description\n   * The options object can be filled with the specified initial values. It can\n   * also contain additional members, as a result of serializing a previous\n   * expansion state, as shown in the example.\n   *\n   * @class\n   * @alias ICAL.RecurExpansion\n   * @param {Object} options\n   *        Recurrence expansion options\n   * @param {ICAL.Time} options.dtstart\n   *        Start time of the event\n   * @param {ICAL.Component=} options.component\n   *        Component for expansion, required if not resuming.\n   */\n  function RecurExpansion(options) {\n    this.ruleDates = [];\n    this.exDates = [];\n    this.fromData(options);\n  }\n\n  RecurExpansion.prototype = {\n    /**\n     * True when iteration is fully completed.\n     * @type {Boolean}\n     */\n    complete: false,\n\n    /**\n     * Array of rrule iterators.\n     *\n     * @type {ICAL.RecurIterator[]}\n     * @private\n     */\n    ruleIterators: null,\n\n    /**\n     * Array of rdate instances.\n     *\n     * @type {ICAL.Time[]}\n     * @private\n     */\n    ruleDates: null,\n\n    /**\n     * Array of exdate instances.\n     *\n     * @type {ICAL.Time[]}\n     * @private\n     */\n    exDates: null,\n\n    /**\n     * Current position in ruleDates array.\n     * @type {Number}\n     * @private\n     */\n    ruleDateInc: 0,\n\n    /**\n     * Current position in exDates array\n     * @type {Number}\n     * @private\n     */\n    exDateInc: 0,\n\n    /**\n     * Current negative date.\n     *\n     * @type {ICAL.Time}\n     * @private\n     */\n    exDate: null,\n\n    /**\n     * Current additional date.\n     *\n     * @type {ICAL.Time}\n     * @private\n     */\n    ruleDate: null,\n\n    /**\n     * Start date of recurring rules.\n     *\n     * @type {ICAL.Time}\n     */\n    dtstart: null,\n\n    /**\n     * Last expanded time\n     *\n     * @type {ICAL.Time}\n     */\n    last: null,\n\n    /**\n     * Initialize the recurrence expansion from the data object. The options\n     * object may also contain additional members, see the\n     * {@link ICAL.RecurExpansion constructor} for more details.\n     *\n     * @param {Object} options\n     *        Recurrence expansion options\n     * @param {ICAL.Time} options.dtstart\n     *        Start time of the event\n     * @param {ICAL.Component=} options.component\n     *        Component for expansion, required if not resuming.\n     */\n    fromData: function(options) {\n      var start = ICAL.helpers.formatClassType(options.dtstart, ICAL.Time);\n\n      if (!start) {\n        throw new Error('.dtstart (ICAL.Time) must be given');\n      } else {\n        this.dtstart = start;\n      }\n\n      if (options.component) {\n        this._init(options.component);\n      } else {\n        this.last = formatTime(options.last) || start.clone();\n\n        if (!options.ruleIterators) {\n          throw new Error('.ruleIterators or .component must be given');\n        }\n\n        this.ruleIterators = options.ruleIterators.map(function(item) {\n          return ICAL.helpers.formatClassType(item, ICAL.RecurIterator);\n        });\n\n        this.ruleDateInc = options.ruleDateInc;\n        this.exDateInc = options.exDateInc;\n\n        if (options.ruleDates) {\n          this.ruleDates = options.ruleDates.map(formatTime);\n          this.ruleDate = this.ruleDates[this.ruleDateInc];\n        }\n\n        if (options.exDates) {\n          this.exDates = options.exDates.map(formatTime);\n          this.exDate = this.exDates[this.exDateInc];\n        }\n\n        if (typeof(options.complete) !== 'undefined') {\n          this.complete = options.complete;\n        }\n      }\n    },\n\n    /**\n     * Retrieve the next occurrence in the series.\n     * @return {ICAL.Time}\n     */\n    next: function() {\n      var iter;\n      var ruleOfDay;\n      var next;\n      var compare;\n\n      var maxTries = 500;\n      var currentTry = 0;\n\n      while (true) {\n        if (currentTry++ > maxTries) {\n          throw new Error(\n            'max tries have occured, rule may be impossible to forfill.'\n          );\n        }\n\n        next = this.ruleDate;\n        iter = this._nextRecurrenceIter(this.last);\n\n        // no more matches\n        // because we increment the rule day or rule\n        // _after_ we choose a value this should be\n        // the only spot where we need to worry about the\n        // end of events.\n        if (!next && !iter) {\n          // there are no more iterators or rdates\n          this.complete = true;\n          break;\n        }\n\n        // no next rule day or recurrence rule is first.\n        if (!next || (iter && next.compare(iter.last) > 0)) {\n          // must be cloned, recur will reuse the time element.\n          next = iter.last.clone();\n          // move to next so we can continue\n          iter.next();\n        }\n\n        // if the ruleDate is still next increment it.\n        if (this.ruleDate === next) {\n          this._nextRuleDay();\n        }\n\n        this.last = next;\n\n        // check the negative rules\n        if (this.exDate) {\n          compare = this.exDate.compare(this.last);\n\n          if (compare < 0) {\n            this._nextExDay();\n          }\n\n          // if the current rule is excluded skip it.\n          if (compare === 0) {\n            this._nextExDay();\n            continue;\n          }\n        }\n\n        //XXX: The spec states that after we resolve the final\n        //     list of dates we execute exdate this seems somewhat counter\n        //     intuitive to what I have seen most servers do so for now\n        //     I exclude based on the original date not the one that may\n        //     have been modified by the exception.\n        return this.last;\n      }\n    },\n\n    /**\n     * Converts object into a serialize-able format. This format can be passed\n     * back into the expansion to resume iteration.\n     * @return {Object}\n     */\n    toJSON: function() {\n      function toJSON(item) {\n        return item.toJSON();\n      }\n\n      var result = Object.create(null);\n      result.ruleIterators = this.ruleIterators.map(toJSON);\n\n      if (this.ruleDates) {\n        result.ruleDates = this.ruleDates.map(toJSON);\n      }\n\n      if (this.exDates) {\n        result.exDates = this.exDates.map(toJSON);\n      }\n\n      result.ruleDateInc = this.ruleDateInc;\n      result.exDateInc = this.exDateInc;\n      result.last = this.last.toJSON();\n      result.dtstart = this.dtstart.toJSON();\n      result.complete = this.complete;\n\n      return result;\n    },\n\n    /**\n     * Extract all dates from the properties in the given component. The\n     * properties will be filtered by the property name.\n     *\n     * @private\n     * @param {ICAL.Component} component        The component to search in\n     * @param {String} propertyName             The property name to search for\n     * @return {ICAL.Time[]}                    The extracted dates.\n     */\n    _extractDates: function(component, propertyName) {\n      function handleProp(prop) {\n        idx = ICAL.helpers.binsearchInsert(\n          result,\n          prop,\n          compareTime\n        );\n\n        // ordered insert\n        result.splice(idx, 0, prop);\n      }\n\n      var result = [];\n      var props = component.getAllProperties(propertyName);\n      var len = props.length;\n      var i = 0;\n      var prop;\n\n      var idx;\n\n      for (; i < len; i++) {\n        props[i].getValues().forEach(handleProp);\n      }\n\n      return result;\n    },\n\n    /**\n     * Initialize the recurrence expansion.\n     *\n     * @private\n     * @param {ICAL.Component} component    The component to initialize from.\n     */\n    _init: function(component) {\n      this.ruleIterators = [];\n\n      this.last = this.dtstart.clone();\n\n      // to provide api consistency non-recurring\n      // events can also use the iterator though it will\n      // only return a single time.\n      if (!isRecurringComponent(component)) {\n        this.ruleDate = this.last.clone();\n        this.complete = true;\n        return;\n      }\n\n      if (component.hasProperty('rdate')) {\n        this.ruleDates = this._extractDates(component, 'rdate');\n\n        // special hack for cases where first rdate is prior\n        // to the start date. We only check for the first rdate.\n        // This is mostly for google's crazy recurring date logic\n        // (contacts birthdays).\n        if ((this.ruleDates[0]) &&\n            (this.ruleDates[0].compare(this.dtstart) < 0)) {\n\n          this.ruleDateInc = 0;\n          this.last = this.ruleDates[0].clone();\n        } else {\n          this.ruleDateInc = ICAL.helpers.binsearchInsert(\n            this.ruleDates,\n            this.last,\n            compareTime\n          );\n        }\n\n        this.ruleDate = this.ruleDates[this.ruleDateInc];\n      }\n\n      if (component.hasProperty('rrule')) {\n        var rules = component.getAllProperties('rrule');\n        var i = 0;\n        var len = rules.length;\n\n        var rule;\n        var iter;\n\n        for (; i < len; i++) {\n          rule = rules[i].getFirstValue();\n          iter = rule.iterator(this.dtstart);\n          this.ruleIterators.push(iter);\n\n          // increment to the next occurrence so future\n          // calls to next return times beyond the initial iteration.\n          // XXX: I find this suspicious might be a bug?\n          iter.next();\n        }\n      }\n\n      if (component.hasProperty('exdate')) {\n        this.exDates = this._extractDates(component, 'exdate');\n        // if we have a .last day we increment the index to beyond it.\n        this.exDateInc = ICAL.helpers.binsearchInsert(\n          this.exDates,\n          this.last,\n          compareTime\n        );\n\n        this.exDate = this.exDates[this.exDateInc];\n      }\n    },\n\n    /**\n     * Advance to the next exdate\n     * @private\n     */\n    _nextExDay: function() {\n      this.exDate = this.exDates[++this.exDateInc];\n    },\n\n    /**\n     * Advance to the next rule date\n     * @private\n     */\n    _nextRuleDay: function() {\n      this.ruleDate = this.ruleDates[++this.ruleDateInc];\n    },\n\n    /**\n     * Find and return the recurrence rule with the most recent event and\n     * return it.\n     *\n     * @private\n     * @return {?ICAL.RecurIterator}    Found iterator.\n     */\n    _nextRecurrenceIter: function() {\n      var iters = this.ruleIterators;\n\n      if (iters.length === 0) {\n        return null;\n      }\n\n      var len = iters.length;\n      var iter;\n      var iterTime;\n      var iterIdx = 0;\n      var chosenIter;\n\n      // loop through each iterator\n      for (; iterIdx < len; iterIdx++) {\n        iter = iters[iterIdx];\n        iterTime = iter.last;\n\n        // if iteration is complete\n        // then we must exclude it from\n        // the search and remove it.\n        if (iter.completed) {\n          len--;\n          if (iterIdx !== 0) {\n            iterIdx--;\n          }\n          iters.splice(iterIdx, 1);\n          continue;\n        }\n\n        // find the most recent possible choice\n        if (!chosenIter || chosenIter.last.compare(iterTime) > 0) {\n          // that iterator is saved\n          chosenIter = iter;\n        }\n      }\n\n      // the chosen iterator is returned but not mutated\n      // this iterator contains the most recent event.\n      return chosenIter;\n    }\n  };\n\n  return RecurExpansion;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.Event = (function() {\n\n  /**\n   * @classdesc\n   * ICAL.js is organized into multiple layers. The bottom layer is a raw jCal\n   * object, followed by the component/property layer. The highest level is the\n   * event representation, which this class is part of. See the\n   * {@tutorial layers} guide for more details.\n   *\n   * @class\n   * @alias ICAL.Event\n   * @param {ICAL.Component=} component         The ICAL.Component to base this event on\n   * @param {Object} options                    Options for this event\n   * @param {Boolean} options.strictExceptions\n   *          When true, will verify exceptions are related by their UUID\n   * @param {Array<ICAL.Component|ICAL.Event>} options.exceptions\n   *          Exceptions to this event, either as components or events. If not\n   *            specified exceptions will automatically be set in relation of\n   *            component's parent\n   */\n  function Event(component, options) {\n    if (!(component instanceof ICAL.Component)) {\n      options = component;\n      component = null;\n    }\n\n    if (component) {\n      this.component = component;\n    } else {\n      this.component = new ICAL.Component('vevent');\n    }\n\n    this._rangeExceptionCache = Object.create(null);\n    this.exceptions = Object.create(null);\n    this.rangeExceptions = [];\n\n    if (options && options.strictExceptions) {\n      this.strictExceptions = options.strictExceptions;\n    }\n\n    if (options && options.exceptions) {\n      options.exceptions.forEach(this.relateException, this);\n    } else if (this.component.parent && !this.isRecurrenceException()) {\n      this.component.parent.getAllSubcomponents('vevent').forEach(function(event) {\n        if (event.hasProperty('recurrence-id')) {\n          this.relateException(event);\n        }\n      }, this);\n    }\n  }\n\n  Event.prototype = {\n\n    THISANDFUTURE: 'THISANDFUTURE',\n\n    /**\n     * List of related event exceptions.\n     *\n     * @type {ICAL.Event[]}\n     */\n    exceptions: null,\n\n    /**\n     * When true, will verify exceptions are related by their UUID.\n     *\n     * @type {Boolean}\n     */\n    strictExceptions: false,\n\n    /**\n     * Relates a given event exception to this object.  If the given component\n     * does not share the UID of this event it cannot be related and will throw\n     * an exception.\n     *\n     * If this component is an exception it cannot have other exceptions\n     * related to it.\n     *\n     * @param {ICAL.Component|ICAL.Event} obj       Component or event\n     */\n    relateException: function(obj) {\n      if (this.isRecurrenceException()) {\n        throw new Error('cannot relate exception to exceptions');\n      }\n\n      if (obj instanceof ICAL.Component) {\n        obj = new ICAL.Event(obj);\n      }\n\n      if (this.strictExceptions && obj.uid !== this.uid) {\n        throw new Error('attempted to relate unrelated exception');\n      }\n\n      var id = obj.recurrenceId.toString();\n\n      // we don't sort or manage exceptions directly\n      // here the recurrence expander handles that.\n      this.exceptions[id] = obj;\n\n      // index RANGE=THISANDFUTURE exceptions so we can\n      // look them up later in getOccurrenceDetails.\n      if (obj.modifiesFuture()) {\n        var item = [\n          obj.recurrenceId.toUnixTime(), id\n        ];\n\n        // we keep them sorted so we can find the nearest\n        // value later on...\n        var idx = ICAL.helpers.binsearchInsert(\n          this.rangeExceptions,\n          item,\n          compareRangeException\n        );\n\n        this.rangeExceptions.splice(idx, 0, item);\n      }\n    },\n\n    /**\n     * Checks if this record is an exception and has the RANGE=THISANDFUTURE\n     * value.\n     *\n     * @return {Boolean}        True, when exception is within range\n     */\n    modifiesFuture: function() {\n      if (!this.component.hasProperty('recurrence-id')) {\n        return false;\n      }\n\n      var range = this.component.getFirstProperty('recurrence-id').getParameter('range');\n      return range === this.THISANDFUTURE;\n    },\n\n    /**\n     * Finds the range exception nearest to the given date.\n     *\n     * @param {ICAL.Time} time usually an occurrence time of an event\n     * @return {?ICAL.Event} the related event/exception or null\n     */\n    findRangeException: function(time) {\n      if (!this.rangeExceptions.length) {\n        return null;\n      }\n\n      var utc = time.toUnixTime();\n      var idx = ICAL.helpers.binsearchInsert(\n        this.rangeExceptions,\n        [utc],\n        compareRangeException\n      );\n\n      idx -= 1;\n\n      // occurs before\n      if (idx < 0) {\n        return null;\n      }\n\n      var rangeItem = this.rangeExceptions[idx];\n\n      /* istanbul ignore next: sanity check only */\n      if (utc < rangeItem[0]) {\n        return null;\n      }\n\n      return rangeItem[1];\n    },\n\n    /**\n     * This object is returned by {@link ICAL.Event#getOccurrenceDetails getOccurrenceDetails}\n     *\n     * @typedef {Object} occurrenceDetails\n     * @memberof ICAL.Event\n     * @property {ICAL.Time} recurrenceId       The passed in recurrence id\n     * @property {ICAL.Event} item              The occurrence\n     * @property {ICAL.Time} startDate          The start of the occurrence\n     * @property {ICAL.Time} endDate            The end of the occurrence\n     */\n\n    /**\n     * Returns the occurrence details based on its start time.  If the\n     * occurrence has an exception will return the details for that exception.\n     *\n     * NOTE: this method is intend to be used in conjunction\n     *       with the {@link ICAL.Event#iterator iterator} method.\n     *\n     * @param {ICAL.Time} occurrence time occurrence\n     * @return {ICAL.Event.occurrenceDetails} Information about the occurrence\n     */\n    getOccurrenceDetails: function(occurrence) {\n      var id = occurrence.toString();\n      var utcId = occurrence.convertToZone(ICAL.Timezone.utcTimezone).toString();\n      var item;\n      var result = {\n        //XXX: Clone?\n        recurrenceId: occurrence\n      };\n\n      if (id in this.exceptions) {\n        item = result.item = this.exceptions[id];\n        result.startDate = item.startDate;\n        result.endDate = item.endDate;\n        result.item = item;\n      } else if (utcId in this.exceptions) {\n        item = this.exceptions[utcId];\n        result.startDate = item.startDate;\n        result.endDate = item.endDate;\n        result.item = item;\n      } else {\n        // range exceptions (RANGE=THISANDFUTURE) have a\n        // lower priority then direct exceptions but\n        // must be accounted for first. Their item is\n        // always the first exception with the range prop.\n        var rangeExceptionId = this.findRangeException(\n          occurrence\n        );\n        var end;\n\n        if (rangeExceptionId) {\n          var exception = this.exceptions[rangeExceptionId];\n\n          // range exception must modify standard time\n          // by the difference (if any) in start/end times.\n          result.item = exception;\n\n          var startDiff = this._rangeExceptionCache[rangeExceptionId];\n\n          if (!startDiff) {\n            var original = exception.recurrenceId.clone();\n            var newStart = exception.startDate.clone();\n\n            // zones must be same otherwise subtract may be incorrect.\n            original.zone = newStart.zone;\n            startDiff = newStart.subtractDate(original);\n\n            this._rangeExceptionCache[rangeExceptionId] = startDiff;\n          }\n\n          var start = occurrence.clone();\n          start.zone = exception.startDate.zone;\n          start.addDuration(startDiff);\n\n          end = start.clone();\n          end.addDuration(exception.duration);\n\n          result.startDate = start;\n          result.endDate = end;\n        } else {\n          // no range exception standard expansion\n          end = occurrence.clone();\n          end.addDuration(this.duration);\n\n          result.endDate = end;\n          result.startDate = occurrence;\n          result.item = this;\n        }\n      }\n\n      return result;\n    },\n\n    /**\n     * Builds a recur expansion instance for a specific point in time (defaults\n     * to startDate).\n     *\n     * @param {ICAL.Time} startTime     Starting point for expansion\n     * @return {ICAL.RecurExpansion}    Expansion object\n     */\n    iterator: function(startTime) {\n      return new ICAL.RecurExpansion({\n        component: this.component,\n        dtstart: startTime || this.startDate\n      });\n    },\n\n    /**\n     * Checks if the event is recurring\n     *\n     * @return {Boolean}        True, if event is recurring\n     */\n    isRecurring: function() {\n      var comp = this.component;\n      return comp.hasProperty('rrule') || comp.hasProperty('rdate');\n    },\n\n    /**\n     * Checks if the event describes a recurrence exception. See\n     * {@tutorial terminology} for details.\n     *\n     * @return {Boolean}    True, if the event describes a recurrence exception\n     */\n    isRecurrenceException: function() {\n      return this.component.hasProperty('recurrence-id');\n    },\n\n    /**\n     * Returns the types of recurrences this event may have.\n     *\n     * Returned as an object with the following possible keys:\n     *\n     *    - YEARLY\n     *    - MONTHLY\n     *    - WEEKLY\n     *    - DAILY\n     *    - MINUTELY\n     *    - SECONDLY\n     *\n     * @return {Object.<ICAL.Recur.frequencyValues, Boolean>}\n     *          Object of recurrence flags\n     */\n    getRecurrenceTypes: function() {\n      var rules = this.component.getAllProperties('rrule');\n      var i = 0;\n      var len = rules.length;\n      var result = Object.create(null);\n\n      for (; i < len; i++) {\n        var value = rules[i].getFirstValue();\n        result[value.freq] = true;\n      }\n\n      return result;\n    },\n\n    /**\n     * The uid of this event\n     * @type {String}\n     */\n    get uid() {\n      return this._firstProp('uid');\n    },\n\n    set uid(value) {\n      this._setProp('uid', value);\n    },\n\n    /**\n     * The start date\n     * @type {ICAL.Time}\n     */\n    get startDate() {\n      return this._firstProp('dtstart');\n    },\n\n    set startDate(value) {\n      this._setTime('dtstart', value);\n    },\n\n    /**\n     * The end date. This can be the result directly from the property, or the\n     * end date calculated from start date and duration. Setting the property\n     * will remove any duration properties.\n     * @type {ICAL.Time}\n     */\n    get endDate() {\n      var endDate = this._firstProp('dtend');\n      if (!endDate) {\n          var duration = this._firstProp('duration');\n          endDate = this.startDate.clone();\n          if (duration) {\n              endDate.addDuration(duration);\n          } else if (endDate.isDate) {\n              endDate.day += 1;\n          }\n      }\n      return endDate;\n    },\n\n    set endDate(value) {\n      if (this.component.hasProperty('duration')) {\n        this.component.removeProperty('duration');\n      }\n      this._setTime('dtend', value);\n    },\n\n    /**\n     * The duration. This can be the result directly from the property, or the\n     * duration calculated from start date and end date. Setting the property\n     * will remove any `dtend` properties.\n     * @type {ICAL.Duration}\n     */\n    get duration() {\n      var duration = this._firstProp('duration');\n      if (!duration) {\n        return this.endDate.subtractDateTz(this.startDate);\n      }\n      return duration;\n    },\n\n    set duration(value) {\n      if (this.component.hasProperty('dtend')) {\n        this.component.removeProperty('dtend');\n      }\n\n      this._setProp('duration', value);\n    },\n\n    /**\n     * The location of the event.\n     * @type {String}\n     */\n    get location() {\n      return this._firstProp('location');\n    },\n\n    set location(value) {\n      return this._setProp('location', value);\n    },\n\n    /**\n     * The attendees in the event\n     * @type {ICAL.Property[]}\n     * @readonly\n     */\n    get attendees() {\n      //XXX: This is way lame we should have a better\n      //     data structure for this later.\n      return this.component.getAllProperties('attendee');\n    },\n\n\n    /**\n     * The event summary\n     * @type {String}\n     */\n    get summary() {\n      return this._firstProp('summary');\n    },\n\n    set summary(value) {\n      this._setProp('summary', value);\n    },\n\n    /**\n     * The event description.\n     * @type {String}\n     */\n    get description() {\n      return this._firstProp('description');\n    },\n\n    set description(value) {\n      this._setProp('description', value);\n    },\n\n    /**\n     * The event color from [rfc7986](https://datatracker.ietf.org/doc/html/rfc7986)\n     * @type {String}\n     */\n    get color() {\n      return this._firstProp('color');\n    },\n\n    set color(value) {\n      this._setProp('color', value);\n    },\n\n    /**\n     * The organizer value as an uri. In most cases this is a mailto: uri, but\n     * it can also be something else, like urn:uuid:...\n     * @type {String}\n     */\n    get organizer() {\n      return this._firstProp('organizer');\n    },\n\n    set organizer(value) {\n      this._setProp('organizer', value);\n    },\n\n    /**\n     * The sequence value for this event. Used for scheduling\n     * see {@tutorial terminology}.\n     * @type {Number}\n     */\n    get sequence() {\n      return this._firstProp('sequence');\n    },\n\n    set sequence(value) {\n      this._setProp('sequence', value);\n    },\n\n    /**\n     * The recurrence id for this event. See {@tutorial terminology} for details.\n     * @type {ICAL.Time}\n     */\n    get recurrenceId() {\n      return this._firstProp('recurrence-id');\n    },\n\n    set recurrenceId(value) {\n      this._setTime('recurrence-id', value);\n    },\n\n    /**\n     * Set/update a time property's value.\n     * This will also update the TZID of the property.\n     *\n     * TODO: this method handles the case where we are switching\n     * from a known timezone to an implied timezone (one without TZID).\n     * This does _not_ handle the case of moving between a known\n     *  (by TimezoneService) timezone to an unknown timezone...\n     *\n     * We will not add/remove/update the VTIMEZONE subcomponents\n     *  leading to invalid ICAL data...\n     * @private\n     * @param {String} propName     The property name\n     * @param {ICAL.Time} time      The time to set\n     */\n    _setTime: function(propName, time) {\n      var prop = this.component.getFirstProperty(propName);\n\n      if (!prop) {\n        prop = new ICAL.Property(propName);\n        this.component.addProperty(prop);\n      }\n\n      // utc and local don't get a tzid\n      if (\n        time.zone === ICAL.Timezone.localTimezone ||\n        time.zone === ICAL.Timezone.utcTimezone\n      ) {\n        // remove the tzid\n        prop.removeParameter('tzid');\n      } else {\n        prop.setParameter('tzid', time.zone.tzid);\n      }\n\n      prop.setValue(time);\n    },\n\n    _setProp: function(name, value) {\n      this.component.updatePropertyWithValue(name, value);\n    },\n\n    _firstProp: function(name) {\n      return this.component.getFirstPropertyValue(name);\n    },\n\n    /**\n     * The string representation of this event.\n     * @return {String}\n     */\n    toString: function() {\n      return this.component.toString();\n    }\n\n  };\n\n  function compareRangeException(a, b) {\n    if (a[0] > b[0]) return 1;\n    if (b[0] > a[0]) return -1;\n    return 0;\n  }\n\n  return Event;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.ComponentParser = (function() {\n  /**\n   * @classdesc\n   * The ComponentParser is used to process a String or jCal Object,\n   * firing callbacks for various found components, as well as completion.\n   *\n   * @example\n   * var options = {\n   *   // when false no events will be emitted for type\n   *   parseEvent: true,\n   *   parseTimezone: true\n   * };\n   *\n   * var parser = new ICAL.ComponentParser(options);\n   *\n   * parser.onevent(eventComponent) {\n   *   //...\n   * }\n   *\n   * // ontimezone, etc...\n   *\n   * parser.oncomplete = function() {\n   *\n   * };\n   *\n   * parser.process(stringOrComponent);\n   *\n   * @class\n   * @alias ICAL.ComponentParser\n   * @param {Object=} options        Component parser options\n   * @param {Boolean} options.parseEvent        Whether events should be parsed\n   * @param {Boolean} options.parseTimezeone    Whether timezones should be parsed\n   */\n  function ComponentParser(options) {\n    if (typeof(options) === 'undefined') {\n      options = {};\n    }\n\n    var key;\n    for (key in options) {\n      /* istanbul ignore else */\n      if (options.hasOwnProperty(key)) {\n        this[key] = options[key];\n      }\n    }\n  }\n\n  ComponentParser.prototype = {\n\n    /**\n     * When true, parse events\n     *\n     * @type {Boolean}\n     */\n    parseEvent: true,\n\n    /**\n     * When true, parse timezones\n     *\n     * @type {Boolean}\n     */\n    parseTimezone: true,\n\n\n    /* SAX like events here for reference */\n\n    /**\n     * Fired when parsing is complete\n     * @callback\n     */\n    oncomplete: /* istanbul ignore next */ function() {},\n\n    /**\n     * Fired if an error occurs during parsing.\n     *\n     * @callback\n     * @param {Error} err details of error\n     */\n    onerror: /* istanbul ignore next */ function(err) {},\n\n    /**\n     * Fired when a top level component (VTIMEZONE) is found\n     *\n     * @callback\n     * @param {ICAL.Timezone} component     Timezone object\n     */\n    ontimezone: /* istanbul ignore next */ function(component) {},\n\n    /**\n     * Fired when a top level component (VEVENT) is found.\n     *\n     * @callback\n     * @param {ICAL.Event} component    Top level component\n     */\n    onevent: /* istanbul ignore next */ function(component) {},\n\n    /**\n     * Process a string or parse ical object.  This function itself will return\n     * nothing but will start the parsing process.\n     *\n     * Events must be registered prior to calling this method.\n     *\n     * @param {ICAL.Component|String|Object} ical      The component to process,\n     *        either in its final form, as a jCal Object, or string representation\n     */\n    process: function(ical) {\n      //TODO: this is sync now in the future we will have a incremental parser.\n      if (typeof(ical) === 'string') {\n        ical = ICAL.parse(ical);\n      }\n\n      if (!(ical instanceof ICAL.Component)) {\n        ical = new ICAL.Component(ical);\n      }\n\n      var components = ical.getAllSubcomponents();\n      var i = 0;\n      var len = components.length;\n      var component;\n\n      for (; i < len; i++) {\n        component = components[i];\n\n        switch (component.name) {\n          case 'vtimezone':\n            if (this.parseTimezone) {\n              var tzid = component.getFirstPropertyValue('tzid');\n              if (tzid) {\n                this.ontimezone(new ICAL.Timezone({\n                  tzid: tzid,\n                  component: component\n                }));\n              }\n            }\n            break;\n          case 'vevent':\n            if (this.parseEvent) {\n              this.onevent(new ICAL.Event(component));\n            }\n            break;\n          default:\n            continue;\n        }\n      }\n\n      //XXX: ideally we should do a \"nextTick\" here\n      //     so in all cases this is actually async.\n      this.oncomplete();\n    }\n  };\n\n  return ComponentParser;\n}());\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}