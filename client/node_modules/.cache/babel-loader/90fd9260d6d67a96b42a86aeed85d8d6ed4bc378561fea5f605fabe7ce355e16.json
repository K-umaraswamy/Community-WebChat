{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport { asciiAlpha, asciiAlphanumeric, asciiControl, markdownLineEndingOrSpace, unicodePunctuation, unicodeWhitespace } from 'micromark-util-character';\nimport { codes } from 'micromark-util-symbol/codes.js';\nconst wwwPrefix = {\n  tokenize: tokenizeWwwPrefix,\n  partial: true\n};\nconst domain = {\n  tokenize: tokenizeDomain,\n  partial: true\n};\nconst path = {\n  tokenize: tokenizePath,\n  partial: true\n};\nconst trail = {\n  tokenize: tokenizeTrail,\n  partial: true\n};\nconst emailDomainDotTrail = {\n  tokenize: tokenizeEmailDomainDotTrail,\n  partial: true\n};\nconst wwwAutolink = {\n  tokenize: tokenizeWwwAutolink,\n  previous: previousWww\n};\nconst protocolAutolink = {\n  tokenize: tokenizeProtocolAutolink,\n  previous: previousProtocol\n};\nconst emailAutolink = {\n  tokenize: tokenizeEmailAutolink,\n  previous: previousEmail\n};\n\n/** @type {ConstructRecord} */\nconst text = {};\n\n// To do: next major: expose functions that yields extension.\n\n/**\n * Extension for `micromark` that can be passed in `extensions` to enable GFM\n * autolink literal syntax.\n *\n * @type {Extension}\n */\nexport const gfmAutolinkLiteral = {\n  text\n};\n\n/** @type {Code} */\nlet code = codes.digit0;\n\n// Add alphanumerics.\nwhile (code < codes.leftCurlyBrace) {\n  text[code] = emailAutolink;\n  code++;\n  if (code === codes.colon) code = codes.uppercaseA;else if (code === codes.leftSquareBracket) code = codes.lowercaseA;\n}\ntext[codes.plusSign] = emailAutolink;\ntext[codes.dash] = emailAutolink;\ntext[codes.dot] = emailAutolink;\ntext[codes.underscore] = emailAutolink;\ntext[codes.uppercaseH] = [emailAutolink, protocolAutolink];\ntext[codes.lowercaseH] = [emailAutolink, protocolAutolink];\ntext[codes.uppercaseW] = [emailAutolink, wwwAutolink];\ntext[codes.lowercaseW] = [emailAutolink, wwwAutolink];\n\n// To do: perform email autolink literals on events, afterwards.\n// That’s where `markdown-rs` and `cmark-gfm` perform it.\n// It should look for `@`, then for atext backwards, and then for a label\n// forwards.\n// To do: `mailto:`, `xmpp:` protocol as prefix.\n\n/**\n * Email autolink literal.\n *\n * ```markdown\n * > | a contact@example.org b\n *       ^^^^^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeEmailAutolink(effects, ok, nok) {\n  const self = this;\n  /** @type {boolean | undefined} */\n  let dot;\n  /** @type {boolean} */\n  let data;\n  return start;\n\n  /**\n   * Start of email autolink literal.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (!gfmAtext(code) || !previousEmail.call(self, self.previous) || previousUnbalanced(self.events)) {\n      return nok(code);\n    }\n    effects.enter('literalAutolink');\n    effects.enter('literalAutolinkEmail');\n    return atext(code);\n  }\n\n  /**\n   * In email atext.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function atext(code) {\n    if (gfmAtext(code)) {\n      effects.consume(code);\n      return atext;\n    }\n    if (code === codes.atSign) {\n      effects.consume(code);\n      return emailDomain;\n    }\n    return nok(code);\n  }\n\n  /**\n   * In email domain.\n   *\n   * The reference code is a bit overly complex as it handles the `@`, of which\n   * there may be just one.\n   * Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L318>\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailDomain(code) {\n    // Dot followed by alphanumerical (not `-` or `_`).\n    if (code === codes.dot) {\n      return effects.check(emailDomainDotTrail, emailDomainAfter, emailDomainDot)(code);\n    }\n\n    // Alphanumerical, `-`, and `_`.\n    if (code === codes.dash || code === codes.underscore || asciiAlphanumeric(code)) {\n      data = true;\n      effects.consume(code);\n      return emailDomain;\n    }\n\n    // To do: `/` if xmpp.\n\n    // Note: normally we’d truncate trailing punctuation from the link.\n    // However, email autolink literals cannot contain any of those markers,\n    // except for `.`, but that can only occur if it isn’t trailing.\n    // So we can ignore truncating!\n    return emailDomainAfter(code);\n  }\n\n  /**\n   * In email domain, on dot that is not a trail.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *                      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailDomainDot(code) {\n    effects.consume(code);\n    dot = true;\n    return emailDomain;\n  }\n\n  /**\n   * After email domain.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailDomainAfter(code) {\n    // Domain must not be empty, must include a dot, and must end in alphabetical.\n    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L332>.\n    if (data && dot && asciiAlpha(self.previous)) {\n      effects.exit('literalAutolinkEmail');\n      effects.exit('literalAutolink');\n      return ok(code);\n    }\n    return nok(code);\n  }\n}\n\n/**\n * `www` autolink literal.\n *\n * ```markdown\n * > | a www.example.org b\n *       ^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeWwwAutolink(effects, ok, nok) {\n  const self = this;\n  return wwwStart;\n\n  /**\n   * Start of www autolink literal.\n   *\n   * ```markdown\n   * > | www.example.com/a?b#c\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwStart(code) {\n    if (code !== codes.uppercaseW && code !== codes.lowercaseW || !previousWww.call(self, self.previous) || previousUnbalanced(self.events)) {\n      return nok(code);\n    }\n    effects.enter('literalAutolink');\n    effects.enter('literalAutolinkWww');\n    // Note: we *check*, so we can discard the `www.` we parsed.\n    // If it worked, we consider it as a part of the domain.\n    return effects.check(wwwPrefix, effects.attempt(domain, effects.attempt(path, wwwAfter), nok), nok)(code);\n  }\n\n  /**\n   * After a www autolink literal.\n   *\n   * ```markdown\n   * > | www.example.com/a?b#c\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwAfter(code) {\n    effects.exit('literalAutolinkWww');\n    effects.exit('literalAutolink');\n    return ok(code);\n  }\n}\n\n/**\n * Protocol autolink literal.\n *\n * ```markdown\n * > | a https://example.org b\n *       ^^^^^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeProtocolAutolink(effects, ok, nok) {\n  const self = this;\n  let buffer = '';\n  let seen = false;\n  return protocolStart;\n\n  /**\n   * Start of protocol autolink literal.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolStart(code) {\n    if ((code === codes.uppercaseH || code === codes.lowercaseH) && previousProtocol.call(self, self.previous) && !previousUnbalanced(self.events)) {\n      effects.enter('literalAutolink');\n      effects.enter('literalAutolinkHttp');\n      buffer += String.fromCodePoint(code);\n      effects.consume(code);\n      return protocolPrefixInside;\n    }\n    return nok(code);\n  }\n\n  /**\n   * In protocol.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *     ^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolPrefixInside(code) {\n    // `5` is size of `https`\n    if (asciiAlpha(code) && buffer.length < 5) {\n      // @ts-expect-error: definitely number.\n      buffer += String.fromCodePoint(code);\n      effects.consume(code);\n      return protocolPrefixInside;\n    }\n    if (code === codes.colon) {\n      const protocol = buffer.toLowerCase();\n      if (protocol === 'http' || protocol === 'https') {\n        effects.consume(code);\n        return protocolSlashesInside;\n      }\n    }\n    return nok(code);\n  }\n\n  /**\n   * In slashes.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *           ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolSlashesInside(code) {\n    if (code === codes.slash) {\n      effects.consume(code);\n      if (seen) {\n        return afterProtocol;\n      }\n      seen = true;\n      return protocolSlashesInside;\n    }\n    return nok(code);\n  }\n\n  /**\n   * After protocol, before domain.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function afterProtocol(code) {\n    // To do: this is different from `markdown-rs`:\n    // https://github.com/wooorm/markdown-rs/blob/b3a921c761309ae00a51fe348d8a43adbc54b518/src/construct/gfm_autolink_literal.rs#L172-L182\n    return code === codes.eof || asciiControl(code) || markdownLineEndingOrSpace(code) || unicodeWhitespace(code) || unicodePunctuation(code) ? nok(code) : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code);\n  }\n\n  /**\n   * After a protocol autolink literal.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *                              ^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolAfter(code) {\n    effects.exit('literalAutolinkHttp');\n    effects.exit('literalAutolink');\n    return ok(code);\n  }\n}\n\n/**\n * `www` prefix.\n *\n * ```markdown\n * > | a www.example.org b\n *       ^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeWwwPrefix(effects, ok, nok) {\n  let size = 0;\n  return wwwPrefixInside;\n\n  /**\n   * In www prefix.\n   *\n   * ```markdown\n   * > | www.example.com\n   *     ^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwPrefixInside(code) {\n    if ((code === codes.uppercaseW || code === codes.lowercaseW) && size < 3) {\n      size++;\n      effects.consume(code);\n      return wwwPrefixInside;\n    }\n    if (code === codes.dot && size === 3) {\n      effects.consume(code);\n      return wwwPrefixAfter;\n    }\n    return nok(code);\n  }\n\n  /**\n   * After www prefix.\n   *\n   * ```markdown\n   * > | www.example.com\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwPrefixAfter(code) {\n    // If there is *anything*, we can link.\n    return code === codes.eof ? nok(code) : ok(code);\n  }\n}\n\n/**\n * Domain.\n *\n * ```markdown\n * > | a https://example.org b\n *               ^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDomain(effects, ok, nok) {\n  /** @type {boolean | undefined} */\n  let underscoreInLastSegment;\n  /** @type {boolean | undefined} */\n  let underscoreInLastLastSegment;\n  /** @type {boolean | undefined} */\n  let seen;\n  return domainInside;\n\n  /**\n   * In domain.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *             ^^^^^^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function domainInside(code) {\n    // Check whether this marker, which is a trailing punctuation\n    // marker, optionally followed by more trailing markers, and then\n    // followed by an end.\n    if (code === codes.dot || code === codes.underscore) {\n      return effects.check(trail, domainAfter, domainAtPunctuation)(code);\n    }\n\n    // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can\n    // occur, which sounds like ASCII only, but they also support `www.點看.com`,\n    // so that’s Unicode.\n    // Instead of some new production for Unicode alphanumerics, markdown\n    // already has that for Unicode punctuation and whitespace, so use those.\n    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L12>.\n    if (code === codes.eof || markdownLineEndingOrSpace(code) || unicodeWhitespace(code) || code !== codes.dash && unicodePunctuation(code)) {\n      return domainAfter(code);\n    }\n    seen = true;\n    effects.consume(code);\n    return domainInside;\n  }\n\n  /**\n   * In domain, at potential trailing punctuation, that was not trailing.\n   *\n   * ```markdown\n   * > | https://example.com\n   *                    ^\n   * ```\n   *\n   * @type {State}\n   */\n  function domainAtPunctuation(code) {\n    // There is an underscore in the last segment of the domain\n    if (code === codes.underscore) {\n      underscoreInLastSegment = true;\n    }\n    // Otherwise, it’s a `.`: save the last segment underscore in the\n    // penultimate segment slot.\n    else {\n      underscoreInLastLastSegment = underscoreInLastSegment;\n      underscoreInLastSegment = undefined;\n    }\n    effects.consume(code);\n    return domainInside;\n  }\n\n  /**\n   * After domain.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *                        ^\n   * ```\n   *\n   * @type {State} */\n  function domainAfter(code) {\n    // Note: that’s GH says a dot is needed, but it’s not true:\n    // <https://github.com/github/cmark-gfm/issues/279>\n    if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {\n      return nok(code);\n    }\n    return ok(code);\n  }\n}\n\n/**\n * Path.\n *\n * ```markdown\n * > | a https://example.org/stuff b\n *                          ^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizePath(effects, ok) {\n  let sizeOpen = 0;\n  let sizeClose = 0;\n  return pathInside;\n\n  /**\n   * In path.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *                        ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function pathInside(code) {\n    if (code === codes.leftParenthesis) {\n      sizeOpen++;\n      effects.consume(code);\n      return pathInside;\n    }\n\n    // To do: `markdown-rs` also needs this.\n    // If this is a paren, and there are less closings than openings,\n    // we don’t check for a trail.\n    if (code === codes.rightParenthesis && sizeClose < sizeOpen) {\n      return pathAtPunctuation(code);\n    }\n\n    // Check whether this trailing punctuation marker is optionally\n    // followed by more trailing markers, and then followed\n    // by an end.\n    if (code === codes.exclamationMark || code === codes.quotationMark || code === codes.ampersand || code === codes.apostrophe || code === codes.rightParenthesis || code === codes.asterisk || code === codes.comma || code === codes.dot || code === codes.colon || code === codes.semicolon || code === codes.lessThan || code === codes.questionMark || code === codes.rightSquareBracket || code === codes.underscore || code === codes.tilde) {\n      return effects.check(trail, ok, pathAtPunctuation)(code);\n    }\n    if (code === codes.eof || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {\n      return ok(code);\n    }\n    effects.consume(code);\n    return pathInside;\n  }\n\n  /**\n   * In path, at potential trailing punctuation, that was not trailing.\n   *\n   * ```markdown\n   * > | https://example.com/a\"b\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function pathAtPunctuation(code) {\n    // Count closing parens.\n    if (code === codes.rightParenthesis) {\n      sizeClose++;\n    }\n    effects.consume(code);\n    return pathInside;\n  }\n}\n\n/**\n * Trail.\n *\n * This calls `ok` if this *is* the trail, followed by an end, which means\n * the entire trail is not part of the link.\n * It calls `nok` if this *is* part of the link.\n *\n * ```markdown\n * > | https://example.com\").\n *                        ^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeTrail(effects, ok, nok) {\n  return trail;\n\n  /**\n   * In trail of domain or path.\n   *\n   * ```markdown\n   * > | https://example.com\").\n   *                        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trail(code) {\n    // Regular trailing punctuation.\n    if (code === codes.exclamationMark || code === codes.quotationMark || code === codes.apostrophe || code === codes.rightParenthesis || code === codes.asterisk || code === codes.comma || code === codes.dot || code === codes.colon || code === codes.semicolon || code === codes.questionMark || code === codes.underscore || code === codes.tilde) {\n      effects.consume(code);\n      return trail;\n    }\n\n    // `&` followed by one or more alphabeticals and then a `;`, is\n    // as a whole considered as trailing punctuation.\n    // In all other cases, it is considered as continuation of the URL.\n    if (code === codes.ampersand) {\n      effects.consume(code);\n      return trailCharRefStart;\n    }\n\n    // Needed because we allow literals after `[`, as we fix:\n    // <https://github.com/github/cmark-gfm/issues/278>.\n    // Check that it is not followed by `(` or `[`.\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code);\n      return trailBracketAfter;\n    }\n    if (\n    // `<` is an end.\n    code === codes.lessThan ||\n    // So is whitespace.\n    code === codes.eof || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {\n      return ok(code);\n    }\n    return nok(code);\n  }\n\n  /**\n   * In trail, after `]`.\n   *\n   * > 👉 **Note**: this deviates from `cmark-gfm` to fix a bug.\n   * > See end of <https://github.com/github/cmark-gfm/issues/278> for more.\n   *\n   * ```markdown\n   * > | https://example.com](\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trailBracketAfter(code) {\n    // Whitespace or something that could start a resource or reference is the end.\n    // Switch back to trail otherwise.\n    if (code === codes.eof || code === codes.leftParenthesis || code === codes.leftSquareBracket || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {\n      return ok(code);\n    }\n    return trail(code);\n  }\n\n  /**\n   * In character-reference like trail, after `&`.\n   *\n   * ```markdown\n   * > | https://example.com&amp;).\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trailCharRefStart(code) {\n    // When non-alpha, it’s not a trail.\n    return asciiAlpha(code) ? trailCharRefInside(code) : nok(code);\n  }\n\n  /**\n   * In character-reference like trail.\n   *\n   * ```markdown\n   * > | https://example.com&amp;).\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trailCharRefInside(code) {\n    // Switch back to trail if this is well-formed.\n    if (code === codes.semicolon) {\n      effects.consume(code);\n      return trail;\n    }\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      return trailCharRefInside;\n    }\n\n    // It’s not a trail.\n    return nok(code);\n  }\n}\n\n/**\n * Dot in email domain trail.\n *\n * This calls `ok` if this *is* the trail, followed by an end, which means\n * the trail is not part of the link.\n * It calls `nok` if this *is* part of the link.\n *\n * ```markdown\n * > | contact@example.org.\n *                        ^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeEmailDomainDotTrail(effects, ok, nok) {\n  return start;\n\n  /**\n   * Dot.\n   *\n   * ```markdown\n   * > | contact@example.org.\n   *                    ^   ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // Must be dot.\n    effects.consume(code);\n    return after;\n  }\n\n  /**\n   * After dot.\n   *\n   * ```markdown\n   * > | contact@example.org.\n   *                     ^   ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // Not a trail if alphanumeric.\n    return asciiAlphanumeric(code) ? nok(code) : ok(code);\n  }\n}\n\n/**\n * See:\n * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L156>.\n *\n * @type {Previous}\n */\nfunction previousWww(code) {\n  return code === codes.eof || code === codes.leftParenthesis || code === codes.asterisk || code === codes.underscore || code === codes.leftSquareBracket || code === codes.rightSquareBracket || code === codes.tilde || markdownLineEndingOrSpace(code);\n}\n\n/**\n * See:\n * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L214>.\n *\n * @type {Previous}\n */\nfunction previousProtocol(code) {\n  return !asciiAlpha(code);\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Previous}\n */\nfunction previousEmail(code) {\n  // Do not allow a slash “inside” atext.\n  // The reference code is a bit weird, but that’s what it results in.\n  // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L307>.\n  // Other than slash, every preceding character is allowed.\n  return !(code === codes.slash || gfmAtext(code));\n}\n\n/**\n * @param {Code} code\n * @returns {boolean}\n */\nfunction gfmAtext(code) {\n  return code === codes.plusSign || code === codes.dash || code === codes.dot || code === codes.underscore || asciiAlphanumeric(code);\n}\n\n/**\n * @param {Array<Event>} events\n * @returns {boolean}\n */\nfunction previousUnbalanced(events) {\n  let index = events.length;\n  let result = false;\n  while (index--) {\n    const token = events[index][1];\n    if ((token.type === 'labelLink' || token.type === 'labelImage') && !token._balanced) {\n      result = true;\n      break;\n    }\n\n    // If we’ve seen this token, and it was marked as not having any unbalanced\n    // bracket before it, we can exit.\n    if (token._gfmAutolinkLiteralWalkedInto) {\n      result = false;\n      break;\n    }\n  }\n  if (events.length > 0 && !result) {\n    // Mark the last token as “walked into” w/o finding\n    // anything.\n    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;\n  }\n  return result;\n}","map":{"version":3,"names":["asciiAlpha","asciiAlphanumeric","asciiControl","markdownLineEndingOrSpace","unicodePunctuation","unicodeWhitespace","codes","wwwPrefix","tokenize","tokenizeWwwPrefix","partial","domain","tokenizeDomain","path","tokenizePath","trail","tokenizeTrail","emailDomainDotTrail","tokenizeEmailDomainDotTrail","wwwAutolink","tokenizeWwwAutolink","previous","previousWww","protocolAutolink","tokenizeProtocolAutolink","previousProtocol","emailAutolink","tokenizeEmailAutolink","previousEmail","text","gfmAutolinkLiteral","code","digit0","leftCurlyBrace","colon","uppercaseA","leftSquareBracket","lowercaseA","plusSign","dash","dot","underscore","uppercaseH","lowercaseH","uppercaseW","lowercaseW","effects","ok","nok","self","data","start","gfmAtext","call","previousUnbalanced","events","enter","atext","consume","atSign","emailDomain","check","emailDomainAfter","emailDomainDot","exit","wwwStart","attempt","wwwAfter","buffer","seen","protocolStart","String","fromCodePoint","protocolPrefixInside","length","protocol","toLowerCase","protocolSlashesInside","slash","afterProtocol","eof","protocolAfter","size","wwwPrefixInside","wwwPrefixAfter","underscoreInLastSegment","underscoreInLastLastSegment","domainInside","domainAfter","domainAtPunctuation","undefined","sizeOpen","sizeClose","pathInside","leftParenthesis","rightParenthesis","pathAtPunctuation","exclamationMark","quotationMark","ampersand","apostrophe","asterisk","comma","semicolon","lessThan","questionMark","rightSquareBracket","tilde","trailCharRefStart","trailBracketAfter","trailCharRefInside","after","index","result","token","type","_balanced","_gfmAutolinkLiteralWalkedInto"],"sources":["C:/Users/Amlanjyoti Pegu/Desktop/Community_Chat-project/client/node_modules/micromark-extension-gfm-autolink-literal/dev/lib/syntax.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  asciiControl,\n  markdownLineEndingOrSpace,\n  unicodePunctuation,\n  unicodeWhitespace\n} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\n\nconst wwwPrefix = {tokenize: tokenizeWwwPrefix, partial: true}\nconst domain = {tokenize: tokenizeDomain, partial: true}\nconst path = {tokenize: tokenizePath, partial: true}\nconst trail = {tokenize: tokenizeTrail, partial: true}\nconst emailDomainDotTrail = {\n  tokenize: tokenizeEmailDomainDotTrail,\n  partial: true\n}\n\nconst wwwAutolink = {tokenize: tokenizeWwwAutolink, previous: previousWww}\nconst protocolAutolink = {\n  tokenize: tokenizeProtocolAutolink,\n  previous: previousProtocol\n}\nconst emailAutolink = {tokenize: tokenizeEmailAutolink, previous: previousEmail}\n\n/** @type {ConstructRecord} */\nconst text = {}\n\n// To do: next major: expose functions that yields extension.\n\n/**\n * Extension for `micromark` that can be passed in `extensions` to enable GFM\n * autolink literal syntax.\n *\n * @type {Extension}\n */\nexport const gfmAutolinkLiteral = {text}\n\n/** @type {Code} */\nlet code = codes.digit0\n\n// Add alphanumerics.\nwhile (code < codes.leftCurlyBrace) {\n  text[code] = emailAutolink\n  code++\n  if (code === codes.colon) code = codes.uppercaseA\n  else if (code === codes.leftSquareBracket) code = codes.lowercaseA\n}\n\ntext[codes.plusSign] = emailAutolink\ntext[codes.dash] = emailAutolink\ntext[codes.dot] = emailAutolink\ntext[codes.underscore] = emailAutolink\ntext[codes.uppercaseH] = [emailAutolink, protocolAutolink]\ntext[codes.lowercaseH] = [emailAutolink, protocolAutolink]\ntext[codes.uppercaseW] = [emailAutolink, wwwAutolink]\ntext[codes.lowercaseW] = [emailAutolink, wwwAutolink]\n\n// To do: perform email autolink literals on events, afterwards.\n// That’s where `markdown-rs` and `cmark-gfm` perform it.\n// It should look for `@`, then for atext backwards, and then for a label\n// forwards.\n// To do: `mailto:`, `xmpp:` protocol as prefix.\n\n/**\n * Email autolink literal.\n *\n * ```markdown\n * > | a contact@example.org b\n *       ^^^^^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeEmailAutolink(effects, ok, nok) {\n  const self = this\n  /** @type {boolean | undefined} */\n  let dot\n  /** @type {boolean} */\n  let data\n\n  return start\n\n  /**\n   * Start of email autolink literal.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (\n      !gfmAtext(code) ||\n      !previousEmail.call(self, self.previous) ||\n      previousUnbalanced(self.events)\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('literalAutolink')\n    effects.enter('literalAutolinkEmail')\n    return atext(code)\n  }\n\n  /**\n   * In email atext.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function atext(code) {\n    if (gfmAtext(code)) {\n      effects.consume(code)\n      return atext\n    }\n\n    if (code === codes.atSign) {\n      effects.consume(code)\n      return emailDomain\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In email domain.\n   *\n   * The reference code is a bit overly complex as it handles the `@`, of which\n   * there may be just one.\n   * Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L318>\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailDomain(code) {\n    // Dot followed by alphanumerical (not `-` or `_`).\n    if (code === codes.dot) {\n      return effects.check(\n        emailDomainDotTrail,\n        emailDomainAfter,\n        emailDomainDot\n      )(code)\n    }\n\n    // Alphanumerical, `-`, and `_`.\n    if (\n      code === codes.dash ||\n      code === codes.underscore ||\n      asciiAlphanumeric(code)\n    ) {\n      data = true\n      effects.consume(code)\n      return emailDomain\n    }\n\n    // To do: `/` if xmpp.\n\n    // Note: normally we’d truncate trailing punctuation from the link.\n    // However, email autolink literals cannot contain any of those markers,\n    // except for `.`, but that can only occur if it isn’t trailing.\n    // So we can ignore truncating!\n    return emailDomainAfter(code)\n  }\n\n  /**\n   * In email domain, on dot that is not a trail.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *                      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailDomainDot(code) {\n    effects.consume(code)\n    dot = true\n    return emailDomain\n  }\n\n  /**\n   * After email domain.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailDomainAfter(code) {\n    // Domain must not be empty, must include a dot, and must end in alphabetical.\n    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L332>.\n    if (data && dot && asciiAlpha(self.previous)) {\n      effects.exit('literalAutolinkEmail')\n      effects.exit('literalAutolink')\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n\n/**\n * `www` autolink literal.\n *\n * ```markdown\n * > | a www.example.org b\n *       ^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeWwwAutolink(effects, ok, nok) {\n  const self = this\n\n  return wwwStart\n\n  /**\n   * Start of www autolink literal.\n   *\n   * ```markdown\n   * > | www.example.com/a?b#c\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwStart(code) {\n    if (\n      (code !== codes.uppercaseW && code !== codes.lowercaseW) ||\n      !previousWww.call(self, self.previous) ||\n      previousUnbalanced(self.events)\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('literalAutolink')\n    effects.enter('literalAutolinkWww')\n    // Note: we *check*, so we can discard the `www.` we parsed.\n    // If it worked, we consider it as a part of the domain.\n    return effects.check(\n      wwwPrefix,\n      effects.attempt(domain, effects.attempt(path, wwwAfter), nok),\n      nok\n    )(code)\n  }\n\n  /**\n   * After a www autolink literal.\n   *\n   * ```markdown\n   * > | www.example.com/a?b#c\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwAfter(code) {\n    effects.exit('literalAutolinkWww')\n    effects.exit('literalAutolink')\n    return ok(code)\n  }\n}\n\n/**\n * Protocol autolink literal.\n *\n * ```markdown\n * > | a https://example.org b\n *       ^^^^^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeProtocolAutolink(effects, ok, nok) {\n  const self = this\n  let buffer = ''\n  let seen = false\n\n  return protocolStart\n\n  /**\n   * Start of protocol autolink literal.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolStart(code) {\n    if (\n      (code === codes.uppercaseH || code === codes.lowercaseH) &&\n      previousProtocol.call(self, self.previous) &&\n      !previousUnbalanced(self.events)\n    ) {\n      effects.enter('literalAutolink')\n      effects.enter('literalAutolinkHttp')\n      buffer += String.fromCodePoint(code)\n      effects.consume(code)\n      return protocolPrefixInside\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In protocol.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *     ^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolPrefixInside(code) {\n    // `5` is size of `https`\n    if (asciiAlpha(code) && buffer.length < 5) {\n      // @ts-expect-error: definitely number.\n      buffer += String.fromCodePoint(code)\n      effects.consume(code)\n      return protocolPrefixInside\n    }\n\n    if (code === codes.colon) {\n      const protocol = buffer.toLowerCase()\n\n      if (protocol === 'http' || protocol === 'https') {\n        effects.consume(code)\n        return protocolSlashesInside\n      }\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In slashes.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *           ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolSlashesInside(code) {\n    if (code === codes.slash) {\n      effects.consume(code)\n\n      if (seen) {\n        return afterProtocol\n      }\n\n      seen = true\n      return protocolSlashesInside\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After protocol, before domain.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function afterProtocol(code) {\n    // To do: this is different from `markdown-rs`:\n    // https://github.com/wooorm/markdown-rs/blob/b3a921c761309ae00a51fe348d8a43adbc54b518/src/construct/gfm_autolink_literal.rs#L172-L182\n    return code === codes.eof ||\n      asciiControl(code) ||\n      markdownLineEndingOrSpace(code) ||\n      unicodeWhitespace(code) ||\n      unicodePunctuation(code)\n      ? nok(code)\n      : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code)\n  }\n\n  /**\n   * After a protocol autolink literal.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *                              ^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolAfter(code) {\n    effects.exit('literalAutolinkHttp')\n    effects.exit('literalAutolink')\n    return ok(code)\n  }\n}\n\n/**\n * `www` prefix.\n *\n * ```markdown\n * > | a www.example.org b\n *       ^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeWwwPrefix(effects, ok, nok) {\n  let size = 0\n\n  return wwwPrefixInside\n\n  /**\n   * In www prefix.\n   *\n   * ```markdown\n   * > | www.example.com\n   *     ^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwPrefixInside(code) {\n    if ((code === codes.uppercaseW || code === codes.lowercaseW) && size < 3) {\n      size++\n      effects.consume(code)\n      return wwwPrefixInside\n    }\n\n    if (code === codes.dot && size === 3) {\n      effects.consume(code)\n      return wwwPrefixAfter\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After www prefix.\n   *\n   * ```markdown\n   * > | www.example.com\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwPrefixAfter(code) {\n    // If there is *anything*, we can link.\n    return code === codes.eof ? nok(code) : ok(code)\n  }\n}\n\n/**\n * Domain.\n *\n * ```markdown\n * > | a https://example.org b\n *               ^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDomain(effects, ok, nok) {\n  /** @type {boolean | undefined} */\n  let underscoreInLastSegment\n  /** @type {boolean | undefined} */\n  let underscoreInLastLastSegment\n  /** @type {boolean | undefined} */\n  let seen\n\n  return domainInside\n\n  /**\n   * In domain.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *             ^^^^^^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function domainInside(code) {\n    // Check whether this marker, which is a trailing punctuation\n    // marker, optionally followed by more trailing markers, and then\n    // followed by an end.\n    if (code === codes.dot || code === codes.underscore) {\n      return effects.check(trail, domainAfter, domainAtPunctuation)(code)\n    }\n\n    // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can\n    // occur, which sounds like ASCII only, but they also support `www.點看.com`,\n    // so that’s Unicode.\n    // Instead of some new production for Unicode alphanumerics, markdown\n    // already has that for Unicode punctuation and whitespace, so use those.\n    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L12>.\n    if (\n      code === codes.eof ||\n      markdownLineEndingOrSpace(code) ||\n      unicodeWhitespace(code) ||\n      (code !== codes.dash && unicodePunctuation(code))\n    ) {\n      return domainAfter(code)\n    }\n\n    seen = true\n    effects.consume(code)\n    return domainInside\n  }\n\n  /**\n   * In domain, at potential trailing punctuation, that was not trailing.\n   *\n   * ```markdown\n   * > | https://example.com\n   *                    ^\n   * ```\n   *\n   * @type {State}\n   */\n  function domainAtPunctuation(code) {\n    // There is an underscore in the last segment of the domain\n    if (code === codes.underscore) {\n      underscoreInLastSegment = true\n    }\n    // Otherwise, it’s a `.`: save the last segment underscore in the\n    // penultimate segment slot.\n    else {\n      underscoreInLastLastSegment = underscoreInLastSegment\n      underscoreInLastSegment = undefined\n    }\n\n    effects.consume(code)\n    return domainInside\n  }\n\n  /**\n   * After domain.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *                        ^\n   * ```\n   *\n   * @type {State} */\n  function domainAfter(code) {\n    // Note: that’s GH says a dot is needed, but it’s not true:\n    // <https://github.com/github/cmark-gfm/issues/279>\n    if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {\n      return nok(code)\n    }\n\n    return ok(code)\n  }\n}\n\n/**\n * Path.\n *\n * ```markdown\n * > | a https://example.org/stuff b\n *                          ^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizePath(effects, ok) {\n  let sizeOpen = 0\n  let sizeClose = 0\n\n  return pathInside\n\n  /**\n   * In path.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *                        ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function pathInside(code) {\n    if (code === codes.leftParenthesis) {\n      sizeOpen++\n      effects.consume(code)\n      return pathInside\n    }\n\n    // To do: `markdown-rs` also needs this.\n    // If this is a paren, and there are less closings than openings,\n    // we don’t check for a trail.\n    if (code === codes.rightParenthesis && sizeClose < sizeOpen) {\n      return pathAtPunctuation(code)\n    }\n\n    // Check whether this trailing punctuation marker is optionally\n    // followed by more trailing markers, and then followed\n    // by an end.\n    if (\n      code === codes.exclamationMark ||\n      code === codes.quotationMark ||\n      code === codes.ampersand ||\n      code === codes.apostrophe ||\n      code === codes.rightParenthesis ||\n      code === codes.asterisk ||\n      code === codes.comma ||\n      code === codes.dot ||\n      code === codes.colon ||\n      code === codes.semicolon ||\n      code === codes.lessThan ||\n      code === codes.questionMark ||\n      code === codes.rightSquareBracket ||\n      code === codes.underscore ||\n      code === codes.tilde\n    ) {\n      return effects.check(trail, ok, pathAtPunctuation)(code)\n    }\n\n    if (\n      code === codes.eof ||\n      markdownLineEndingOrSpace(code) ||\n      unicodeWhitespace(code)\n    ) {\n      return ok(code)\n    }\n\n    effects.consume(code)\n    return pathInside\n  }\n\n  /**\n   * In path, at potential trailing punctuation, that was not trailing.\n   *\n   * ```markdown\n   * > | https://example.com/a\"b\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function pathAtPunctuation(code) {\n    // Count closing parens.\n    if (code === codes.rightParenthesis) {\n      sizeClose++\n    }\n\n    effects.consume(code)\n    return pathInside\n  }\n}\n\n/**\n * Trail.\n *\n * This calls `ok` if this *is* the trail, followed by an end, which means\n * the entire trail is not part of the link.\n * It calls `nok` if this *is* part of the link.\n *\n * ```markdown\n * > | https://example.com\").\n *                        ^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeTrail(effects, ok, nok) {\n  return trail\n\n  /**\n   * In trail of domain or path.\n   *\n   * ```markdown\n   * > | https://example.com\").\n   *                        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trail(code) {\n    // Regular trailing punctuation.\n    if (\n      code === codes.exclamationMark ||\n      code === codes.quotationMark ||\n      code === codes.apostrophe ||\n      code === codes.rightParenthesis ||\n      code === codes.asterisk ||\n      code === codes.comma ||\n      code === codes.dot ||\n      code === codes.colon ||\n      code === codes.semicolon ||\n      code === codes.questionMark ||\n      code === codes.underscore ||\n      code === codes.tilde\n    ) {\n      effects.consume(code)\n      return trail\n    }\n\n    // `&` followed by one or more alphabeticals and then a `;`, is\n    // as a whole considered as trailing punctuation.\n    // In all other cases, it is considered as continuation of the URL.\n    if (code === codes.ampersand) {\n      effects.consume(code)\n      return trailCharRefStart\n    }\n\n    // Needed because we allow literals after `[`, as we fix:\n    // <https://github.com/github/cmark-gfm/issues/278>.\n    // Check that it is not followed by `(` or `[`.\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code)\n      return trailBracketAfter\n    }\n\n    if (\n      // `<` is an end.\n      code === codes.lessThan ||\n      // So is whitespace.\n      code === codes.eof ||\n      markdownLineEndingOrSpace(code) ||\n      unicodeWhitespace(code)\n    ) {\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In trail, after `]`.\n   *\n   * > 👉 **Note**: this deviates from `cmark-gfm` to fix a bug.\n   * > See end of <https://github.com/github/cmark-gfm/issues/278> for more.\n   *\n   * ```markdown\n   * > | https://example.com](\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trailBracketAfter(code) {\n    // Whitespace or something that could start a resource or reference is the end.\n    // Switch back to trail otherwise.\n    if (\n      code === codes.eof ||\n      code === codes.leftParenthesis ||\n      code === codes.leftSquareBracket ||\n      markdownLineEndingOrSpace(code) ||\n      unicodeWhitespace(code)\n    ) {\n      return ok(code)\n    }\n\n    return trail(code)\n  }\n\n  /**\n   * In character-reference like trail, after `&`.\n   *\n   * ```markdown\n   * > | https://example.com&amp;).\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trailCharRefStart(code) {\n    // When non-alpha, it’s not a trail.\n    return asciiAlpha(code) ? trailCharRefInside(code) : nok(code)\n  }\n\n  /**\n   * In character-reference like trail.\n   *\n   * ```markdown\n   * > | https://example.com&amp;).\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trailCharRefInside(code) {\n    // Switch back to trail if this is well-formed.\n    if (code === codes.semicolon) {\n      effects.consume(code)\n      return trail\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return trailCharRefInside\n    }\n\n    // It’s not a trail.\n    return nok(code)\n  }\n}\n\n/**\n * Dot in email domain trail.\n *\n * This calls `ok` if this *is* the trail, followed by an end, which means\n * the trail is not part of the link.\n * It calls `nok` if this *is* part of the link.\n *\n * ```markdown\n * > | contact@example.org.\n *                        ^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeEmailDomainDotTrail(effects, ok, nok) {\n  return start\n\n  /**\n   * Dot.\n   *\n   * ```markdown\n   * > | contact@example.org.\n   *                    ^   ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // Must be dot.\n    effects.consume(code)\n    return after\n  }\n\n  /**\n   * After dot.\n   *\n   * ```markdown\n   * > | contact@example.org.\n   *                     ^   ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // Not a trail if alphanumeric.\n    return asciiAlphanumeric(code) ? nok(code) : ok(code)\n  }\n}\n\n/**\n * See:\n * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L156>.\n *\n * @type {Previous}\n */\nfunction previousWww(code) {\n  return (\n    code === codes.eof ||\n    code === codes.leftParenthesis ||\n    code === codes.asterisk ||\n    code === codes.underscore ||\n    code === codes.leftSquareBracket ||\n    code === codes.rightSquareBracket ||\n    code === codes.tilde ||\n    markdownLineEndingOrSpace(code)\n  )\n}\n\n/**\n * See:\n * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L214>.\n *\n * @type {Previous}\n */\nfunction previousProtocol(code) {\n  return !asciiAlpha(code)\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Previous}\n */\nfunction previousEmail(code) {\n  // Do not allow a slash “inside” atext.\n  // The reference code is a bit weird, but that’s what it results in.\n  // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L307>.\n  // Other than slash, every preceding character is allowed.\n  return !(code === codes.slash || gfmAtext(code))\n}\n\n/**\n * @param {Code} code\n * @returns {boolean}\n */\nfunction gfmAtext(code) {\n  return (\n    code === codes.plusSign ||\n    code === codes.dash ||\n    code === codes.dot ||\n    code === codes.underscore ||\n    asciiAlphanumeric(code)\n  )\n}\n\n/**\n * @param {Array<Event>} events\n * @returns {boolean}\n */\nfunction previousUnbalanced(events) {\n  let index = events.length\n  let result = false\n\n  while (index--) {\n    const token = events[index][1]\n\n    if (\n      (token.type === 'labelLink' || token.type === 'labelImage') &&\n      !token._balanced\n    ) {\n      result = true\n      break\n    }\n\n    // If we’ve seen this token, and it was marked as not having any unbalanced\n    // bracket before it, we can exit.\n    if (token._gfmAutolinkLiteralWalkedInto) {\n      result = false\n      break\n    }\n  }\n\n  if (events.length > 0 && !result) {\n    // Mark the last token as “walked into” w/o finding\n    // anything.\n    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true\n  }\n\n  return result\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}