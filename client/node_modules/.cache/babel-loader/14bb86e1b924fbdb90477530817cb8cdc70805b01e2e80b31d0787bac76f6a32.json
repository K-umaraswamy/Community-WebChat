{"ast":null,"code":"'use strict';\n\n/**\nBase interface for a node in an XML document.\n\n@public\n*/\nclass XmlNode {\n  constructor() {\n    /**\n    Parent node of this node, or `null` if this node has no parent.\n     @type {XmlDocument|XmlElement|null}\n    @public\n    */\n    this.parent = null;\n  }\n\n  /**\n  Document that contains this node, or `null` if this node is not associated\n  with a document.\n   @type {XmlDocument?}\n  @public\n  */\n  get document() {\n    return this.parent ? this.parent.document : null;\n  }\n\n  /**\n  Whether this node is the root node of the document.\n   @returns {boolean}\n  @public\n  */\n  get isRootNode() {\n    return this.parent ? this.parent === this.document : false;\n  }\n\n  /**\n  Whether whitespace should be preserved in the content of this element and\n  its children.\n   This is influenced by the value of the special `xml:space` attribute, and\n  will be `true` for any node whose `xml:space` attribute is set to\n  \"preserve\". If a node has no such attribute, it will inherit the value of\n  the nearest ancestor that does (if any).\n   @type {boolean}\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-white-space\n  @public\n  */\n  get preserveWhitespace() {\n    return Boolean(this.parent && this.parent.preserveWhitespace);\n  }\n\n  /**\n  Type of this node.\n   The value of this property is a string that matches one of the static `TYPE_*`\n  properties on the `XmlNode` class (e.g. `TYPE_ELEMENT`, `TYPE_TEXT`, etc.).\n   The `XmlNode` class itself is a base class and doesn't have its own type name.\n   @type {string}\n  @public\n  */\n  get type() {\n    return '';\n  }\n\n  /**\n  Returns a JSON-serializable object representing this node, minus properties\n  that could result in circular references.\n   @returns {{[key: string]: any}}\n  @public\n  */\n  toJSON() {\n    /** @type {{[key: string]: any}} */\n    let json = {\n      type: this.type\n    };\n    if (this.isRootNode) {\n      json.isRootNode = true;\n    }\n    if (this.preserveWhitespace) {\n      json.preserveWhitespace = true;\n    }\n    return json;\n  }\n}\n\n/**\nType value for an `XmlCdata` node.\n\n@type {string}\n@public\n*/\nXmlNode.TYPE_CDATA = 'cdata';\n\n/**\nType value for an `XmlComment` node.\n\n@type {string}\n@public\n*/\nXmlNode.TYPE_COMMENT = 'comment';\n\n/**\nType value for an `XmlDocument` node.\n\n@type {string}\n@public\n*/\nXmlNode.TYPE_DOCUMENT = 'document';\n\n/**\nType value for an `XmlElement` node.\n\n@type {string}\n@public\n*/\nXmlNode.TYPE_ELEMENT = 'element';\n\n/**\nType value for an `XmlProcessingInstruction` node.\n\n@type {string}\n@public\n*/\nXmlNode.TYPE_PROCESSING_INSTRUCTION = 'pi';\n\n/**\nType value for an `XmlText` node.\n\n@type {string}\n@public\n*/\nXmlNode.TYPE_TEXT = 'text';\nmodule.exports = XmlNode;\n\n/** @typedef {import('./XmlDocument')} XmlDocument */\n/** @typedef {import('./XmlElement')} XmlElement */","map":{"version":3,"names":["XmlNode","constructor","parent","document","isRootNode","preserveWhitespace","Boolean","type","toJSON","json","TYPE_CDATA","TYPE_COMMENT","TYPE_DOCUMENT","TYPE_ELEMENT","TYPE_PROCESSING_INSTRUCTION","TYPE_TEXT","module","exports"],"sources":["C:/Users/Amlanjyoti Pegu/Desktop/Community_Chat-project/client/node_modules/@rgrove/parse-xml/src/lib/XmlNode.js"],"sourcesContent":["'use strict';\n\n/**\nBase interface for a node in an XML document.\n\n@public\n*/\nclass XmlNode {\n  constructor() {\n    /**\n    Parent node of this node, or `null` if this node has no parent.\n\n    @type {XmlDocument|XmlElement|null}\n    @public\n    */\n    this.parent = null;\n  }\n\n  /**\n  Document that contains this node, or `null` if this node is not associated\n  with a document.\n\n  @type {XmlDocument?}\n  @public\n  */\n  get document() {\n    return this.parent\n      ? this.parent.document\n      : null;\n  }\n\n  /**\n  Whether this node is the root node of the document.\n\n  @returns {boolean}\n  @public\n  */\n  get isRootNode() {\n    return this.parent\n      ? this.parent === this.document\n      : false;\n  }\n\n  /**\n  Whether whitespace should be preserved in the content of this element and\n  its children.\n\n  This is influenced by the value of the special `xml:space` attribute, and\n  will be `true` for any node whose `xml:space` attribute is set to\n  \"preserve\". If a node has no such attribute, it will inherit the value of\n  the nearest ancestor that does (if any).\n\n  @type {boolean}\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-white-space\n  @public\n  */\n  get preserveWhitespace() {\n    return Boolean(this.parent && this.parent.preserveWhitespace);\n  }\n\n  /**\n  Type of this node.\n\n  The value of this property is a string that matches one of the static `TYPE_*`\n  properties on the `XmlNode` class (e.g. `TYPE_ELEMENT`, `TYPE_TEXT`, etc.).\n\n  The `XmlNode` class itself is a base class and doesn't have its own type name.\n\n  @type {string}\n  @public\n  */\n  get type() {\n    return '';\n  }\n\n  /**\n  Returns a JSON-serializable object representing this node, minus properties\n  that could result in circular references.\n\n  @returns {{[key: string]: any}}\n  @public\n  */\n  toJSON() {\n    /** @type {{[key: string]: any}} */\n    let json = {\n      type: this.type\n    };\n\n    if (this.isRootNode) {\n      json.isRootNode = true;\n    }\n\n    if (this.preserveWhitespace) {\n      json.preserveWhitespace = true;\n    }\n\n    return json;\n  }\n}\n\n/**\nType value for an `XmlCdata` node.\n\n@type {string}\n@public\n*/\nXmlNode.TYPE_CDATA = 'cdata';\n\n/**\nType value for an `XmlComment` node.\n\n@type {string}\n@public\n*/\nXmlNode.TYPE_COMMENT = 'comment';\n\n/**\nType value for an `XmlDocument` node.\n\n@type {string}\n@public\n*/\nXmlNode.TYPE_DOCUMENT = 'document';\n\n/**\nType value for an `XmlElement` node.\n\n@type {string}\n@public\n*/\nXmlNode.TYPE_ELEMENT = 'element';\n\n/**\nType value for an `XmlProcessingInstruction` node.\n\n@type {string}\n@public\n*/\nXmlNode.TYPE_PROCESSING_INSTRUCTION = 'pi';\n\n/**\nType value for an `XmlText` node.\n\n@type {string}\n@public\n*/\nXmlNode.TYPE_TEXT = 'text';\n\nmodule.exports = XmlNode;\n\n/** @typedef {import('./XmlDocument')} XmlDocument */\n/** @typedef {import('./XmlElement')} XmlElement */\n"],"mappings":"AAAA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA,MAAMA,OAAO,CAAC;EACZC,WAAWA,CAAA,EAAG;IACZ;AACJ;AACA;AACA;AACA;IAEI,IAAI,CAACC,MAAM,GAAG,IAAI;EACpB;;EAEA;AACF;AACA;AACA;AACA;AACA;EAEE,IAAIC,QAAQA,CAAA,EAAG;IACb,OAAO,IAAI,CAACD,MAAM,GACd,IAAI,CAACA,MAAM,CAACC,QAAQ,GACpB,IAAI;EACV;;EAEA;AACF;AACA;AACA;AACA;EAEE,IAAIC,UAAUA,CAAA,EAAG;IACf,OAAO,IAAI,CAACF,MAAM,GACd,IAAI,CAACA,MAAM,KAAK,IAAI,CAACC,QAAQ,GAC7B,KAAK;EACX;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAGE,IAAIE,kBAAkBA,CAAA,EAAG;IACvB,OAAOC,OAAO,CAAC,IAAI,CAACJ,MAAM,IAAI,IAAI,CAACA,MAAM,CAACG,kBAAkB,CAAC;EAC/D;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EAIE,IAAIE,IAAIA,CAAA,EAAG;IACT,OAAO,EAAE;EACX;;EAEA;AACF;AACA;AACA;AACA;AACA;EAEEC,MAAMA,CAAA,EAAG;IACP;IACA,IAAIC,IAAI,GAAG;MACTF,IAAI,EAAE,IAAI,CAACA;IACb,CAAC;IAED,IAAI,IAAI,CAACH,UAAU,EAAE;MACnBK,IAAI,CAACL,UAAU,GAAG,IAAI;IACxB;IAEA,IAAI,IAAI,CAACC,kBAAkB,EAAE;MAC3BI,IAAI,CAACJ,kBAAkB,GAAG,IAAI;IAChC;IAEA,OAAOI,IAAI;EACb;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACAT,OAAO,CAACU,UAAU,GAAG,OAAO;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACAV,OAAO,CAACW,YAAY,GAAG,SAAS;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACAX,OAAO,CAACY,aAAa,GAAG,UAAU;;AAElC;AACA;AACA;AACA;AACA;AACA;AACAZ,OAAO,CAACa,YAAY,GAAG,SAAS;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACAb,OAAO,CAACc,2BAA2B,GAAG,IAAI;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACAd,OAAO,CAACe,SAAS,GAAG,MAAM;AAE1BC,MAAM,CAACC,OAAO,GAAGjB,OAAO;;AAExB;AACA"},"metadata":{},"sourceType":"script","externalDependencies":[]}