{"ast":null,"code":"import { useMemo, useRef } from 'react';\nvar STATUSES_EXCLUDED_FROM_PREPEND = ['sending', 'failed'];\nexport function usePrependedMessagesCount(messages, hasDateSeparator) {\n  var firstRealMessageIndex = hasDateSeparator ? 1 : 0;\n  var firstMessageId = useRef();\n  var earliestMessageId = useRef();\n  var previousNumItemsPrepended = useRef(0);\n  var numItemsPrepended = useMemo(function () {\n    var _a, _b;\n    if (!messages || !messages.length) {\n      previousNumItemsPrepended.current = 0;\n      return 0;\n    }\n    var currentFirstMessageId = (_a = messages === null || messages === void 0 ? void 0 : messages[firstRealMessageIndex]) === null || _a === void 0 ? void 0 : _a.id;\n    // if no new messages were prepended, return early (same amount as before)\n    if (currentFirstMessageId === earliestMessageId.current) {\n      return previousNumItemsPrepended.current;\n    }\n    if (!firstMessageId.current) {\n      firstMessageId.current = currentFirstMessageId;\n    }\n    earliestMessageId.current = currentFirstMessageId;\n    // if new messages were prepended, find out how many\n    // start with this number because there cannot be fewer prepended items than before\n    var adjustPrependedMessageCount = 0;\n    for (var i = previousNumItemsPrepended.current; i < messages.length; i += 1) {\n      // Optimistic UI update, when sending messages, can lead to a situation, when\n      // the order of the messages changes for a moment. This can happen, when a user\n      // sends multiple messages withing few milliseconds. E.g. we send a message A\n      // then message B. At first we have message array with both messages of status \"sending\"\n      // then response for message A is received with a new - later - created_at timestamp\n      // this leads to rearrangement of 1.B (\"sending\"), 2.A (\"received\"). Still firstMessageId.current\n      // points to message A, but now this message has index 1 => previousNumItemsPrepended.current === 1\n      // That in turn leads to incorrect index calculation in VirtualizedMessageList trying to access a message\n      // at non-existent index. Therefore, we ignore messages of status \"sending\" / \"failed\" in order they are\n      // not considered as prepended messages.\n      if (((_b = messages[i]) === null || _b === void 0 ? void 0 : _b.status) &&\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      STATUSES_EXCLUDED_FROM_PREPEND.includes(messages[i].status) && messages[i].id !== firstMessageId.current) {\n        adjustPrependedMessageCount++;\n      }\n      if (messages[i].id === firstMessageId.current) {\n        previousNumItemsPrepended.current = i - adjustPrependedMessageCount;\n        return previousNumItemsPrepended.current;\n      }\n    }\n    // if no match has found, we have jumped - reset the prepended item count.\n    firstMessageId.current = currentFirstMessageId;\n    previousNumItemsPrepended.current = 0;\n    return 0;\n    // TODO: there's a bug here, the messages prop is the same array instance (something mutates it)\n    // that's why the second dependency is necessary\n  }, [messages, messages === null || messages === void 0 ? void 0 : messages.length]);\n  return numItemsPrepended;\n}","map":{"version":3,"names":["useMemo","useRef","STATUSES_EXCLUDED_FROM_PREPEND","usePrependedMessagesCount","messages","hasDateSeparator","firstRealMessageIndex","firstMessageId","earliestMessageId","previousNumItemsPrepended","numItemsPrepended","_a","_b","length","current","currentFirstMessageId","id","adjustPrependedMessageCount","i","status","includes"],"sources":["C:/Users/Amlanjyoti Pegu/Desktop/chat_Web/client/node_modules/stream-chat-react/dist/components/MessageList/hooks/usePrependMessagesCount.js"],"sourcesContent":["import { useMemo, useRef } from 'react';\nvar STATUSES_EXCLUDED_FROM_PREPEND = ['sending', 'failed'];\nexport function usePrependedMessagesCount(messages, hasDateSeparator) {\n    var firstRealMessageIndex = hasDateSeparator ? 1 : 0;\n    var firstMessageId = useRef();\n    var earliestMessageId = useRef();\n    var previousNumItemsPrepended = useRef(0);\n    var numItemsPrepended = useMemo(function () {\n        var _a, _b;\n        if (!messages || !messages.length) {\n            previousNumItemsPrepended.current = 0;\n            return 0;\n        }\n        var currentFirstMessageId = (_a = messages === null || messages === void 0 ? void 0 : messages[firstRealMessageIndex]) === null || _a === void 0 ? void 0 : _a.id;\n        // if no new messages were prepended, return early (same amount as before)\n        if (currentFirstMessageId === earliestMessageId.current) {\n            return previousNumItemsPrepended.current;\n        }\n        if (!firstMessageId.current) {\n            firstMessageId.current = currentFirstMessageId;\n        }\n        earliestMessageId.current = currentFirstMessageId;\n        // if new messages were prepended, find out how many\n        // start with this number because there cannot be fewer prepended items than before\n        var adjustPrependedMessageCount = 0;\n        for (var i = previousNumItemsPrepended.current; i < messages.length; i += 1) {\n            // Optimistic UI update, when sending messages, can lead to a situation, when\n            // the order of the messages changes for a moment. This can happen, when a user\n            // sends multiple messages withing few milliseconds. E.g. we send a message A\n            // then message B. At first we have message array with both messages of status \"sending\"\n            // then response for message A is received with a new - later - created_at timestamp\n            // this leads to rearrangement of 1.B (\"sending\"), 2.A (\"received\"). Still firstMessageId.current\n            // points to message A, but now this message has index 1 => previousNumItemsPrepended.current === 1\n            // That in turn leads to incorrect index calculation in VirtualizedMessageList trying to access a message\n            // at non-existent index. Therefore, we ignore messages of status \"sending\" / \"failed\" in order they are\n            // not considered as prepended messages.\n            if (((_b = messages[i]) === null || _b === void 0 ? void 0 : _b.status) &&\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                STATUSES_EXCLUDED_FROM_PREPEND.includes(messages[i].status) &&\n                messages[i].id !== firstMessageId.current) {\n                adjustPrependedMessageCount++;\n            }\n            if (messages[i].id === firstMessageId.current) {\n                previousNumItemsPrepended.current = i - adjustPrependedMessageCount;\n                return previousNumItemsPrepended.current;\n            }\n        }\n        // if no match has found, we have jumped - reset the prepended item count.\n        firstMessageId.current = currentFirstMessageId;\n        previousNumItemsPrepended.current = 0;\n        return 0;\n        // TODO: there's a bug here, the messages prop is the same array instance (something mutates it)\n        // that's why the second dependency is necessary\n    }, [messages, messages === null || messages === void 0 ? void 0 : messages.length]);\n    return numItemsPrepended;\n}\n"],"mappings":"AAAA,SAASA,OAAO,EAAEC,MAAM,QAAQ,OAAO;AACvC,IAAIC,8BAA8B,GAAG,CAAC,SAAS,EAAE,QAAQ,CAAC;AAC1D,OAAO,SAASC,yBAAyBA,CAACC,QAAQ,EAAEC,gBAAgB,EAAE;EAClE,IAAIC,qBAAqB,GAAGD,gBAAgB,GAAG,CAAC,GAAG,CAAC;EACpD,IAAIE,cAAc,GAAGN,MAAM,CAAC,CAAC;EAC7B,IAAIO,iBAAiB,GAAGP,MAAM,CAAC,CAAC;EAChC,IAAIQ,yBAAyB,GAAGR,MAAM,CAAC,CAAC,CAAC;EACzC,IAAIS,iBAAiB,GAAGV,OAAO,CAAC,YAAY;IACxC,IAAIW,EAAE,EAAEC,EAAE;IACV,IAAI,CAACR,QAAQ,IAAI,CAACA,QAAQ,CAACS,MAAM,EAAE;MAC/BJ,yBAAyB,CAACK,OAAO,GAAG,CAAC;MACrC,OAAO,CAAC;IACZ;IACA,IAAIC,qBAAqB,GAAG,CAACJ,EAAE,GAAGP,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,QAAQ,CAACE,qBAAqB,CAAC,MAAM,IAAI,IAAIK,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACK,EAAE;IACjK;IACA,IAAID,qBAAqB,KAAKP,iBAAiB,CAACM,OAAO,EAAE;MACrD,OAAOL,yBAAyB,CAACK,OAAO;IAC5C;IACA,IAAI,CAACP,cAAc,CAACO,OAAO,EAAE;MACzBP,cAAc,CAACO,OAAO,GAAGC,qBAAqB;IAClD;IACAP,iBAAiB,CAACM,OAAO,GAAGC,qBAAqB;IACjD;IACA;IACA,IAAIE,2BAA2B,GAAG,CAAC;IACnC,KAAK,IAAIC,CAAC,GAAGT,yBAAyB,CAACK,OAAO,EAAEI,CAAC,GAAGd,QAAQ,CAACS,MAAM,EAAEK,CAAC,IAAI,CAAC,EAAE;MACzE;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,IAAI,CAAC,CAACN,EAAE,GAAGR,QAAQ,CAACc,CAAC,CAAC,MAAM,IAAI,IAAIN,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACO,MAAM;MAClE;MACAjB,8BAA8B,CAACkB,QAAQ,CAAChB,QAAQ,CAACc,CAAC,CAAC,CAACC,MAAM,CAAC,IAC3Df,QAAQ,CAACc,CAAC,CAAC,CAACF,EAAE,KAAKT,cAAc,CAACO,OAAO,EAAE;QAC3CG,2BAA2B,EAAE;MACjC;MACA,IAAIb,QAAQ,CAACc,CAAC,CAAC,CAACF,EAAE,KAAKT,cAAc,CAACO,OAAO,EAAE;QAC3CL,yBAAyB,CAACK,OAAO,GAAGI,CAAC,GAAGD,2BAA2B;QACnE,OAAOR,yBAAyB,CAACK,OAAO;MAC5C;IACJ;IACA;IACAP,cAAc,CAACO,OAAO,GAAGC,qBAAqB;IAC9CN,yBAAyB,CAACK,OAAO,GAAG,CAAC;IACrC,OAAO,CAAC;IACR;IACA;EACJ,CAAC,EAAE,CAACV,QAAQ,EAAEA,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,QAAQ,CAACS,MAAM,CAAC,CAAC;EACnF,OAAOH,iBAAiB;AAC5B"},"metadata":{},"sourceType":"module","externalDependencies":[]}