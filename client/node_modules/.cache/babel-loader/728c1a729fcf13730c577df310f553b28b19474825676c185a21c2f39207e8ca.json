{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n */\n\n/**\n * @typedef {import('./infer.js').Align} Align\n */\n\nimport { ok as assert } from 'uvu/assert';\nconst alignment = {\n  none: '',\n  left: ' align=\"left\"',\n  right: ' align=\"right\"',\n  center: ' align=\"center\"'\n};\n\n// To do: next major: expose functions.\n// To do: next major: use `infer` here, when all events are exposed.\n\n/**\n * Extension for `micromark` that can be passed in `htmlExtensions` to support\n * GFM tables when serializing to HTML.\n *\n * @type {HtmlExtension}\n */\nexport const gfmTableHtml = {\n  enter: {\n    table(token) {\n      const tableAlign = token._align;\n      assert(tableAlign, 'expected `_align`');\n      this.lineEndingIfNeeded();\n      this.tag('<table>');\n      this.setData('tableAlign', tableAlign);\n    },\n    tableBody() {\n      this.tag('<tbody>');\n    },\n    tableData() {\n      const tableAlign = this.getData('tableAlign');\n      const tableColumn = this.getData('tableColumn');\n      assert(tableAlign, 'expected `tableAlign`');\n      assert(typeof tableColumn === 'number', 'expected `tableColumn`');\n      const align = alignment[tableAlign[tableColumn]];\n      if (align === undefined) {\n        // Capture results to ignore them.\n        this.buffer();\n      } else {\n        this.lineEndingIfNeeded();\n        this.tag('<td' + align + '>');\n      }\n    },\n    tableHead() {\n      this.lineEndingIfNeeded();\n      this.tag('<thead>');\n    },\n    tableHeader() {\n      const tableAlign = this.getData('tableAlign');\n      const tableColumn = this.getData('tableColumn');\n      assert(tableAlign, 'expected `tableAlign`');\n      assert(typeof tableColumn === 'number', 'expected `tableColumn`');\n      const align = alignment[tableAlign[tableColumn]];\n      this.lineEndingIfNeeded();\n      this.tag('<th' + align + '>');\n    },\n    tableRow() {\n      this.setData('tableColumn', 0);\n      this.lineEndingIfNeeded();\n      this.tag('<tr>');\n    }\n  },\n  exit: {\n    // Overwrite the default code text data handler to unescape escaped pipes when\n    // they are in tables.\n    codeTextData(token) {\n      let value = this.sliceSerialize(token);\n      if (this.getData('tableAlign')) {\n        value = value.replace(/\\\\([\\\\|])/g, replace);\n      }\n      this.raw(this.encode(value));\n    },\n    table() {\n      this.setData('tableAlign');\n      // Note: we don’t set `slurpAllLineEndings` anymore, in delimiter rows,\n      // but we do need to reset it to match a funky newline GH generates for\n      // list items combined with tables.\n      this.setData('slurpAllLineEndings');\n      this.lineEndingIfNeeded();\n      this.tag('</table>');\n    },\n    tableBody() {\n      this.lineEndingIfNeeded();\n      this.tag('</tbody>');\n    },\n    tableData() {\n      const tableAlign = this.getData('tableAlign');\n      const tableColumn = this.getData('tableColumn');\n      assert(tableAlign, 'expected `tableAlign`');\n      assert(typeof tableColumn === 'number', 'expected `tableColumn`');\n      if (tableColumn in tableAlign) {\n        this.tag('</td>');\n        this.setData('tableColumn', tableColumn + 1);\n      } else {\n        // Stop capturing.\n        this.resume();\n      }\n    },\n    tableHead() {\n      this.lineEndingIfNeeded();\n      this.tag('</thead>');\n    },\n    tableHeader() {\n      const tableColumn = this.getData('tableColumn');\n      assert(typeof tableColumn === 'number', 'expected `tableColumn`');\n      this.tag('</th>');\n      this.setData('tableColumn', tableColumn + 1);\n    },\n    tableRow() {\n      const tableAlign = this.getData('tableAlign');\n      let tableColumn = this.getData('tableColumn');\n      assert(tableAlign, 'expected `tableAlign`');\n      assert(typeof tableColumn === 'number', 'expected `tableColumn`');\n      while (tableColumn < tableAlign.length) {\n        this.lineEndingIfNeeded();\n        this.tag('<td' + alignment[tableAlign[tableColumn]] + '></td>');\n        tableColumn++;\n      }\n      this.setData('tableColumn', tableColumn);\n      this.lineEndingIfNeeded();\n      this.tag('</tr>');\n    }\n  }\n};\n\n/**\n * @param {string} $0\n * @param {string} $1\n * @returns {string}\n */\nfunction replace($0, $1) {\n  // Pipes work, backslashes don’t (but can’t escape pipes).\n  return $1 === '|' ? $1 : $0;\n}","map":{"version":3,"names":["ok","assert","alignment","none","left","right","center","gfmTableHtml","enter","table","token","tableAlign","_align","lineEndingIfNeeded","tag","setData","tableBody","tableData","getData","tableColumn","align","undefined","buffer","tableHead","tableHeader","tableRow","exit","codeTextData","value","sliceSerialize","replace","raw","encode","resume","length","$0","$1"],"sources":["C:/Users/Amlanjyoti Pegu/Desktop/Community_Chat-project/client/node_modules/micromark-extension-gfm-table/dev/lib/html.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n */\n\n/**\n * @typedef {import('./infer.js').Align} Align\n */\n\nimport {ok as assert} from 'uvu/assert'\n\nconst alignment = {\n  none: '',\n  left: ' align=\"left\"',\n  right: ' align=\"right\"',\n  center: ' align=\"center\"'\n}\n\n// To do: next major: expose functions.\n// To do: next major: use `infer` here, when all events are exposed.\n\n/**\n * Extension for `micromark` that can be passed in `htmlExtensions` to support\n * GFM tables when serializing to HTML.\n *\n * @type {HtmlExtension}\n */\nexport const gfmTableHtml = {\n  enter: {\n    table(token) {\n      const tableAlign = token._align\n      assert(tableAlign, 'expected `_align`')\n      this.lineEndingIfNeeded()\n      this.tag('<table>')\n      this.setData('tableAlign', tableAlign)\n    },\n    tableBody() {\n      this.tag('<tbody>')\n    },\n    tableData() {\n      const tableAlign = this.getData('tableAlign')\n      const tableColumn = this.getData('tableColumn')\n      assert(tableAlign, 'expected `tableAlign`')\n      assert(typeof tableColumn === 'number', 'expected `tableColumn`')\n      const align = alignment[tableAlign[tableColumn]]\n\n      if (align === undefined) {\n        // Capture results to ignore them.\n        this.buffer()\n      } else {\n        this.lineEndingIfNeeded()\n        this.tag('<td' + align + '>')\n      }\n    },\n    tableHead() {\n      this.lineEndingIfNeeded()\n      this.tag('<thead>')\n    },\n    tableHeader() {\n      const tableAlign = this.getData('tableAlign')\n      const tableColumn = this.getData('tableColumn')\n      assert(tableAlign, 'expected `tableAlign`')\n      assert(typeof tableColumn === 'number', 'expected `tableColumn`')\n      const align = alignment[tableAlign[tableColumn]]\n      this.lineEndingIfNeeded()\n      this.tag('<th' + align + '>')\n    },\n    tableRow() {\n      this.setData('tableColumn', 0)\n      this.lineEndingIfNeeded()\n      this.tag('<tr>')\n    }\n  },\n  exit: {\n    // Overwrite the default code text data handler to unescape escaped pipes when\n    // they are in tables.\n    codeTextData(token) {\n      let value = this.sliceSerialize(token)\n\n      if (this.getData('tableAlign')) {\n        value = value.replace(/\\\\([\\\\|])/g, replace)\n      }\n\n      this.raw(this.encode(value))\n    },\n    table() {\n      this.setData('tableAlign')\n      // Note: we don’t set `slurpAllLineEndings` anymore, in delimiter rows,\n      // but we do need to reset it to match a funky newline GH generates for\n      // list items combined with tables.\n      this.setData('slurpAllLineEndings')\n      this.lineEndingIfNeeded()\n      this.tag('</table>')\n    },\n    tableBody() {\n      this.lineEndingIfNeeded()\n      this.tag('</tbody>')\n    },\n    tableData() {\n      const tableAlign = this.getData('tableAlign')\n      const tableColumn = this.getData('tableColumn')\n      assert(tableAlign, 'expected `tableAlign`')\n      assert(typeof tableColumn === 'number', 'expected `tableColumn`')\n\n      if (tableColumn in tableAlign) {\n        this.tag('</td>')\n        this.setData('tableColumn', tableColumn + 1)\n      } else {\n        // Stop capturing.\n        this.resume()\n      }\n    },\n    tableHead() {\n      this.lineEndingIfNeeded()\n      this.tag('</thead>')\n    },\n    tableHeader() {\n      const tableColumn = this.getData('tableColumn')\n      assert(typeof tableColumn === 'number', 'expected `tableColumn`')\n      this.tag('</th>')\n      this.setData('tableColumn', tableColumn + 1)\n    },\n    tableRow() {\n      const tableAlign = this.getData('tableAlign')\n      let tableColumn = this.getData('tableColumn')\n      assert(tableAlign, 'expected `tableAlign`')\n      assert(typeof tableColumn === 'number', 'expected `tableColumn`')\n\n      while (tableColumn < tableAlign.length) {\n        this.lineEndingIfNeeded()\n        this.tag('<td' + alignment[tableAlign[tableColumn]] + '></td>')\n        tableColumn++\n      }\n\n      this.setData('tableColumn', tableColumn)\n      this.lineEndingIfNeeded()\n      this.tag('</tr>')\n    }\n  }\n}\n\n/**\n * @param {string} $0\n * @param {string} $1\n * @returns {string}\n */\nfunction replace($0, $1) {\n  // Pipes work, backslashes don’t (but can’t escape pipes).\n  return $1 === '|' ? $1 : $0\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}